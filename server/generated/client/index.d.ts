
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model MenuItem
 * 
 */
export type MenuItem = $Result.DefaultSelection<Prisma.$MenuItemPayload>
/**
 * Model MenuVariant
 * 
 */
export type MenuVariant = $Result.DefaultSelection<Prisma.$MenuVariantPayload>
/**
 * Model AddOn
 * 
 */
export type AddOn = $Result.DefaultSelection<Prisma.$AddOnPayload>
/**
 * Model MenuItemAddOn
 * 
 */
export type MenuItemAddOn = $Result.DefaultSelection<Prisma.$MenuItemAddOnPayload>
/**
 * Model ServiceDay
 * *
 *  * ServiceDay is the anchor for daily ops.
 *  * - menuDate: what customer sees/selects ("Monday Menu" date)
 *  * - serviceDate: when it is ready/delivered/picked up (initially next-day)
 *  * Later same-day: menuDate can equal serviceDate on those days.
 */
export type ServiceDay = $Result.DefaultSelection<Prisma.$ServiceDayPayload>
/**
 * Model Menu
 * *
 *  * Menu = a container for a ServiceDay (and optional menuType).
 *  * What’s actually sellable lives in MenuOffering.
 */
export type Menu = $Result.DefaultSelection<Prisma.$MenuPayload>
/**
 * Model MenuOffering
 * *
 *  * MenuOffering = the crucial join table:
 *  * "Variant X is offered on Menu Y with overrides"
 */
export type MenuOffering = $Result.DefaultSelection<Prisma.$MenuOfferingPayload>
/**
 * Model PickupLocation
 * 
 */
export type PickupLocation = $Result.DefaultSelection<Prisma.$PickupLocationPayload>
/**
 * Model Address
 * *
 *  * Address is used for saved addresses AND immutable snapshots.
 *  * For snapshots: isSnapshot=true, userId can be null (guest).
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model SlotTemplate
 * *
 *  * SlotTemplate = reusable slot definition ("5–6pm")
 *  * ServiceSlot = slot instance for a specific ServiceDay (+ fulfillmentType)
 */
export type SlotTemplate = $Result.DefaultSelection<Prisma.$SlotTemplatePayload>
/**
 * Model ServiceSlot
 * 
 */
export type ServiceSlot = $Result.DefaultSelection<Prisma.$ServiceSlotPayload>
/**
 * Model DeliverySettings
 * *
 *  * DeliverySettings: you can keep your tiered distance pricing
 *  * AND store bundling rules for multi-day orders in JSON.
 */
export type DeliverySettings = $Result.DefaultSelection<Prisma.$DeliverySettingsPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model FulfillmentGroup
 * 
 */
export type FulfillmentGroup = $Result.DefaultSelection<Prisma.$FulfillmentGroupPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model OrderItemAddOn
 * 
 */
export type OrderItemAddOn = $Result.DefaultSelection<Prisma.$OrderItemAddOnPayload>
/**
 * Model OrderAdjustment
 * 
 */
export type OrderAdjustment = $Result.DefaultSelection<Prisma.$OrderAdjustmentPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model OrderEvent
 * 
 */
export type OrderEvent = $Result.DefaultSelection<Prisma.$OrderEventPayload>
/**
 * Model CapacityHold
 * *
 *  * Optional: prevents overselling during checkout spikes.
 *  * You can implement later without changing core ordering tables.
 */
export type CapacityHold = $Result.DefaultSelection<Prisma.$CapacityHoldPayload>
/**
 * Model Promotion
 * 
 */
export type Promotion = $Result.DefaultSelection<Prisma.$PromotionPayload>
/**
 * Model PromotionRedemption
 * 
 */
export type PromotionRedemption = $Result.DefaultSelection<Prisma.$PromotionRedemptionPayload>
/**
 * Model RewardAccount
 * 
 */
export type RewardAccount = $Result.DefaultSelection<Prisma.$RewardAccountPayload>
/**
 * Model RewardTransaction
 * 
 */
export type RewardTransaction = $Result.DefaultSelection<Prisma.$RewardTransactionPayload>
/**
 * Model CateringOrder
 * 
 */
export type CateringOrder = $Result.DefaultSelection<Prisma.$CateringOrderPayload>
/**
 * Model CateringItem
 * 
 */
export type CateringItem = $Result.DefaultSelection<Prisma.$CateringItemPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  customer: 'customer',
  employee: 'employee',
  manager: 'manager',
  admin: 'admin'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const MenuType: {
  EVERYDAY: 'EVERYDAY',
  LUNCH: 'LUNCH',
  DINNER: 'DINNER',
  SPECIAL: 'SPECIAL'
};

export type MenuType = (typeof MenuType)[keyof typeof MenuType]


export const FulfillmentType: {
  delivery: 'delivery',
  pickup: 'pickup'
};

export type FulfillmentType = (typeof FulfillmentType)[keyof typeof FulfillmentType]


export const OrderSource: {
  web: 'web',
  admin: 'admin',
  phone: 'phone',
  whatsapp: 'whatsapp',
  ai: 'ai'
};

export type OrderSource = (typeof OrderSource)[keyof typeof OrderSource]


export const OrderCheckoutStatus: {
  draft: 'draft',
  submitted: 'submitted',
  cancelled: 'cancelled'
};

export type OrderCheckoutStatus = (typeof OrderCheckoutStatus)[keyof typeof OrderCheckoutStatus]


export const FulfillmentGroupStatus: {
  pending: 'pending',
  confirmed: 'confirmed',
  preparing: 'preparing',
  out_for_delivery: 'out_for_delivery',
  ready_for_pickup: 'ready_for_pickup',
  completed: 'completed',
  cancelled: 'cancelled'
};

export type FulfillmentGroupStatus = (typeof FulfillmentGroupStatus)[keyof typeof FulfillmentGroupStatus]


export const DeliveryPricingMode: {
  per_order_bundled: 'per_order_bundled',
  per_fulfillment_group: 'per_fulfillment_group'
};

export type DeliveryPricingMode = (typeof DeliveryPricingMode)[keyof typeof DeliveryPricingMode]


export const AdjustmentType: {
  delivery_fee: 'delivery_fee',
  discount: 'discount',
  tax: 'tax',
  tip: 'tip',
  service_fee: 'service_fee',
  manual_adjustment: 'manual_adjustment'
};

export type AdjustmentType = (typeof AdjustmentType)[keyof typeof AdjustmentType]


export const PaymentProvider: {
  stripe: 'stripe',
  manual: 'manual'
};

export type PaymentProvider = (typeof PaymentProvider)[keyof typeof PaymentProvider]


export const PaymentMethod: {
  stripe_card: 'stripe_card',
  cash: 'cash',
  cashapp: 'cashapp',
  zelle: 'zelle',
  venmo: 'venmo',
  other: 'other'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  pending: 'pending',
  authorized: 'authorized',
  paid: 'paid',
  failed: 'failed',
  cancelled: 'cancelled',
  refunded: 'refunded',
  partially_refunded: 'partially_refunded'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const HoldStatus: {
  active: 'active',
  released: 'released',
  converted: 'converted',
  expired: 'expired'
};

export type HoldStatus = (typeof HoldStatus)[keyof typeof HoldStatus]


export const PromotionType: {
  fixed: 'fixed',
  percent: 'percent'
};

export type PromotionType = (typeof PromotionType)[keyof typeof PromotionType]


export const RewardTxnType: {
  earn: 'earn',
  spend: 'spend',
  adjust: 'adjust'
};

export type RewardTxnType = (typeof RewardTxnType)[keyof typeof RewardTxnType]


export const CateringStatus: {
  requested: 'requested',
  approved: 'approved',
  preparing: 'preparing',
  ready: 'ready',
  delivered: 'delivered',
  completed: 'completed',
  cancelled: 'cancelled'
};

export type CateringStatus = (typeof CateringStatus)[keyof typeof CateringStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type MenuType = $Enums.MenuType

export const MenuType: typeof $Enums.MenuType

export type FulfillmentType = $Enums.FulfillmentType

export const FulfillmentType: typeof $Enums.FulfillmentType

export type OrderSource = $Enums.OrderSource

export const OrderSource: typeof $Enums.OrderSource

export type OrderCheckoutStatus = $Enums.OrderCheckoutStatus

export const OrderCheckoutStatus: typeof $Enums.OrderCheckoutStatus

export type FulfillmentGroupStatus = $Enums.FulfillmentGroupStatus

export const FulfillmentGroupStatus: typeof $Enums.FulfillmentGroupStatus

export type DeliveryPricingMode = $Enums.DeliveryPricingMode

export const DeliveryPricingMode: typeof $Enums.DeliveryPricingMode

export type AdjustmentType = $Enums.AdjustmentType

export const AdjustmentType: typeof $Enums.AdjustmentType

export type PaymentProvider = $Enums.PaymentProvider

export const PaymentProvider: typeof $Enums.PaymentProvider

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type HoldStatus = $Enums.HoldStatus

export const HoldStatus: typeof $Enums.HoldStatus

export type PromotionType = $Enums.PromotionType

export const PromotionType: typeof $Enums.PromotionType

export type RewardTxnType = $Enums.RewardTxnType

export const RewardTxnType: typeof $Enums.RewardTxnType

export type CateringStatus = $Enums.CateringStatus

export const CateringStatus: typeof $Enums.CateringStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menuItem`: Exposes CRUD operations for the **MenuItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuItems
    * const menuItems = await prisma.menuItem.findMany()
    * ```
    */
  get menuItem(): Prisma.MenuItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menuVariant`: Exposes CRUD operations for the **MenuVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuVariants
    * const menuVariants = await prisma.menuVariant.findMany()
    * ```
    */
  get menuVariant(): Prisma.MenuVariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addOn`: Exposes CRUD operations for the **AddOn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddOns
    * const addOns = await prisma.addOn.findMany()
    * ```
    */
  get addOn(): Prisma.AddOnDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menuItemAddOn`: Exposes CRUD operations for the **MenuItemAddOn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuItemAddOns
    * const menuItemAddOns = await prisma.menuItemAddOn.findMany()
    * ```
    */
  get menuItemAddOn(): Prisma.MenuItemAddOnDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceDay`: Exposes CRUD operations for the **ServiceDay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceDays
    * const serviceDays = await prisma.serviceDay.findMany()
    * ```
    */
  get serviceDay(): Prisma.ServiceDayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menu`: Exposes CRUD operations for the **Menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menus
    * const menus = await prisma.menu.findMany()
    * ```
    */
  get menu(): Prisma.MenuDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menuOffering`: Exposes CRUD operations for the **MenuOffering** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuOfferings
    * const menuOfferings = await prisma.menuOffering.findMany()
    * ```
    */
  get menuOffering(): Prisma.MenuOfferingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pickupLocation`: Exposes CRUD operations for the **PickupLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PickupLocations
    * const pickupLocations = await prisma.pickupLocation.findMany()
    * ```
    */
  get pickupLocation(): Prisma.PickupLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.slotTemplate`: Exposes CRUD operations for the **SlotTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SlotTemplates
    * const slotTemplates = await prisma.slotTemplate.findMany()
    * ```
    */
  get slotTemplate(): Prisma.SlotTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceSlot`: Exposes CRUD operations for the **ServiceSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceSlots
    * const serviceSlots = await prisma.serviceSlot.findMany()
    * ```
    */
  get serviceSlot(): Prisma.ServiceSlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliverySettings`: Exposes CRUD operations for the **DeliverySettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliverySettings
    * const deliverySettings = await prisma.deliverySettings.findMany()
    * ```
    */
  get deliverySettings(): Prisma.DeliverySettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fulfillmentGroup`: Exposes CRUD operations for the **FulfillmentGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FulfillmentGroups
    * const fulfillmentGroups = await prisma.fulfillmentGroup.findMany()
    * ```
    */
  get fulfillmentGroup(): Prisma.FulfillmentGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItemAddOn`: Exposes CRUD operations for the **OrderItemAddOn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItemAddOns
    * const orderItemAddOns = await prisma.orderItemAddOn.findMany()
    * ```
    */
  get orderItemAddOn(): Prisma.OrderItemAddOnDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderAdjustment`: Exposes CRUD operations for the **OrderAdjustment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderAdjustments
    * const orderAdjustments = await prisma.orderAdjustment.findMany()
    * ```
    */
  get orderAdjustment(): Prisma.OrderAdjustmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderEvent`: Exposes CRUD operations for the **OrderEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderEvents
    * const orderEvents = await prisma.orderEvent.findMany()
    * ```
    */
  get orderEvent(): Prisma.OrderEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.capacityHold`: Exposes CRUD operations for the **CapacityHold** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CapacityHolds
    * const capacityHolds = await prisma.capacityHold.findMany()
    * ```
    */
  get capacityHold(): Prisma.CapacityHoldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotion`: Exposes CRUD operations for the **Promotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotions
    * const promotions = await prisma.promotion.findMany()
    * ```
    */
  get promotion(): Prisma.PromotionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotionRedemption`: Exposes CRUD operations for the **PromotionRedemption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromotionRedemptions
    * const promotionRedemptions = await prisma.promotionRedemption.findMany()
    * ```
    */
  get promotionRedemption(): Prisma.PromotionRedemptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rewardAccount`: Exposes CRUD operations for the **RewardAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RewardAccounts
    * const rewardAccounts = await prisma.rewardAccount.findMany()
    * ```
    */
  get rewardAccount(): Prisma.RewardAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rewardTransaction`: Exposes CRUD operations for the **RewardTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RewardTransactions
    * const rewardTransactions = await prisma.rewardTransaction.findMany()
    * ```
    */
  get rewardTransaction(): Prisma.RewardTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cateringOrder`: Exposes CRUD operations for the **CateringOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CateringOrders
    * const cateringOrders = await prisma.cateringOrder.findMany()
    * ```
    */
  get cateringOrder(): Prisma.CateringOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cateringItem`: Exposes CRUD operations for the **CateringItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CateringItems
    * const cateringItems = await prisma.cateringItem.findMany()
    * ```
    */
  get cateringItem(): Prisma.CateringItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.1.0
   * Query Engine version: ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Category: 'Category',
    MenuItem: 'MenuItem',
    MenuVariant: 'MenuVariant',
    AddOn: 'AddOn',
    MenuItemAddOn: 'MenuItemAddOn',
    ServiceDay: 'ServiceDay',
    Menu: 'Menu',
    MenuOffering: 'MenuOffering',
    PickupLocation: 'PickupLocation',
    Address: 'Address',
    SlotTemplate: 'SlotTemplate',
    ServiceSlot: 'ServiceSlot',
    DeliverySettings: 'DeliverySettings',
    Order: 'Order',
    FulfillmentGroup: 'FulfillmentGroup',
    OrderItem: 'OrderItem',
    OrderItemAddOn: 'OrderItemAddOn',
    OrderAdjustment: 'OrderAdjustment',
    Payment: 'Payment',
    OrderEvent: 'OrderEvent',
    CapacityHold: 'CapacityHold',
    Promotion: 'Promotion',
    PromotionRedemption: 'PromotionRedemption',
    RewardAccount: 'RewardAccount',
    RewardTransaction: 'RewardTransaction',
    CateringOrder: 'CateringOrder',
    CateringItem: 'CateringItem',
    Review: 'Review'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "category" | "menuItem" | "menuVariant" | "addOn" | "menuItemAddOn" | "serviceDay" | "menu" | "menuOffering" | "pickupLocation" | "address" | "slotTemplate" | "serviceSlot" | "deliverySettings" | "order" | "fulfillmentGroup" | "orderItem" | "orderItemAddOn" | "orderAdjustment" | "payment" | "orderEvent" | "capacityHold" | "promotion" | "promotionRedemption" | "rewardAccount" | "rewardTransaction" | "cateringOrder" | "cateringItem" | "review"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      MenuItem: {
        payload: Prisma.$MenuItemPayload<ExtArgs>
        fields: Prisma.MenuItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          findFirst: {
            args: Prisma.MenuItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          findMany: {
            args: Prisma.MenuItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>[]
          }
          create: {
            args: Prisma.MenuItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          createMany: {
            args: Prisma.MenuItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>[]
          }
          delete: {
            args: Prisma.MenuItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          update: {
            args: Prisma.MenuItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          deleteMany: {
            args: Prisma.MenuItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenuItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>[]
          }
          upsert: {
            args: Prisma.MenuItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          aggregate: {
            args: Prisma.MenuItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenuItem>
          }
          groupBy: {
            args: Prisma.MenuItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuItemCountArgs<ExtArgs>
            result: $Utils.Optional<MenuItemCountAggregateOutputType> | number
          }
        }
      }
      MenuVariant: {
        payload: Prisma.$MenuVariantPayload<ExtArgs>
        fields: Prisma.MenuVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuVariantPayload>
          }
          findFirst: {
            args: Prisma.MenuVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuVariantPayload>
          }
          findMany: {
            args: Prisma.MenuVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuVariantPayload>[]
          }
          create: {
            args: Prisma.MenuVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuVariantPayload>
          }
          createMany: {
            args: Prisma.MenuVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuVariantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuVariantPayload>[]
          }
          delete: {
            args: Prisma.MenuVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuVariantPayload>
          }
          update: {
            args: Prisma.MenuVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuVariantPayload>
          }
          deleteMany: {
            args: Prisma.MenuVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenuVariantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuVariantPayload>[]
          }
          upsert: {
            args: Prisma.MenuVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuVariantPayload>
          }
          aggregate: {
            args: Prisma.MenuVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenuVariant>
          }
          groupBy: {
            args: Prisma.MenuVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuVariantCountArgs<ExtArgs>
            result: $Utils.Optional<MenuVariantCountAggregateOutputType> | number
          }
        }
      }
      AddOn: {
        payload: Prisma.$AddOnPayload<ExtArgs>
        fields: Prisma.AddOnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddOnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddOnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>
          }
          findFirst: {
            args: Prisma.AddOnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddOnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>
          }
          findMany: {
            args: Prisma.AddOnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>[]
          }
          create: {
            args: Prisma.AddOnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>
          }
          createMany: {
            args: Prisma.AddOnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddOnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>[]
          }
          delete: {
            args: Prisma.AddOnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>
          }
          update: {
            args: Prisma.AddOnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>
          }
          deleteMany: {
            args: Prisma.AddOnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddOnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddOnUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>[]
          }
          upsert: {
            args: Prisma.AddOnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnPayload>
          }
          aggregate: {
            args: Prisma.AddOnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddOn>
          }
          groupBy: {
            args: Prisma.AddOnGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddOnGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddOnCountArgs<ExtArgs>
            result: $Utils.Optional<AddOnCountAggregateOutputType> | number
          }
        }
      }
      MenuItemAddOn: {
        payload: Prisma.$MenuItemAddOnPayload<ExtArgs>
        fields: Prisma.MenuItemAddOnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuItemAddOnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemAddOnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuItemAddOnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemAddOnPayload>
          }
          findFirst: {
            args: Prisma.MenuItemAddOnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemAddOnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuItemAddOnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemAddOnPayload>
          }
          findMany: {
            args: Prisma.MenuItemAddOnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemAddOnPayload>[]
          }
          create: {
            args: Prisma.MenuItemAddOnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemAddOnPayload>
          }
          createMany: {
            args: Prisma.MenuItemAddOnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuItemAddOnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemAddOnPayload>[]
          }
          delete: {
            args: Prisma.MenuItemAddOnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemAddOnPayload>
          }
          update: {
            args: Prisma.MenuItemAddOnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemAddOnPayload>
          }
          deleteMany: {
            args: Prisma.MenuItemAddOnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuItemAddOnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenuItemAddOnUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemAddOnPayload>[]
          }
          upsert: {
            args: Prisma.MenuItemAddOnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemAddOnPayload>
          }
          aggregate: {
            args: Prisma.MenuItemAddOnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenuItemAddOn>
          }
          groupBy: {
            args: Prisma.MenuItemAddOnGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuItemAddOnGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuItemAddOnCountArgs<ExtArgs>
            result: $Utils.Optional<MenuItemAddOnCountAggregateOutputType> | number
          }
        }
      }
      ServiceDay: {
        payload: Prisma.$ServiceDayPayload<ExtArgs>
        fields: Prisma.ServiceDayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceDayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceDayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDayPayload>
          }
          findFirst: {
            args: Prisma.ServiceDayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceDayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDayPayload>
          }
          findMany: {
            args: Prisma.ServiceDayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDayPayload>[]
          }
          create: {
            args: Prisma.ServiceDayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDayPayload>
          }
          createMany: {
            args: Prisma.ServiceDayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceDayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDayPayload>[]
          }
          delete: {
            args: Prisma.ServiceDayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDayPayload>
          }
          update: {
            args: Prisma.ServiceDayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDayPayload>
          }
          deleteMany: {
            args: Prisma.ServiceDayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceDayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceDayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDayPayload>[]
          }
          upsert: {
            args: Prisma.ServiceDayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDayPayload>
          }
          aggregate: {
            args: Prisma.ServiceDayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceDay>
          }
          groupBy: {
            args: Prisma.ServiceDayGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceDayGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceDayCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceDayCountAggregateOutputType> | number
          }
        }
      }
      Menu: {
        payload: Prisma.$MenuPayload<ExtArgs>
        fields: Prisma.MenuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findFirst: {
            args: Prisma.MenuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findMany: {
            args: Prisma.MenuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          create: {
            args: Prisma.MenuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          createMany: {
            args: Prisma.MenuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          delete: {
            args: Prisma.MenuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          update: {
            args: Prisma.MenuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          deleteMany: {
            args: Prisma.MenuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenuUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          upsert: {
            args: Prisma.MenuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          aggregate: {
            args: Prisma.MenuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenu>
          }
          groupBy: {
            args: Prisma.MenuGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuCountArgs<ExtArgs>
            result: $Utils.Optional<MenuCountAggregateOutputType> | number
          }
        }
      }
      MenuOffering: {
        payload: Prisma.$MenuOfferingPayload<ExtArgs>
        fields: Prisma.MenuOfferingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuOfferingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuOfferingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuOfferingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuOfferingPayload>
          }
          findFirst: {
            args: Prisma.MenuOfferingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuOfferingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuOfferingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuOfferingPayload>
          }
          findMany: {
            args: Prisma.MenuOfferingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuOfferingPayload>[]
          }
          create: {
            args: Prisma.MenuOfferingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuOfferingPayload>
          }
          createMany: {
            args: Prisma.MenuOfferingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuOfferingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuOfferingPayload>[]
          }
          delete: {
            args: Prisma.MenuOfferingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuOfferingPayload>
          }
          update: {
            args: Prisma.MenuOfferingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuOfferingPayload>
          }
          deleteMany: {
            args: Prisma.MenuOfferingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuOfferingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenuOfferingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuOfferingPayload>[]
          }
          upsert: {
            args: Prisma.MenuOfferingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuOfferingPayload>
          }
          aggregate: {
            args: Prisma.MenuOfferingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenuOffering>
          }
          groupBy: {
            args: Prisma.MenuOfferingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuOfferingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuOfferingCountArgs<ExtArgs>
            result: $Utils.Optional<MenuOfferingCountAggregateOutputType> | number
          }
        }
      }
      PickupLocation: {
        payload: Prisma.$PickupLocationPayload<ExtArgs>
        fields: Prisma.PickupLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PickupLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PickupLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>
          }
          findFirst: {
            args: Prisma.PickupLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PickupLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>
          }
          findMany: {
            args: Prisma.PickupLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>[]
          }
          create: {
            args: Prisma.PickupLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>
          }
          createMany: {
            args: Prisma.PickupLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PickupLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>[]
          }
          delete: {
            args: Prisma.PickupLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>
          }
          update: {
            args: Prisma.PickupLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>
          }
          deleteMany: {
            args: Prisma.PickupLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PickupLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PickupLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>[]
          }
          upsert: {
            args: Prisma.PickupLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupLocationPayload>
          }
          aggregate: {
            args: Prisma.PickupLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePickupLocation>
          }
          groupBy: {
            args: Prisma.PickupLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PickupLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PickupLocationCountArgs<ExtArgs>
            result: $Utils.Optional<PickupLocationCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      SlotTemplate: {
        payload: Prisma.$SlotTemplatePayload<ExtArgs>
        fields: Prisma.SlotTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SlotTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SlotTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotTemplatePayload>
          }
          findFirst: {
            args: Prisma.SlotTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SlotTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotTemplatePayload>
          }
          findMany: {
            args: Prisma.SlotTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotTemplatePayload>[]
          }
          create: {
            args: Prisma.SlotTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotTemplatePayload>
          }
          createMany: {
            args: Prisma.SlotTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SlotTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotTemplatePayload>[]
          }
          delete: {
            args: Prisma.SlotTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotTemplatePayload>
          }
          update: {
            args: Prisma.SlotTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotTemplatePayload>
          }
          deleteMany: {
            args: Prisma.SlotTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SlotTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SlotTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotTemplatePayload>[]
          }
          upsert: {
            args: Prisma.SlotTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotTemplatePayload>
          }
          aggregate: {
            args: Prisma.SlotTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSlotTemplate>
          }
          groupBy: {
            args: Prisma.SlotTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<SlotTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.SlotTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<SlotTemplateCountAggregateOutputType> | number
          }
        }
      }
      ServiceSlot: {
        payload: Prisma.$ServiceSlotPayload<ExtArgs>
        fields: Prisma.ServiceSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSlotPayload>
          }
          findFirst: {
            args: Prisma.ServiceSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSlotPayload>
          }
          findMany: {
            args: Prisma.ServiceSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSlotPayload>[]
          }
          create: {
            args: Prisma.ServiceSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSlotPayload>
          }
          createMany: {
            args: Prisma.ServiceSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceSlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSlotPayload>[]
          }
          delete: {
            args: Prisma.ServiceSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSlotPayload>
          }
          update: {
            args: Prisma.ServiceSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSlotPayload>
          }
          deleteMany: {
            args: Prisma.ServiceSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceSlotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSlotPayload>[]
          }
          upsert: {
            args: Prisma.ServiceSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSlotPayload>
          }
          aggregate: {
            args: Prisma.ServiceSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceSlot>
          }
          groupBy: {
            args: Prisma.ServiceSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceSlotCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceSlotCountAggregateOutputType> | number
          }
        }
      }
      DeliverySettings: {
        payload: Prisma.$DeliverySettingsPayload<ExtArgs>
        fields: Prisma.DeliverySettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliverySettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverySettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliverySettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverySettingsPayload>
          }
          findFirst: {
            args: Prisma.DeliverySettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverySettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliverySettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverySettingsPayload>
          }
          findMany: {
            args: Prisma.DeliverySettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverySettingsPayload>[]
          }
          create: {
            args: Prisma.DeliverySettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverySettingsPayload>
          }
          createMany: {
            args: Prisma.DeliverySettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliverySettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverySettingsPayload>[]
          }
          delete: {
            args: Prisma.DeliverySettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverySettingsPayload>
          }
          update: {
            args: Prisma.DeliverySettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverySettingsPayload>
          }
          deleteMany: {
            args: Prisma.DeliverySettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliverySettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliverySettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverySettingsPayload>[]
          }
          upsert: {
            args: Prisma.DeliverySettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverySettingsPayload>
          }
          aggregate: {
            args: Prisma.DeliverySettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliverySettings>
          }
          groupBy: {
            args: Prisma.DeliverySettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliverySettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliverySettingsCountArgs<ExtArgs>
            result: $Utils.Optional<DeliverySettingsCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      FulfillmentGroup: {
        payload: Prisma.$FulfillmentGroupPayload<ExtArgs>
        fields: Prisma.FulfillmentGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FulfillmentGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FulfillmentGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentGroupPayload>
          }
          findFirst: {
            args: Prisma.FulfillmentGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FulfillmentGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentGroupPayload>
          }
          findMany: {
            args: Prisma.FulfillmentGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentGroupPayload>[]
          }
          create: {
            args: Prisma.FulfillmentGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentGroupPayload>
          }
          createMany: {
            args: Prisma.FulfillmentGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FulfillmentGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentGroupPayload>[]
          }
          delete: {
            args: Prisma.FulfillmentGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentGroupPayload>
          }
          update: {
            args: Prisma.FulfillmentGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentGroupPayload>
          }
          deleteMany: {
            args: Prisma.FulfillmentGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FulfillmentGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FulfillmentGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentGroupPayload>[]
          }
          upsert: {
            args: Prisma.FulfillmentGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FulfillmentGroupPayload>
          }
          aggregate: {
            args: Prisma.FulfillmentGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFulfillmentGroup>
          }
          groupBy: {
            args: Prisma.FulfillmentGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<FulfillmentGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.FulfillmentGroupCountArgs<ExtArgs>
            result: $Utils.Optional<FulfillmentGroupCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      OrderItemAddOn: {
        payload: Prisma.$OrderItemAddOnPayload<ExtArgs>
        fields: Prisma.OrderItemAddOnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemAddOnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemAddOnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemAddOnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemAddOnPayload>
          }
          findFirst: {
            args: Prisma.OrderItemAddOnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemAddOnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemAddOnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemAddOnPayload>
          }
          findMany: {
            args: Prisma.OrderItemAddOnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemAddOnPayload>[]
          }
          create: {
            args: Prisma.OrderItemAddOnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemAddOnPayload>
          }
          createMany: {
            args: Prisma.OrderItemAddOnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemAddOnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemAddOnPayload>[]
          }
          delete: {
            args: Prisma.OrderItemAddOnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemAddOnPayload>
          }
          update: {
            args: Prisma.OrderItemAddOnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemAddOnPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemAddOnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemAddOnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemAddOnUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemAddOnPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemAddOnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemAddOnPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAddOnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItemAddOn>
          }
          groupBy: {
            args: Prisma.OrderItemAddOnGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemAddOnGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemAddOnCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemAddOnCountAggregateOutputType> | number
          }
        }
      }
      OrderAdjustment: {
        payload: Prisma.$OrderAdjustmentPayload<ExtArgs>
        fields: Prisma.OrderAdjustmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderAdjustmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAdjustmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderAdjustmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAdjustmentPayload>
          }
          findFirst: {
            args: Prisma.OrderAdjustmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAdjustmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderAdjustmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAdjustmentPayload>
          }
          findMany: {
            args: Prisma.OrderAdjustmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAdjustmentPayload>[]
          }
          create: {
            args: Prisma.OrderAdjustmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAdjustmentPayload>
          }
          createMany: {
            args: Prisma.OrderAdjustmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderAdjustmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAdjustmentPayload>[]
          }
          delete: {
            args: Prisma.OrderAdjustmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAdjustmentPayload>
          }
          update: {
            args: Prisma.OrderAdjustmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAdjustmentPayload>
          }
          deleteMany: {
            args: Prisma.OrderAdjustmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderAdjustmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderAdjustmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAdjustmentPayload>[]
          }
          upsert: {
            args: Prisma.OrderAdjustmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAdjustmentPayload>
          }
          aggregate: {
            args: Prisma.OrderAdjustmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderAdjustment>
          }
          groupBy: {
            args: Prisma.OrderAdjustmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderAdjustmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderAdjustmentCountArgs<ExtArgs>
            result: $Utils.Optional<OrderAdjustmentCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      OrderEvent: {
        payload: Prisma.$OrderEventPayload<ExtArgs>
        fields: Prisma.OrderEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderEventPayload>
          }
          findFirst: {
            args: Prisma.OrderEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderEventPayload>
          }
          findMany: {
            args: Prisma.OrderEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderEventPayload>[]
          }
          create: {
            args: Prisma.OrderEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderEventPayload>
          }
          createMany: {
            args: Prisma.OrderEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderEventPayload>[]
          }
          delete: {
            args: Prisma.OrderEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderEventPayload>
          }
          update: {
            args: Prisma.OrderEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderEventPayload>
          }
          deleteMany: {
            args: Prisma.OrderEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderEventPayload>[]
          }
          upsert: {
            args: Prisma.OrderEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderEventPayload>
          }
          aggregate: {
            args: Prisma.OrderEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderEvent>
          }
          groupBy: {
            args: Prisma.OrderEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderEventCountArgs<ExtArgs>
            result: $Utils.Optional<OrderEventCountAggregateOutputType> | number
          }
        }
      }
      CapacityHold: {
        payload: Prisma.$CapacityHoldPayload<ExtArgs>
        fields: Prisma.CapacityHoldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CapacityHoldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapacityHoldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CapacityHoldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapacityHoldPayload>
          }
          findFirst: {
            args: Prisma.CapacityHoldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapacityHoldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CapacityHoldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapacityHoldPayload>
          }
          findMany: {
            args: Prisma.CapacityHoldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapacityHoldPayload>[]
          }
          create: {
            args: Prisma.CapacityHoldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapacityHoldPayload>
          }
          createMany: {
            args: Prisma.CapacityHoldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CapacityHoldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapacityHoldPayload>[]
          }
          delete: {
            args: Prisma.CapacityHoldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapacityHoldPayload>
          }
          update: {
            args: Prisma.CapacityHoldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapacityHoldPayload>
          }
          deleteMany: {
            args: Prisma.CapacityHoldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CapacityHoldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CapacityHoldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapacityHoldPayload>[]
          }
          upsert: {
            args: Prisma.CapacityHoldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapacityHoldPayload>
          }
          aggregate: {
            args: Prisma.CapacityHoldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapacityHold>
          }
          groupBy: {
            args: Prisma.CapacityHoldGroupByArgs<ExtArgs>
            result: $Utils.Optional<CapacityHoldGroupByOutputType>[]
          }
          count: {
            args: Prisma.CapacityHoldCountArgs<ExtArgs>
            result: $Utils.Optional<CapacityHoldCountAggregateOutputType> | number
          }
        }
      }
      Promotion: {
        payload: Prisma.$PromotionPayload<ExtArgs>
        fields: Prisma.PromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findFirst: {
            args: Prisma.PromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findMany: {
            args: Prisma.PromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          create: {
            args: Prisma.PromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          createMany: {
            args: Prisma.PromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          delete: {
            args: Prisma.PromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          update: {
            args: Prisma.PromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromotionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          upsert: {
            args: Prisma.PromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          aggregate: {
            args: Prisma.PromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotion>
          }
          groupBy: {
            args: Prisma.PromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionCountAggregateOutputType> | number
          }
        }
      }
      PromotionRedemption: {
        payload: Prisma.$PromotionRedemptionPayload<ExtArgs>
        fields: Prisma.PromotionRedemptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionRedemptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionRedemptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          findFirst: {
            args: Prisma.PromotionRedemptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionRedemptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          findMany: {
            args: Prisma.PromotionRedemptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>[]
          }
          create: {
            args: Prisma.PromotionRedemptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          createMany: {
            args: Prisma.PromotionRedemptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionRedemptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>[]
          }
          delete: {
            args: Prisma.PromotionRedemptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          update: {
            args: Prisma.PromotionRedemptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionRedemptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionRedemptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromotionRedemptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>[]
          }
          upsert: {
            args: Prisma.PromotionRedemptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          aggregate: {
            args: Prisma.PromotionRedemptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotionRedemption>
          }
          groupBy: {
            args: Prisma.PromotionRedemptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionRedemptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionRedemptionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionRedemptionCountAggregateOutputType> | number
          }
        }
      }
      RewardAccount: {
        payload: Prisma.$RewardAccountPayload<ExtArgs>
        fields: Prisma.RewardAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccountPayload>
          }
          findFirst: {
            args: Prisma.RewardAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccountPayload>
          }
          findMany: {
            args: Prisma.RewardAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccountPayload>[]
          }
          create: {
            args: Prisma.RewardAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccountPayload>
          }
          createMany: {
            args: Prisma.RewardAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RewardAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccountPayload>[]
          }
          delete: {
            args: Prisma.RewardAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccountPayload>
          }
          update: {
            args: Prisma.RewardAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccountPayload>
          }
          deleteMany: {
            args: Prisma.RewardAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RewardAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccountPayload>[]
          }
          upsert: {
            args: Prisma.RewardAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccountPayload>
          }
          aggregate: {
            args: Prisma.RewardAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewardAccount>
          }
          groupBy: {
            args: Prisma.RewardAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardAccountCountArgs<ExtArgs>
            result: $Utils.Optional<RewardAccountCountAggregateOutputType> | number
          }
        }
      }
      RewardTransaction: {
        payload: Prisma.$RewardTransactionPayload<ExtArgs>
        fields: Prisma.RewardTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>
          }
          findFirst: {
            args: Prisma.RewardTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>
          }
          findMany: {
            args: Prisma.RewardTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>[]
          }
          create: {
            args: Prisma.RewardTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>
          }
          createMany: {
            args: Prisma.RewardTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RewardTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>[]
          }
          delete: {
            args: Prisma.RewardTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>
          }
          update: {
            args: Prisma.RewardTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>
          }
          deleteMany: {
            args: Prisma.RewardTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RewardTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>[]
          }
          upsert: {
            args: Prisma.RewardTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>
          }
          aggregate: {
            args: Prisma.RewardTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewardTransaction>
          }
          groupBy: {
            args: Prisma.RewardTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<RewardTransactionCountAggregateOutputType> | number
          }
        }
      }
      CateringOrder: {
        payload: Prisma.$CateringOrderPayload<ExtArgs>
        fields: Prisma.CateringOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CateringOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CateringOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringOrderPayload>
          }
          findFirst: {
            args: Prisma.CateringOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CateringOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringOrderPayload>
          }
          findMany: {
            args: Prisma.CateringOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringOrderPayload>[]
          }
          create: {
            args: Prisma.CateringOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringOrderPayload>
          }
          createMany: {
            args: Prisma.CateringOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CateringOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringOrderPayload>[]
          }
          delete: {
            args: Prisma.CateringOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringOrderPayload>
          }
          update: {
            args: Prisma.CateringOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringOrderPayload>
          }
          deleteMany: {
            args: Prisma.CateringOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CateringOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CateringOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringOrderPayload>[]
          }
          upsert: {
            args: Prisma.CateringOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringOrderPayload>
          }
          aggregate: {
            args: Prisma.CateringOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCateringOrder>
          }
          groupBy: {
            args: Prisma.CateringOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<CateringOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.CateringOrderCountArgs<ExtArgs>
            result: $Utils.Optional<CateringOrderCountAggregateOutputType> | number
          }
        }
      }
      CateringItem: {
        payload: Prisma.$CateringItemPayload<ExtArgs>
        fields: Prisma.CateringItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CateringItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CateringItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringItemPayload>
          }
          findFirst: {
            args: Prisma.CateringItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CateringItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringItemPayload>
          }
          findMany: {
            args: Prisma.CateringItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringItemPayload>[]
          }
          create: {
            args: Prisma.CateringItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringItemPayload>
          }
          createMany: {
            args: Prisma.CateringItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CateringItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringItemPayload>[]
          }
          delete: {
            args: Prisma.CateringItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringItemPayload>
          }
          update: {
            args: Prisma.CateringItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringItemPayload>
          }
          deleteMany: {
            args: Prisma.CateringItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CateringItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CateringItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringItemPayload>[]
          }
          upsert: {
            args: Prisma.CateringItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringItemPayload>
          }
          aggregate: {
            args: Prisma.CateringItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCateringItem>
          }
          groupBy: {
            args: Prisma.CateringItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CateringItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CateringItemCountArgs<ExtArgs>
            result: $Utils.Optional<CateringItemCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    category?: CategoryOmit
    menuItem?: MenuItemOmit
    menuVariant?: MenuVariantOmit
    addOn?: AddOnOmit
    menuItemAddOn?: MenuItemAddOnOmit
    serviceDay?: ServiceDayOmit
    menu?: MenuOmit
    menuOffering?: MenuOfferingOmit
    pickupLocation?: PickupLocationOmit
    address?: AddressOmit
    slotTemplate?: SlotTemplateOmit
    serviceSlot?: ServiceSlotOmit
    deliverySettings?: DeliverySettingsOmit
    order?: OrderOmit
    fulfillmentGroup?: FulfillmentGroupOmit
    orderItem?: OrderItemOmit
    orderItemAddOn?: OrderItemAddOnOmit
    orderAdjustment?: OrderAdjustmentOmit
    payment?: PaymentOmit
    orderEvent?: OrderEventOmit
    capacityHold?: CapacityHoldOmit
    promotion?: PromotionOmit
    promotionRedemption?: PromotionRedemptionOmit
    rewardAccount?: RewardAccountOmit
    rewardTransaction?: RewardTransactionOmit
    cateringOrder?: CateringOrderOmit
    cateringItem?: CateringItemOmit
    review?: ReviewOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    orders: number
    createdOrders: number
    addresses: number
    paymentsReceived: number
    cateringOrders: number
    createdCateringOrders: number
    reviews: number
    promotionRedemptions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    createdOrders?: boolean | UserCountOutputTypeCountCreatedOrdersArgs
    addresses?: boolean | UserCountOutputTypeCountAddressesArgs
    paymentsReceived?: boolean | UserCountOutputTypeCountPaymentsReceivedArgs
    cateringOrders?: boolean | UserCountOutputTypeCountCateringOrdersArgs
    createdCateringOrders?: boolean | UserCountOutputTypeCountCreatedCateringOrdersArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    promotionRedemptions?: boolean | UserCountOutputTypeCountPromotionRedemptionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCateringOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CateringOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedCateringOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CateringOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPromotionRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionRedemptionWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    items: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CategoryCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemWhereInput
  }


  /**
   * Count Type MenuItemCountOutputType
   */

  export type MenuItemCountOutputType = {
    variants: number
    addOnLinks: number
    cateringItems: number
  }

  export type MenuItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | MenuItemCountOutputTypeCountVariantsArgs
    addOnLinks?: boolean | MenuItemCountOutputTypeCountAddOnLinksArgs
    cateringItems?: boolean | MenuItemCountOutputTypeCountCateringItemsArgs
  }

  // Custom InputTypes
  /**
   * MenuItemCountOutputType without action
   */
  export type MenuItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemCountOutputType
     */
    select?: MenuItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MenuItemCountOutputType without action
   */
  export type MenuItemCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuVariantWhereInput
  }

  /**
   * MenuItemCountOutputType without action
   */
  export type MenuItemCountOutputTypeCountAddOnLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemAddOnWhereInput
  }

  /**
   * MenuItemCountOutputType without action
   */
  export type MenuItemCountOutputTypeCountCateringItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CateringItemWhereInput
  }


  /**
   * Count Type MenuVariantCountOutputType
   */

  export type MenuVariantCountOutputType = {
    offerings: number
    orderItems: number
  }

  export type MenuVariantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offerings?: boolean | MenuVariantCountOutputTypeCountOfferingsArgs
    orderItems?: boolean | MenuVariantCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * MenuVariantCountOutputType without action
   */
  export type MenuVariantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuVariantCountOutputType
     */
    select?: MenuVariantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MenuVariantCountOutputType without action
   */
  export type MenuVariantCountOutputTypeCountOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuOfferingWhereInput
  }

  /**
   * MenuVariantCountOutputType without action
   */
  export type MenuVariantCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type AddOnCountOutputType
   */

  export type AddOnCountOutputType = {
    itemLinks: number
    orderLinks: number
  }

  export type AddOnCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemLinks?: boolean | AddOnCountOutputTypeCountItemLinksArgs
    orderLinks?: boolean | AddOnCountOutputTypeCountOrderLinksArgs
  }

  // Custom InputTypes
  /**
   * AddOnCountOutputType without action
   */
  export type AddOnCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOnCountOutputType
     */
    select?: AddOnCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddOnCountOutputType without action
   */
  export type AddOnCountOutputTypeCountItemLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemAddOnWhereInput
  }

  /**
   * AddOnCountOutputType without action
   */
  export type AddOnCountOutputTypeCountOrderLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemAddOnWhereInput
  }


  /**
   * Count Type ServiceDayCountOutputType
   */

  export type ServiceDayCountOutputType = {
    menus: number
    slots: number
    groups: number
  }

  export type ServiceDayCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menus?: boolean | ServiceDayCountOutputTypeCountMenusArgs
    slots?: boolean | ServiceDayCountOutputTypeCountSlotsArgs
    groups?: boolean | ServiceDayCountOutputTypeCountGroupsArgs
  }

  // Custom InputTypes
  /**
   * ServiceDayCountOutputType without action
   */
  export type ServiceDayCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDayCountOutputType
     */
    select?: ServiceDayCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceDayCountOutputType without action
   */
  export type ServiceDayCountOutputTypeCountMenusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
  }

  /**
   * ServiceDayCountOutputType without action
   */
  export type ServiceDayCountOutputTypeCountSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceSlotWhereInput
  }

  /**
   * ServiceDayCountOutputType without action
   */
  export type ServiceDayCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FulfillmentGroupWhereInput
  }


  /**
   * Count Type MenuCountOutputType
   */

  export type MenuCountOutputType = {
    offerings: number
  }

  export type MenuCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offerings?: boolean | MenuCountOutputTypeCountOfferingsArgs
  }

  // Custom InputTypes
  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuCountOutputType
     */
    select?: MenuCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeCountOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuOfferingWhereInput
  }


  /**
   * Count Type MenuOfferingCountOutputType
   */

  export type MenuOfferingCountOutputType = {
    holds: number
  }

  export type MenuOfferingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    holds?: boolean | MenuOfferingCountOutputTypeCountHoldsArgs
  }

  // Custom InputTypes
  /**
   * MenuOfferingCountOutputType without action
   */
  export type MenuOfferingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuOfferingCountOutputType
     */
    select?: MenuOfferingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MenuOfferingCountOutputType without action
   */
  export type MenuOfferingCountOutputTypeCountHoldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CapacityHoldWhereInput
  }


  /**
   * Count Type PickupLocationCountOutputType
   */

  export type PickupLocationCountOutputType = {
    serviceSlots: number
    orders: number
  }

  export type PickupLocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceSlots?: boolean | PickupLocationCountOutputTypeCountServiceSlotsArgs
    orders?: boolean | PickupLocationCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * PickupLocationCountOutputType without action
   */
  export type PickupLocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocationCountOutputType
     */
    select?: PickupLocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PickupLocationCountOutputType without action
   */
  export type PickupLocationCountOutputTypeCountServiceSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceSlotWhereInput
  }

  /**
   * PickupLocationCountOutputType without action
   */
  export type PickupLocationCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type AddressCountOutputType
   */

  export type AddressCountOutputType = {
    deliveryOrders: number
  }

  export type AddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveryOrders?: boolean | AddressCountOutputTypeCountDeliveryOrdersArgs
  }

  // Custom InputTypes
  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountDeliveryOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type SlotTemplateCountOutputType
   */

  export type SlotTemplateCountOutputType = {
    serviceSlots: number
  }

  export type SlotTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceSlots?: boolean | SlotTemplateCountOutputTypeCountServiceSlotsArgs
  }

  // Custom InputTypes
  /**
   * SlotTemplateCountOutputType without action
   */
  export type SlotTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotTemplateCountOutputType
     */
    select?: SlotTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SlotTemplateCountOutputType without action
   */
  export type SlotTemplateCountOutputTypeCountServiceSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceSlotWhereInput
  }


  /**
   * Count Type ServiceSlotCountOutputType
   */

  export type ServiceSlotCountOutputType = {
    groups: number
  }

  export type ServiceSlotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups?: boolean | ServiceSlotCountOutputTypeCountGroupsArgs
  }

  // Custom InputTypes
  /**
   * ServiceSlotCountOutputType without action
   */
  export type ServiceSlotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlotCountOutputType
     */
    select?: ServiceSlotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceSlotCountOutputType without action
   */
  export type ServiceSlotCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FulfillmentGroupWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    groups: number
    items: number
    adjustments: number
    payments: number
    events: number
    promoRedemptions: number
    capacityHolds: number
    rewardTransactions: number
    reviews: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups?: boolean | OrderCountOutputTypeCountGroupsArgs
    items?: boolean | OrderCountOutputTypeCountItemsArgs
    adjustments?: boolean | OrderCountOutputTypeCountAdjustmentsArgs
    payments?: boolean | OrderCountOutputTypeCountPaymentsArgs
    events?: boolean | OrderCountOutputTypeCountEventsArgs
    promoRedemptions?: boolean | OrderCountOutputTypeCountPromoRedemptionsArgs
    capacityHolds?: boolean | OrderCountOutputTypeCountCapacityHoldsArgs
    rewardTransactions?: boolean | OrderCountOutputTypeCountRewardTransactionsArgs
    reviews?: boolean | OrderCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FulfillmentGroupWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderAdjustmentWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderEventWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPromoRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionRedemptionWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountCapacityHoldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CapacityHoldWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountRewardTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardTransactionWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type FulfillmentGroupCountOutputType
   */

  export type FulfillmentGroupCountOutputType = {
    items: number
    adjustments: number
    events: number
  }

  export type FulfillmentGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | FulfillmentGroupCountOutputTypeCountItemsArgs
    adjustments?: boolean | FulfillmentGroupCountOutputTypeCountAdjustmentsArgs
    events?: boolean | FulfillmentGroupCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * FulfillmentGroupCountOutputType without action
   */
  export type FulfillmentGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroupCountOutputType
     */
    select?: FulfillmentGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FulfillmentGroupCountOutputType without action
   */
  export type FulfillmentGroupCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * FulfillmentGroupCountOutputType without action
   */
  export type FulfillmentGroupCountOutputTypeCountAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderAdjustmentWhereInput
  }

  /**
   * FulfillmentGroupCountOutputType without action
   */
  export type FulfillmentGroupCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderEventWhereInput
  }


  /**
   * Count Type OrderItemCountOutputType
   */

  export type OrderItemCountOutputType = {
    addOns: number
  }

  export type OrderItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addOns?: boolean | OrderItemCountOutputTypeCountAddOnsArgs
  }

  // Custom InputTypes
  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemCountOutputType
     */
    select?: OrderItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeCountAddOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemAddOnWhereInput
  }


  /**
   * Count Type PromotionCountOutputType
   */

  export type PromotionCountOutputType = {
    redemptions: number
  }

  export type PromotionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redemptions?: boolean | PromotionCountOutputTypeCountRedemptionsArgs
  }

  // Custom InputTypes
  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCountOutputType
     */
    select?: PromotionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeCountRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionRedemptionWhereInput
  }


  /**
   * Count Type RewardAccountCountOutputType
   */

  export type RewardAccountCountOutputType = {
    txns: number
  }

  export type RewardAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    txns?: boolean | RewardAccountCountOutputTypeCountTxnsArgs
  }

  // Custom InputTypes
  /**
   * RewardAccountCountOutputType without action
   */
  export type RewardAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccountCountOutputType
     */
    select?: RewardAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RewardAccountCountOutputType without action
   */
  export type RewardAccountCountOutputTypeCountTxnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardTransactionWhereInput
  }


  /**
   * Count Type CateringOrderCountOutputType
   */

  export type CateringOrderCountOutputType = {
    items: number
  }

  export type CateringOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CateringOrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * CateringOrderCountOutputType without action
   */
  export type CateringOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringOrderCountOutputType
     */
    select?: CateringOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CateringOrderCountOutputType without action
   */
  export type CateringOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CateringItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    googleId: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    googleId: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    googleId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    googleId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    googleId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    googleId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    name: string | null
    googleId: string | null
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    googleId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | User$ordersArgs<ExtArgs>
    createdOrders?: boolean | User$createdOrdersArgs<ExtArgs>
    addresses?: boolean | User$addressesArgs<ExtArgs>
    paymentsReceived?: boolean | User$paymentsReceivedArgs<ExtArgs>
    cateringOrders?: boolean | User$cateringOrdersArgs<ExtArgs>
    createdCateringOrders?: boolean | User$createdCateringOrdersArgs<ExtArgs>
    rewardAccount?: boolean | User$rewardAccountArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    promotionRedemptions?: boolean | User$promotionRedemptionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    googleId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    googleId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    googleId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "googleId" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | User$ordersArgs<ExtArgs>
    createdOrders?: boolean | User$createdOrdersArgs<ExtArgs>
    addresses?: boolean | User$addressesArgs<ExtArgs>
    paymentsReceived?: boolean | User$paymentsReceivedArgs<ExtArgs>
    cateringOrders?: boolean | User$cateringOrdersArgs<ExtArgs>
    createdCateringOrders?: boolean | User$createdCateringOrdersArgs<ExtArgs>
    rewardAccount?: boolean | User$rewardAccountArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    promotionRedemptions?: boolean | User$promotionRedemptionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
      createdOrders: Prisma.$OrderPayload<ExtArgs>[]
      addresses: Prisma.$AddressPayload<ExtArgs>[]
      paymentsReceived: Prisma.$PaymentPayload<ExtArgs>[]
      cateringOrders: Prisma.$CateringOrderPayload<ExtArgs>[]
      createdCateringOrders: Prisma.$CateringOrderPayload<ExtArgs>[]
      rewardAccount: Prisma.$RewardAccountPayload<ExtArgs> | null
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      promotionRedemptions: Prisma.$PromotionRedemptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string | null
      googleId: string | null
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdOrders<T extends User$createdOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addresses<T extends User$addressesArgs<ExtArgs> = {}>(args?: Subset<T, User$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentsReceived<T extends User$paymentsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cateringOrders<T extends User$cateringOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$cateringOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CateringOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdCateringOrders<T extends User$createdCateringOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdCateringOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CateringOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rewardAccount<T extends User$rewardAccountArgs<ExtArgs> = {}>(args?: Subset<T, User$rewardAccountArgs<ExtArgs>>): Prisma__RewardAccountClient<$Result.GetResult<Prisma.$RewardAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promotionRedemptions<T extends User$promotionRedemptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$promotionRedemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.createdOrders
   */
  export type User$createdOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.addresses
   */
  export type User$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * User.paymentsReceived
   */
  export type User$paymentsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.cateringOrders
   */
  export type User$cateringOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringOrder
     */
    select?: CateringOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringOrder
     */
    omit?: CateringOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringOrderInclude<ExtArgs> | null
    where?: CateringOrderWhereInput
    orderBy?: CateringOrderOrderByWithRelationInput | CateringOrderOrderByWithRelationInput[]
    cursor?: CateringOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CateringOrderScalarFieldEnum | CateringOrderScalarFieldEnum[]
  }

  /**
   * User.createdCateringOrders
   */
  export type User$createdCateringOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringOrder
     */
    select?: CateringOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringOrder
     */
    omit?: CateringOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringOrderInclude<ExtArgs> | null
    where?: CateringOrderWhereInput
    orderBy?: CateringOrderOrderByWithRelationInput | CateringOrderOrderByWithRelationInput[]
    cursor?: CateringOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CateringOrderScalarFieldEnum | CateringOrderScalarFieldEnum[]
  }

  /**
   * User.rewardAccount
   */
  export type User$rewardAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccount
     */
    select?: RewardAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccount
     */
    omit?: RewardAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccountInclude<ExtArgs> | null
    where?: RewardAccountWhereInput
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.promotionRedemptions
   */
  export type User$promotionRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    where?: PromotionRedemptionWhereInput
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    cursor?: PromotionRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
    position: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
    position: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    position: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
    position?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
    position?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    position: number
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | Category$itemsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "position" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Category$itemsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      items: Prisma.$MenuItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      position: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Category$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Category$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
    readonly position: FieldRef<"Category", 'Int'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.items
   */
  export type Category$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    where?: MenuItemWhereInput
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    cursor?: MenuItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model MenuItem
   */

  export type AggregateMenuItem = {
    _count: MenuItemCountAggregateOutputType | null
    _avg: MenuItemAvgAggregateOutputType | null
    _sum: MenuItemSumAggregateOutputType | null
    _min: MenuItemMinAggregateOutputType | null
    _max: MenuItemMaxAggregateOutputType | null
  }

  export type MenuItemAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
  }

  export type MenuItemSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
  }

  export type MenuItemMinAggregateOutputType = {
    id: number | null
    categoryId: number | null
    name: string | null
    description: string | null
    imageUrl: string | null
    isActive: boolean | null
    archivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuItemMaxAggregateOutputType = {
    id: number | null
    categoryId: number | null
    name: string | null
    description: string | null
    imageUrl: string | null
    isActive: boolean | null
    archivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuItemCountAggregateOutputType = {
    id: number
    categoryId: number
    name: number
    description: number
    imageUrl: number
    nutrition: number
    allergens: number
    isActive: number
    archivedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenuItemAvgAggregateInputType = {
    id?: true
    categoryId?: true
  }

  export type MenuItemSumAggregateInputType = {
    id?: true
    categoryId?: true
  }

  export type MenuItemMinAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    description?: true
    imageUrl?: true
    isActive?: true
    archivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuItemMaxAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    description?: true
    imageUrl?: true
    isActive?: true
    archivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuItemCountAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    description?: true
    imageUrl?: true
    nutrition?: true
    allergens?: true
    isActive?: true
    archivedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuItem to aggregate.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuItems
    **/
    _count?: true | MenuItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuItemMaxAggregateInputType
  }

  export type GetMenuItemAggregateType<T extends MenuItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuItem[P]>
      : GetScalarType<T[P], AggregateMenuItem[P]>
  }




  export type MenuItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemWhereInput
    orderBy?: MenuItemOrderByWithAggregationInput | MenuItemOrderByWithAggregationInput[]
    by: MenuItemScalarFieldEnum[] | MenuItemScalarFieldEnum
    having?: MenuItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuItemCountAggregateInputType | true
    _avg?: MenuItemAvgAggregateInputType
    _sum?: MenuItemSumAggregateInputType
    _min?: MenuItemMinAggregateInputType
    _max?: MenuItemMaxAggregateInputType
  }

  export type MenuItemGroupByOutputType = {
    id: number
    categoryId: number | null
    name: string
    description: string | null
    imageUrl: string | null
    nutrition: JsonValue | null
    allergens: JsonValue | null
    isActive: boolean
    archivedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MenuItemCountAggregateOutputType | null
    _avg: MenuItemAvgAggregateOutputType | null
    _sum: MenuItemSumAggregateOutputType | null
    _min: MenuItemMinAggregateOutputType | null
    _max: MenuItemMaxAggregateOutputType | null
  }

  type GetMenuItemGroupByPayload<T extends MenuItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuItemGroupByOutputType[P]>
            : GetScalarType<T[P], MenuItemGroupByOutputType[P]>
        }
      >
    >


  export type MenuItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    nutrition?: boolean
    allergens?: boolean
    isActive?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | MenuItem$categoryArgs<ExtArgs>
    variants?: boolean | MenuItem$variantsArgs<ExtArgs>
    addOnLinks?: boolean | MenuItem$addOnLinksArgs<ExtArgs>
    cateringItems?: boolean | MenuItem$cateringItemsArgs<ExtArgs>
    _count?: boolean | MenuItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItem"]>

  export type MenuItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    nutrition?: boolean
    allergens?: boolean
    isActive?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | MenuItem$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["menuItem"]>

  export type MenuItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    nutrition?: boolean
    allergens?: boolean
    isActive?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | MenuItem$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["menuItem"]>

  export type MenuItemSelectScalar = {
    id?: boolean
    categoryId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    nutrition?: boolean
    allergens?: boolean
    isActive?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MenuItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "categoryId" | "name" | "description" | "imageUrl" | "nutrition" | "allergens" | "isActive" | "archivedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["menuItem"]>
  export type MenuItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | MenuItem$categoryArgs<ExtArgs>
    variants?: boolean | MenuItem$variantsArgs<ExtArgs>
    addOnLinks?: boolean | MenuItem$addOnLinksArgs<ExtArgs>
    cateringItems?: boolean | MenuItem$cateringItemsArgs<ExtArgs>
    _count?: boolean | MenuItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MenuItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | MenuItem$categoryArgs<ExtArgs>
  }
  export type MenuItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | MenuItem$categoryArgs<ExtArgs>
  }

  export type $MenuItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenuItem"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs> | null
      variants: Prisma.$MenuVariantPayload<ExtArgs>[]
      addOnLinks: Prisma.$MenuItemAddOnPayload<ExtArgs>[]
      cateringItems: Prisma.$CateringItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      categoryId: number | null
      name: string
      description: string | null
      imageUrl: string | null
      nutrition: Prisma.JsonValue | null
      allergens: Prisma.JsonValue | null
      isActive: boolean
      archivedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["menuItem"]>
    composites: {}
  }

  type MenuItemGetPayload<S extends boolean | null | undefined | MenuItemDefaultArgs> = $Result.GetResult<Prisma.$MenuItemPayload, S>

  type MenuItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenuItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenuItemCountAggregateInputType | true
    }

  export interface MenuItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenuItem'], meta: { name: 'MenuItem' } }
    /**
     * Find zero or one MenuItem that matches the filter.
     * @param {MenuItemFindUniqueArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuItemFindUniqueArgs>(args: SelectSubset<T, MenuItemFindUniqueArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MenuItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenuItemFindUniqueOrThrowArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenuItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindFirstArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuItemFindFirstArgs>(args?: SelectSubset<T, MenuItemFindFirstArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenuItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindFirstOrThrowArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MenuItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuItems
     * const menuItems = await prisma.menuItem.findMany()
     * 
     * // Get first 10 MenuItems
     * const menuItems = await prisma.menuItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuItemWithIdOnly = await prisma.menuItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuItemFindManyArgs>(args?: SelectSubset<T, MenuItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MenuItem.
     * @param {MenuItemCreateArgs} args - Arguments to create a MenuItem.
     * @example
     * // Create one MenuItem
     * const MenuItem = await prisma.menuItem.create({
     *   data: {
     *     // ... data to create a MenuItem
     *   }
     * })
     * 
     */
    create<T extends MenuItemCreateArgs>(args: SelectSubset<T, MenuItemCreateArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MenuItems.
     * @param {MenuItemCreateManyArgs} args - Arguments to create many MenuItems.
     * @example
     * // Create many MenuItems
     * const menuItem = await prisma.menuItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuItemCreateManyArgs>(args?: SelectSubset<T, MenuItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenuItems and returns the data saved in the database.
     * @param {MenuItemCreateManyAndReturnArgs} args - Arguments to create many MenuItems.
     * @example
     * // Create many MenuItems
     * const menuItem = await prisma.menuItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenuItems and only return the `id`
     * const menuItemWithIdOnly = await prisma.menuItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuItemCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MenuItem.
     * @param {MenuItemDeleteArgs} args - Arguments to delete one MenuItem.
     * @example
     * // Delete one MenuItem
     * const MenuItem = await prisma.menuItem.delete({
     *   where: {
     *     // ... filter to delete one MenuItem
     *   }
     * })
     * 
     */
    delete<T extends MenuItemDeleteArgs>(args: SelectSubset<T, MenuItemDeleteArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MenuItem.
     * @param {MenuItemUpdateArgs} args - Arguments to update one MenuItem.
     * @example
     * // Update one MenuItem
     * const menuItem = await prisma.menuItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuItemUpdateArgs>(args: SelectSubset<T, MenuItemUpdateArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MenuItems.
     * @param {MenuItemDeleteManyArgs} args - Arguments to filter MenuItems to delete.
     * @example
     * // Delete a few MenuItems
     * const { count } = await prisma.menuItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuItemDeleteManyArgs>(args?: SelectSubset<T, MenuItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuItems
     * const menuItem = await prisma.menuItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuItemUpdateManyArgs>(args: SelectSubset<T, MenuItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuItems and returns the data updated in the database.
     * @param {MenuItemUpdateManyAndReturnArgs} args - Arguments to update many MenuItems.
     * @example
     * // Update many MenuItems
     * const menuItem = await prisma.menuItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MenuItems and only return the `id`
     * const menuItemWithIdOnly = await prisma.menuItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenuItemUpdateManyAndReturnArgs>(args: SelectSubset<T, MenuItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MenuItem.
     * @param {MenuItemUpsertArgs} args - Arguments to update or create a MenuItem.
     * @example
     * // Update or create a MenuItem
     * const menuItem = await prisma.menuItem.upsert({
     *   create: {
     *     // ... data to create a MenuItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuItem we want to update
     *   }
     * })
     */
    upsert<T extends MenuItemUpsertArgs>(args: SelectSubset<T, MenuItemUpsertArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MenuItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemCountArgs} args - Arguments to filter MenuItems to count.
     * @example
     * // Count the number of MenuItems
     * const count = await prisma.menuItem.count({
     *   where: {
     *     // ... the filter for the MenuItems we want to count
     *   }
     * })
    **/
    count<T extends MenuItemCountArgs>(
      args?: Subset<T, MenuItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuItemAggregateArgs>(args: Subset<T, MenuItemAggregateArgs>): Prisma.PrismaPromise<GetMenuItemAggregateType<T>>

    /**
     * Group by MenuItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuItemGroupByArgs['orderBy'] }
        : { orderBy?: MenuItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenuItem model
   */
  readonly fields: MenuItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends MenuItem$categoryArgs<ExtArgs> = {}>(args?: Subset<T, MenuItem$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    variants<T extends MenuItem$variantsArgs<ExtArgs> = {}>(args?: Subset<T, MenuItem$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addOnLinks<T extends MenuItem$addOnLinksArgs<ExtArgs> = {}>(args?: Subset<T, MenuItem$addOnLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemAddOnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cateringItems<T extends MenuItem$cateringItemsArgs<ExtArgs> = {}>(args?: Subset<T, MenuItem$cateringItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CateringItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenuItem model
   */
  interface MenuItemFieldRefs {
    readonly id: FieldRef<"MenuItem", 'Int'>
    readonly categoryId: FieldRef<"MenuItem", 'Int'>
    readonly name: FieldRef<"MenuItem", 'String'>
    readonly description: FieldRef<"MenuItem", 'String'>
    readonly imageUrl: FieldRef<"MenuItem", 'String'>
    readonly nutrition: FieldRef<"MenuItem", 'Json'>
    readonly allergens: FieldRef<"MenuItem", 'Json'>
    readonly isActive: FieldRef<"MenuItem", 'Boolean'>
    readonly archivedAt: FieldRef<"MenuItem", 'DateTime'>
    readonly createdAt: FieldRef<"MenuItem", 'DateTime'>
    readonly updatedAt: FieldRef<"MenuItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MenuItem findUnique
   */
  export type MenuItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem findUniqueOrThrow
   */
  export type MenuItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem findFirst
   */
  export type MenuItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItems.
     */
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem findFirstOrThrow
   */
  export type MenuItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItems.
     */
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem findMany
   */
  export type MenuItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItems to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem create
   */
  export type MenuItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MenuItem.
     */
    data: XOR<MenuItemCreateInput, MenuItemUncheckedCreateInput>
  }

  /**
   * MenuItem createMany
   */
  export type MenuItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenuItems.
     */
    data: MenuItemCreateManyInput | MenuItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenuItem createManyAndReturn
   */
  export type MenuItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * The data used to create many MenuItems.
     */
    data: MenuItemCreateManyInput | MenuItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuItem update
   */
  export type MenuItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MenuItem.
     */
    data: XOR<MenuItemUpdateInput, MenuItemUncheckedUpdateInput>
    /**
     * Choose, which MenuItem to update.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem updateMany
   */
  export type MenuItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenuItems.
     */
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyInput>
    /**
     * Filter which MenuItems to update
     */
    where?: MenuItemWhereInput
    /**
     * Limit how many MenuItems to update.
     */
    limit?: number
  }

  /**
   * MenuItem updateManyAndReturn
   */
  export type MenuItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * The data used to update MenuItems.
     */
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyInput>
    /**
     * Filter which MenuItems to update
     */
    where?: MenuItemWhereInput
    /**
     * Limit how many MenuItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuItem upsert
   */
  export type MenuItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MenuItem to update in case it exists.
     */
    where: MenuItemWhereUniqueInput
    /**
     * In case the MenuItem found by the `where` argument doesn't exist, create a new MenuItem with this data.
     */
    create: XOR<MenuItemCreateInput, MenuItemUncheckedCreateInput>
    /**
     * In case the MenuItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuItemUpdateInput, MenuItemUncheckedUpdateInput>
  }

  /**
   * MenuItem delete
   */
  export type MenuItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter which MenuItem to delete.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem deleteMany
   */
  export type MenuItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuItems to delete
     */
    where?: MenuItemWhereInput
    /**
     * Limit how many MenuItems to delete.
     */
    limit?: number
  }

  /**
   * MenuItem.category
   */
  export type MenuItem$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * MenuItem.variants
   */
  export type MenuItem$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuVariant
     */
    select?: MenuVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuVariant
     */
    omit?: MenuVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuVariantInclude<ExtArgs> | null
    where?: MenuVariantWhereInput
    orderBy?: MenuVariantOrderByWithRelationInput | MenuVariantOrderByWithRelationInput[]
    cursor?: MenuVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuVariantScalarFieldEnum | MenuVariantScalarFieldEnum[]
  }

  /**
   * MenuItem.addOnLinks
   */
  export type MenuItem$addOnLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemAddOn
     */
    select?: MenuItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemAddOn
     */
    omit?: MenuItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemAddOnInclude<ExtArgs> | null
    where?: MenuItemAddOnWhereInput
    orderBy?: MenuItemAddOnOrderByWithRelationInput | MenuItemAddOnOrderByWithRelationInput[]
    cursor?: MenuItemAddOnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuItemAddOnScalarFieldEnum | MenuItemAddOnScalarFieldEnum[]
  }

  /**
   * MenuItem.cateringItems
   */
  export type MenuItem$cateringItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringItem
     */
    select?: CateringItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringItem
     */
    omit?: CateringItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringItemInclude<ExtArgs> | null
    where?: CateringItemWhereInput
    orderBy?: CateringItemOrderByWithRelationInput | CateringItemOrderByWithRelationInput[]
    cursor?: CateringItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CateringItemScalarFieldEnum | CateringItemScalarFieldEnum[]
  }

  /**
   * MenuItem without action
   */
  export type MenuItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
  }


  /**
   * Model MenuVariant
   */

  export type AggregateMenuVariant = {
    _count: MenuVariantCountAggregateOutputType | null
    _avg: MenuVariantAvgAggregateOutputType | null
    _sum: MenuVariantSumAggregateOutputType | null
    _min: MenuVariantMinAggregateOutputType | null
    _max: MenuVariantMaxAggregateOutputType | null
  }

  export type MenuVariantAvgAggregateOutputType = {
    id: number | null
    menuItemId: number | null
    basePriceCents: number | null
    baseCapacity: number | null
    prepMinutes: number | null
    packagingCostCents: number | null
  }

  export type MenuVariantSumAggregateOutputType = {
    id: number | null
    menuItemId: number | null
    basePriceCents: number | null
    baseCapacity: number | null
    prepMinutes: number | null
    packagingCostCents: number | null
  }

  export type MenuVariantMinAggregateOutputType = {
    id: number | null
    menuItemId: number | null
    label: string | null
    basePriceCents: number | null
    baseCapacity: number | null
    isActive: boolean | null
    prepMinutes: number | null
    packagingCostCents: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuVariantMaxAggregateOutputType = {
    id: number | null
    menuItemId: number | null
    label: string | null
    basePriceCents: number | null
    baseCapacity: number | null
    isActive: boolean | null
    prepMinutes: number | null
    packagingCostCents: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuVariantCountAggregateOutputType = {
    id: number
    menuItemId: number
    label: number
    basePriceCents: number
    baseCapacity: number
    isActive: number
    prepMinutes: number
    packagingCostCents: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenuVariantAvgAggregateInputType = {
    id?: true
    menuItemId?: true
    basePriceCents?: true
    baseCapacity?: true
    prepMinutes?: true
    packagingCostCents?: true
  }

  export type MenuVariantSumAggregateInputType = {
    id?: true
    menuItemId?: true
    basePriceCents?: true
    baseCapacity?: true
    prepMinutes?: true
    packagingCostCents?: true
  }

  export type MenuVariantMinAggregateInputType = {
    id?: true
    menuItemId?: true
    label?: true
    basePriceCents?: true
    baseCapacity?: true
    isActive?: true
    prepMinutes?: true
    packagingCostCents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuVariantMaxAggregateInputType = {
    id?: true
    menuItemId?: true
    label?: true
    basePriceCents?: true
    baseCapacity?: true
    isActive?: true
    prepMinutes?: true
    packagingCostCents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuVariantCountAggregateInputType = {
    id?: true
    menuItemId?: true
    label?: true
    basePriceCents?: true
    baseCapacity?: true
    isActive?: true
    prepMinutes?: true
    packagingCostCents?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuVariant to aggregate.
     */
    where?: MenuVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuVariants to fetch.
     */
    orderBy?: MenuVariantOrderByWithRelationInput | MenuVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuVariants
    **/
    _count?: true | MenuVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuVariantMaxAggregateInputType
  }

  export type GetMenuVariantAggregateType<T extends MenuVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuVariant[P]>
      : GetScalarType<T[P], AggregateMenuVariant[P]>
  }




  export type MenuVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuVariantWhereInput
    orderBy?: MenuVariantOrderByWithAggregationInput | MenuVariantOrderByWithAggregationInput[]
    by: MenuVariantScalarFieldEnum[] | MenuVariantScalarFieldEnum
    having?: MenuVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuVariantCountAggregateInputType | true
    _avg?: MenuVariantAvgAggregateInputType
    _sum?: MenuVariantSumAggregateInputType
    _min?: MenuVariantMinAggregateInputType
    _max?: MenuVariantMaxAggregateInputType
  }

  export type MenuVariantGroupByOutputType = {
    id: number
    menuItemId: number
    label: string
    basePriceCents: number
    baseCapacity: number | null
    isActive: boolean
    prepMinutes: number | null
    packagingCostCents: number | null
    createdAt: Date
    updatedAt: Date
    _count: MenuVariantCountAggregateOutputType | null
    _avg: MenuVariantAvgAggregateOutputType | null
    _sum: MenuVariantSumAggregateOutputType | null
    _min: MenuVariantMinAggregateOutputType | null
    _max: MenuVariantMaxAggregateOutputType | null
  }

  type GetMenuVariantGroupByPayload<T extends MenuVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuVariantGroupByOutputType[P]>
            : GetScalarType<T[P], MenuVariantGroupByOutputType[P]>
        }
      >
    >


  export type MenuVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuItemId?: boolean
    label?: boolean
    basePriceCents?: boolean
    baseCapacity?: boolean
    isActive?: boolean
    prepMinutes?: boolean
    packagingCostCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menuItem?: boolean | MenuItemDefaultArgs<ExtArgs>
    offerings?: boolean | MenuVariant$offeringsArgs<ExtArgs>
    orderItems?: boolean | MenuVariant$orderItemsArgs<ExtArgs>
    _count?: boolean | MenuVariantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuVariant"]>

  export type MenuVariantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuItemId?: boolean
    label?: boolean
    basePriceCents?: boolean
    baseCapacity?: boolean
    isActive?: boolean
    prepMinutes?: boolean
    packagingCostCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menuItem?: boolean | MenuItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuVariant"]>

  export type MenuVariantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuItemId?: boolean
    label?: boolean
    basePriceCents?: boolean
    baseCapacity?: boolean
    isActive?: boolean
    prepMinutes?: boolean
    packagingCostCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menuItem?: boolean | MenuItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuVariant"]>

  export type MenuVariantSelectScalar = {
    id?: boolean
    menuItemId?: boolean
    label?: boolean
    basePriceCents?: boolean
    baseCapacity?: boolean
    isActive?: boolean
    prepMinutes?: boolean
    packagingCostCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MenuVariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "menuItemId" | "label" | "basePriceCents" | "baseCapacity" | "isActive" | "prepMinutes" | "packagingCostCents" | "createdAt" | "updatedAt", ExtArgs["result"]["menuVariant"]>
  export type MenuVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menuItem?: boolean | MenuItemDefaultArgs<ExtArgs>
    offerings?: boolean | MenuVariant$offeringsArgs<ExtArgs>
    orderItems?: boolean | MenuVariant$orderItemsArgs<ExtArgs>
    _count?: boolean | MenuVariantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MenuVariantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menuItem?: boolean | MenuItemDefaultArgs<ExtArgs>
  }
  export type MenuVariantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menuItem?: boolean | MenuItemDefaultArgs<ExtArgs>
  }

  export type $MenuVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenuVariant"
    objects: {
      menuItem: Prisma.$MenuItemPayload<ExtArgs>
      offerings: Prisma.$MenuOfferingPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      menuItemId: number
      label: string
      basePriceCents: number
      baseCapacity: number | null
      isActive: boolean
      prepMinutes: number | null
      packagingCostCents: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["menuVariant"]>
    composites: {}
  }

  type MenuVariantGetPayload<S extends boolean | null | undefined | MenuVariantDefaultArgs> = $Result.GetResult<Prisma.$MenuVariantPayload, S>

  type MenuVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenuVariantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenuVariantCountAggregateInputType | true
    }

  export interface MenuVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenuVariant'], meta: { name: 'MenuVariant' } }
    /**
     * Find zero or one MenuVariant that matches the filter.
     * @param {MenuVariantFindUniqueArgs} args - Arguments to find a MenuVariant
     * @example
     * // Get one MenuVariant
     * const menuVariant = await prisma.menuVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuVariantFindUniqueArgs>(args: SelectSubset<T, MenuVariantFindUniqueArgs<ExtArgs>>): Prisma__MenuVariantClient<$Result.GetResult<Prisma.$MenuVariantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MenuVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenuVariantFindUniqueOrThrowArgs} args - Arguments to find a MenuVariant
     * @example
     * // Get one MenuVariant
     * const menuVariant = await prisma.menuVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuVariantClient<$Result.GetResult<Prisma.$MenuVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenuVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuVariantFindFirstArgs} args - Arguments to find a MenuVariant
     * @example
     * // Get one MenuVariant
     * const menuVariant = await prisma.menuVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuVariantFindFirstArgs>(args?: SelectSubset<T, MenuVariantFindFirstArgs<ExtArgs>>): Prisma__MenuVariantClient<$Result.GetResult<Prisma.$MenuVariantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenuVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuVariantFindFirstOrThrowArgs} args - Arguments to find a MenuVariant
     * @example
     * // Get one MenuVariant
     * const menuVariant = await prisma.menuVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuVariantClient<$Result.GetResult<Prisma.$MenuVariantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MenuVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuVariants
     * const menuVariants = await prisma.menuVariant.findMany()
     * 
     * // Get first 10 MenuVariants
     * const menuVariants = await prisma.menuVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuVariantWithIdOnly = await prisma.menuVariant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuVariantFindManyArgs>(args?: SelectSubset<T, MenuVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MenuVariant.
     * @param {MenuVariantCreateArgs} args - Arguments to create a MenuVariant.
     * @example
     * // Create one MenuVariant
     * const MenuVariant = await prisma.menuVariant.create({
     *   data: {
     *     // ... data to create a MenuVariant
     *   }
     * })
     * 
     */
    create<T extends MenuVariantCreateArgs>(args: SelectSubset<T, MenuVariantCreateArgs<ExtArgs>>): Prisma__MenuVariantClient<$Result.GetResult<Prisma.$MenuVariantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MenuVariants.
     * @param {MenuVariantCreateManyArgs} args - Arguments to create many MenuVariants.
     * @example
     * // Create many MenuVariants
     * const menuVariant = await prisma.menuVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuVariantCreateManyArgs>(args?: SelectSubset<T, MenuVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenuVariants and returns the data saved in the database.
     * @param {MenuVariantCreateManyAndReturnArgs} args - Arguments to create many MenuVariants.
     * @example
     * // Create many MenuVariants
     * const menuVariant = await prisma.menuVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenuVariants and only return the `id`
     * const menuVariantWithIdOnly = await prisma.menuVariant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuVariantCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuVariantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuVariantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MenuVariant.
     * @param {MenuVariantDeleteArgs} args - Arguments to delete one MenuVariant.
     * @example
     * // Delete one MenuVariant
     * const MenuVariant = await prisma.menuVariant.delete({
     *   where: {
     *     // ... filter to delete one MenuVariant
     *   }
     * })
     * 
     */
    delete<T extends MenuVariantDeleteArgs>(args: SelectSubset<T, MenuVariantDeleteArgs<ExtArgs>>): Prisma__MenuVariantClient<$Result.GetResult<Prisma.$MenuVariantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MenuVariant.
     * @param {MenuVariantUpdateArgs} args - Arguments to update one MenuVariant.
     * @example
     * // Update one MenuVariant
     * const menuVariant = await prisma.menuVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuVariantUpdateArgs>(args: SelectSubset<T, MenuVariantUpdateArgs<ExtArgs>>): Prisma__MenuVariantClient<$Result.GetResult<Prisma.$MenuVariantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MenuVariants.
     * @param {MenuVariantDeleteManyArgs} args - Arguments to filter MenuVariants to delete.
     * @example
     * // Delete a few MenuVariants
     * const { count } = await prisma.menuVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuVariantDeleteManyArgs>(args?: SelectSubset<T, MenuVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuVariants
     * const menuVariant = await prisma.menuVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuVariantUpdateManyArgs>(args: SelectSubset<T, MenuVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuVariants and returns the data updated in the database.
     * @param {MenuVariantUpdateManyAndReturnArgs} args - Arguments to update many MenuVariants.
     * @example
     * // Update many MenuVariants
     * const menuVariant = await prisma.menuVariant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MenuVariants and only return the `id`
     * const menuVariantWithIdOnly = await prisma.menuVariant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenuVariantUpdateManyAndReturnArgs>(args: SelectSubset<T, MenuVariantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuVariantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MenuVariant.
     * @param {MenuVariantUpsertArgs} args - Arguments to update or create a MenuVariant.
     * @example
     * // Update or create a MenuVariant
     * const menuVariant = await prisma.menuVariant.upsert({
     *   create: {
     *     // ... data to create a MenuVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuVariant we want to update
     *   }
     * })
     */
    upsert<T extends MenuVariantUpsertArgs>(args: SelectSubset<T, MenuVariantUpsertArgs<ExtArgs>>): Prisma__MenuVariantClient<$Result.GetResult<Prisma.$MenuVariantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MenuVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuVariantCountArgs} args - Arguments to filter MenuVariants to count.
     * @example
     * // Count the number of MenuVariants
     * const count = await prisma.menuVariant.count({
     *   where: {
     *     // ... the filter for the MenuVariants we want to count
     *   }
     * })
    **/
    count<T extends MenuVariantCountArgs>(
      args?: Subset<T, MenuVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuVariantAggregateArgs>(args: Subset<T, MenuVariantAggregateArgs>): Prisma.PrismaPromise<GetMenuVariantAggregateType<T>>

    /**
     * Group by MenuVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuVariantGroupByArgs['orderBy'] }
        : { orderBy?: MenuVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenuVariant model
   */
  readonly fields: MenuVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menuItem<T extends MenuItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuItemDefaultArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offerings<T extends MenuVariant$offeringsArgs<ExtArgs> = {}>(args?: Subset<T, MenuVariant$offeringsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends MenuVariant$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, MenuVariant$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenuVariant model
   */
  interface MenuVariantFieldRefs {
    readonly id: FieldRef<"MenuVariant", 'Int'>
    readonly menuItemId: FieldRef<"MenuVariant", 'Int'>
    readonly label: FieldRef<"MenuVariant", 'String'>
    readonly basePriceCents: FieldRef<"MenuVariant", 'Int'>
    readonly baseCapacity: FieldRef<"MenuVariant", 'Int'>
    readonly isActive: FieldRef<"MenuVariant", 'Boolean'>
    readonly prepMinutes: FieldRef<"MenuVariant", 'Int'>
    readonly packagingCostCents: FieldRef<"MenuVariant", 'Int'>
    readonly createdAt: FieldRef<"MenuVariant", 'DateTime'>
    readonly updatedAt: FieldRef<"MenuVariant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MenuVariant findUnique
   */
  export type MenuVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuVariant
     */
    select?: MenuVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuVariant
     */
    omit?: MenuVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuVariantInclude<ExtArgs> | null
    /**
     * Filter, which MenuVariant to fetch.
     */
    where: MenuVariantWhereUniqueInput
  }

  /**
   * MenuVariant findUniqueOrThrow
   */
  export type MenuVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuVariant
     */
    select?: MenuVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuVariant
     */
    omit?: MenuVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuVariantInclude<ExtArgs> | null
    /**
     * Filter, which MenuVariant to fetch.
     */
    where: MenuVariantWhereUniqueInput
  }

  /**
   * MenuVariant findFirst
   */
  export type MenuVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuVariant
     */
    select?: MenuVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuVariant
     */
    omit?: MenuVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuVariantInclude<ExtArgs> | null
    /**
     * Filter, which MenuVariant to fetch.
     */
    where?: MenuVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuVariants to fetch.
     */
    orderBy?: MenuVariantOrderByWithRelationInput | MenuVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuVariants.
     */
    cursor?: MenuVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuVariants.
     */
    distinct?: MenuVariantScalarFieldEnum | MenuVariantScalarFieldEnum[]
  }

  /**
   * MenuVariant findFirstOrThrow
   */
  export type MenuVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuVariant
     */
    select?: MenuVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuVariant
     */
    omit?: MenuVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuVariantInclude<ExtArgs> | null
    /**
     * Filter, which MenuVariant to fetch.
     */
    where?: MenuVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuVariants to fetch.
     */
    orderBy?: MenuVariantOrderByWithRelationInput | MenuVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuVariants.
     */
    cursor?: MenuVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuVariants.
     */
    distinct?: MenuVariantScalarFieldEnum | MenuVariantScalarFieldEnum[]
  }

  /**
   * MenuVariant findMany
   */
  export type MenuVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuVariant
     */
    select?: MenuVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuVariant
     */
    omit?: MenuVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuVariantInclude<ExtArgs> | null
    /**
     * Filter, which MenuVariants to fetch.
     */
    where?: MenuVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuVariants to fetch.
     */
    orderBy?: MenuVariantOrderByWithRelationInput | MenuVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuVariants.
     */
    cursor?: MenuVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuVariants.
     */
    skip?: number
    distinct?: MenuVariantScalarFieldEnum | MenuVariantScalarFieldEnum[]
  }

  /**
   * MenuVariant create
   */
  export type MenuVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuVariant
     */
    select?: MenuVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuVariant
     */
    omit?: MenuVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a MenuVariant.
     */
    data: XOR<MenuVariantCreateInput, MenuVariantUncheckedCreateInput>
  }

  /**
   * MenuVariant createMany
   */
  export type MenuVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenuVariants.
     */
    data: MenuVariantCreateManyInput | MenuVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenuVariant createManyAndReturn
   */
  export type MenuVariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuVariant
     */
    select?: MenuVariantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenuVariant
     */
    omit?: MenuVariantOmit<ExtArgs> | null
    /**
     * The data used to create many MenuVariants.
     */
    data: MenuVariantCreateManyInput | MenuVariantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuVariantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuVariant update
   */
  export type MenuVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuVariant
     */
    select?: MenuVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuVariant
     */
    omit?: MenuVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a MenuVariant.
     */
    data: XOR<MenuVariantUpdateInput, MenuVariantUncheckedUpdateInput>
    /**
     * Choose, which MenuVariant to update.
     */
    where: MenuVariantWhereUniqueInput
  }

  /**
   * MenuVariant updateMany
   */
  export type MenuVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenuVariants.
     */
    data: XOR<MenuVariantUpdateManyMutationInput, MenuVariantUncheckedUpdateManyInput>
    /**
     * Filter which MenuVariants to update
     */
    where?: MenuVariantWhereInput
    /**
     * Limit how many MenuVariants to update.
     */
    limit?: number
  }

  /**
   * MenuVariant updateManyAndReturn
   */
  export type MenuVariantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuVariant
     */
    select?: MenuVariantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenuVariant
     */
    omit?: MenuVariantOmit<ExtArgs> | null
    /**
     * The data used to update MenuVariants.
     */
    data: XOR<MenuVariantUpdateManyMutationInput, MenuVariantUncheckedUpdateManyInput>
    /**
     * Filter which MenuVariants to update
     */
    where?: MenuVariantWhereInput
    /**
     * Limit how many MenuVariants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuVariantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuVariant upsert
   */
  export type MenuVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuVariant
     */
    select?: MenuVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuVariant
     */
    omit?: MenuVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the MenuVariant to update in case it exists.
     */
    where: MenuVariantWhereUniqueInput
    /**
     * In case the MenuVariant found by the `where` argument doesn't exist, create a new MenuVariant with this data.
     */
    create: XOR<MenuVariantCreateInput, MenuVariantUncheckedCreateInput>
    /**
     * In case the MenuVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuVariantUpdateInput, MenuVariantUncheckedUpdateInput>
  }

  /**
   * MenuVariant delete
   */
  export type MenuVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuVariant
     */
    select?: MenuVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuVariant
     */
    omit?: MenuVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuVariantInclude<ExtArgs> | null
    /**
     * Filter which MenuVariant to delete.
     */
    where: MenuVariantWhereUniqueInput
  }

  /**
   * MenuVariant deleteMany
   */
  export type MenuVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuVariants to delete
     */
    where?: MenuVariantWhereInput
    /**
     * Limit how many MenuVariants to delete.
     */
    limit?: number
  }

  /**
   * MenuVariant.offerings
   */
  export type MenuVariant$offeringsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuOffering
     */
    select?: MenuOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuOffering
     */
    omit?: MenuOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuOfferingInclude<ExtArgs> | null
    where?: MenuOfferingWhereInput
    orderBy?: MenuOfferingOrderByWithRelationInput | MenuOfferingOrderByWithRelationInput[]
    cursor?: MenuOfferingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuOfferingScalarFieldEnum | MenuOfferingScalarFieldEnum[]
  }

  /**
   * MenuVariant.orderItems
   */
  export type MenuVariant$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * MenuVariant without action
   */
  export type MenuVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuVariant
     */
    select?: MenuVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuVariant
     */
    omit?: MenuVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuVariantInclude<ExtArgs> | null
  }


  /**
   * Model AddOn
   */

  export type AggregateAddOn = {
    _count: AddOnCountAggregateOutputType | null
    _avg: AddOnAvgAggregateOutputType | null
    _sum: AddOnSumAggregateOutputType | null
    _min: AddOnMinAggregateOutputType | null
    _max: AddOnMaxAggregateOutputType | null
  }

  export type AddOnAvgAggregateOutputType = {
    id: number | null
    priceCents: number | null
  }

  export type AddOnSumAggregateOutputType = {
    id: number | null
    priceCents: number | null
  }

  export type AddOnMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    imageUrl: string | null
    priceCents: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddOnMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    imageUrl: string | null
    priceCents: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddOnCountAggregateOutputType = {
    id: number
    name: number
    description: number
    imageUrl: number
    priceCents: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddOnAvgAggregateInputType = {
    id?: true
    priceCents?: true
  }

  export type AddOnSumAggregateInputType = {
    id?: true
    priceCents?: true
  }

  export type AddOnMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    priceCents?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddOnMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    priceCents?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddOnCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    priceCents?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddOnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddOn to aggregate.
     */
    where?: AddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnOrderByWithRelationInput | AddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddOns
    **/
    _count?: true | AddOnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddOnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddOnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddOnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddOnMaxAggregateInputType
  }

  export type GetAddOnAggregateType<T extends AddOnAggregateArgs> = {
        [P in keyof T & keyof AggregateAddOn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddOn[P]>
      : GetScalarType<T[P], AggregateAddOn[P]>
  }




  export type AddOnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddOnWhereInput
    orderBy?: AddOnOrderByWithAggregationInput | AddOnOrderByWithAggregationInput[]
    by: AddOnScalarFieldEnum[] | AddOnScalarFieldEnum
    having?: AddOnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddOnCountAggregateInputType | true
    _avg?: AddOnAvgAggregateInputType
    _sum?: AddOnSumAggregateInputType
    _min?: AddOnMinAggregateInputType
    _max?: AddOnMaxAggregateInputType
  }

  export type AddOnGroupByOutputType = {
    id: number
    name: string
    description: string | null
    imageUrl: string | null
    priceCents: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AddOnCountAggregateOutputType | null
    _avg: AddOnAvgAggregateOutputType | null
    _sum: AddOnSumAggregateOutputType | null
    _min: AddOnMinAggregateOutputType | null
    _max: AddOnMaxAggregateOutputType | null
  }

  type GetAddOnGroupByPayload<T extends AddOnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddOnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddOnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddOnGroupByOutputType[P]>
            : GetScalarType<T[P], AddOnGroupByOutputType[P]>
        }
      >
    >


  export type AddOnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    priceCents?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    itemLinks?: boolean | AddOn$itemLinksArgs<ExtArgs>
    orderLinks?: boolean | AddOn$orderLinksArgs<ExtArgs>
    _count?: boolean | AddOnCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addOn"]>

  export type AddOnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    priceCents?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["addOn"]>

  export type AddOnSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    priceCents?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["addOn"]>

  export type AddOnSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    priceCents?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddOnOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "imageUrl" | "priceCents" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["addOn"]>
  export type AddOnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemLinks?: boolean | AddOn$itemLinksArgs<ExtArgs>
    orderLinks?: boolean | AddOn$orderLinksArgs<ExtArgs>
    _count?: boolean | AddOnCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AddOnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AddOnIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AddOnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddOn"
    objects: {
      itemLinks: Prisma.$MenuItemAddOnPayload<ExtArgs>[]
      orderLinks: Prisma.$OrderItemAddOnPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      imageUrl: string | null
      priceCents: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["addOn"]>
    composites: {}
  }

  type AddOnGetPayload<S extends boolean | null | undefined | AddOnDefaultArgs> = $Result.GetResult<Prisma.$AddOnPayload, S>

  type AddOnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddOnFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddOnCountAggregateInputType | true
    }

  export interface AddOnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddOn'], meta: { name: 'AddOn' } }
    /**
     * Find zero or one AddOn that matches the filter.
     * @param {AddOnFindUniqueArgs} args - Arguments to find a AddOn
     * @example
     * // Get one AddOn
     * const addOn = await prisma.addOn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddOnFindUniqueArgs>(args: SelectSubset<T, AddOnFindUniqueArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddOn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddOnFindUniqueOrThrowArgs} args - Arguments to find a AddOn
     * @example
     * // Get one AddOn
     * const addOn = await prisma.addOn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddOnFindUniqueOrThrowArgs>(args: SelectSubset<T, AddOnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddOn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnFindFirstArgs} args - Arguments to find a AddOn
     * @example
     * // Get one AddOn
     * const addOn = await prisma.addOn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddOnFindFirstArgs>(args?: SelectSubset<T, AddOnFindFirstArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddOn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnFindFirstOrThrowArgs} args - Arguments to find a AddOn
     * @example
     * // Get one AddOn
     * const addOn = await prisma.addOn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddOnFindFirstOrThrowArgs>(args?: SelectSubset<T, AddOnFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddOns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddOns
     * const addOns = await prisma.addOn.findMany()
     * 
     * // Get first 10 AddOns
     * const addOns = await prisma.addOn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addOnWithIdOnly = await prisma.addOn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddOnFindManyArgs>(args?: SelectSubset<T, AddOnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddOn.
     * @param {AddOnCreateArgs} args - Arguments to create a AddOn.
     * @example
     * // Create one AddOn
     * const AddOn = await prisma.addOn.create({
     *   data: {
     *     // ... data to create a AddOn
     *   }
     * })
     * 
     */
    create<T extends AddOnCreateArgs>(args: SelectSubset<T, AddOnCreateArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddOns.
     * @param {AddOnCreateManyArgs} args - Arguments to create many AddOns.
     * @example
     * // Create many AddOns
     * const addOn = await prisma.addOn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddOnCreateManyArgs>(args?: SelectSubset<T, AddOnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AddOns and returns the data saved in the database.
     * @param {AddOnCreateManyAndReturnArgs} args - Arguments to create many AddOns.
     * @example
     * // Create many AddOns
     * const addOn = await prisma.addOn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AddOns and only return the `id`
     * const addOnWithIdOnly = await prisma.addOn.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddOnCreateManyAndReturnArgs>(args?: SelectSubset<T, AddOnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AddOn.
     * @param {AddOnDeleteArgs} args - Arguments to delete one AddOn.
     * @example
     * // Delete one AddOn
     * const AddOn = await prisma.addOn.delete({
     *   where: {
     *     // ... filter to delete one AddOn
     *   }
     * })
     * 
     */
    delete<T extends AddOnDeleteArgs>(args: SelectSubset<T, AddOnDeleteArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddOn.
     * @param {AddOnUpdateArgs} args - Arguments to update one AddOn.
     * @example
     * // Update one AddOn
     * const addOn = await prisma.addOn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddOnUpdateArgs>(args: SelectSubset<T, AddOnUpdateArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddOns.
     * @param {AddOnDeleteManyArgs} args - Arguments to filter AddOns to delete.
     * @example
     * // Delete a few AddOns
     * const { count } = await prisma.addOn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddOnDeleteManyArgs>(args?: SelectSubset<T, AddOnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddOns
     * const addOn = await prisma.addOn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddOnUpdateManyArgs>(args: SelectSubset<T, AddOnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddOns and returns the data updated in the database.
     * @param {AddOnUpdateManyAndReturnArgs} args - Arguments to update many AddOns.
     * @example
     * // Update many AddOns
     * const addOn = await prisma.addOn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AddOns and only return the `id`
     * const addOnWithIdOnly = await prisma.addOn.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddOnUpdateManyAndReturnArgs>(args: SelectSubset<T, AddOnUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AddOn.
     * @param {AddOnUpsertArgs} args - Arguments to update or create a AddOn.
     * @example
     * // Update or create a AddOn
     * const addOn = await prisma.addOn.upsert({
     *   create: {
     *     // ... data to create a AddOn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddOn we want to update
     *   }
     * })
     */
    upsert<T extends AddOnUpsertArgs>(args: SelectSubset<T, AddOnUpsertArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnCountArgs} args - Arguments to filter AddOns to count.
     * @example
     * // Count the number of AddOns
     * const count = await prisma.addOn.count({
     *   where: {
     *     // ... the filter for the AddOns we want to count
     *   }
     * })
    **/
    count<T extends AddOnCountArgs>(
      args?: Subset<T, AddOnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddOnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddOn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddOnAggregateArgs>(args: Subset<T, AddOnAggregateArgs>): Prisma.PrismaPromise<GetAddOnAggregateType<T>>

    /**
     * Group by AddOn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddOnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddOnGroupByArgs['orderBy'] }
        : { orderBy?: AddOnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddOnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddOnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddOn model
   */
  readonly fields: AddOnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddOn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddOnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itemLinks<T extends AddOn$itemLinksArgs<ExtArgs> = {}>(args?: Subset<T, AddOn$itemLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemAddOnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderLinks<T extends AddOn$orderLinksArgs<ExtArgs> = {}>(args?: Subset<T, AddOn$orderLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemAddOnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddOn model
   */
  interface AddOnFieldRefs {
    readonly id: FieldRef<"AddOn", 'Int'>
    readonly name: FieldRef<"AddOn", 'String'>
    readonly description: FieldRef<"AddOn", 'String'>
    readonly imageUrl: FieldRef<"AddOn", 'String'>
    readonly priceCents: FieldRef<"AddOn", 'Int'>
    readonly isActive: FieldRef<"AddOn", 'Boolean'>
    readonly createdAt: FieldRef<"AddOn", 'DateTime'>
    readonly updatedAt: FieldRef<"AddOn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AddOn findUnique
   */
  export type AddOnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOn
     */
    omit?: AddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * Filter, which AddOn to fetch.
     */
    where: AddOnWhereUniqueInput
  }

  /**
   * AddOn findUniqueOrThrow
   */
  export type AddOnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOn
     */
    omit?: AddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * Filter, which AddOn to fetch.
     */
    where: AddOnWhereUniqueInput
  }

  /**
   * AddOn findFirst
   */
  export type AddOnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOn
     */
    omit?: AddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * Filter, which AddOn to fetch.
     */
    where?: AddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnOrderByWithRelationInput | AddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddOns.
     */
    cursor?: AddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddOns.
     */
    distinct?: AddOnScalarFieldEnum | AddOnScalarFieldEnum[]
  }

  /**
   * AddOn findFirstOrThrow
   */
  export type AddOnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOn
     */
    omit?: AddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * Filter, which AddOn to fetch.
     */
    where?: AddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnOrderByWithRelationInput | AddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddOns.
     */
    cursor?: AddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddOns.
     */
    distinct?: AddOnScalarFieldEnum | AddOnScalarFieldEnum[]
  }

  /**
   * AddOn findMany
   */
  export type AddOnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOn
     */
    omit?: AddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where?: AddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnOrderByWithRelationInput | AddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddOns.
     */
    cursor?: AddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    distinct?: AddOnScalarFieldEnum | AddOnScalarFieldEnum[]
  }

  /**
   * AddOn create
   */
  export type AddOnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOn
     */
    omit?: AddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * The data needed to create a AddOn.
     */
    data: XOR<AddOnCreateInput, AddOnUncheckedCreateInput>
  }

  /**
   * AddOn createMany
   */
  export type AddOnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddOns.
     */
    data: AddOnCreateManyInput | AddOnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddOn createManyAndReturn
   */
  export type AddOnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AddOn
     */
    omit?: AddOnOmit<ExtArgs> | null
    /**
     * The data used to create many AddOns.
     */
    data: AddOnCreateManyInput | AddOnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddOn update
   */
  export type AddOnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOn
     */
    omit?: AddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * The data needed to update a AddOn.
     */
    data: XOR<AddOnUpdateInput, AddOnUncheckedUpdateInput>
    /**
     * Choose, which AddOn to update.
     */
    where: AddOnWhereUniqueInput
  }

  /**
   * AddOn updateMany
   */
  export type AddOnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddOns.
     */
    data: XOR<AddOnUpdateManyMutationInput, AddOnUncheckedUpdateManyInput>
    /**
     * Filter which AddOns to update
     */
    where?: AddOnWhereInput
    /**
     * Limit how many AddOns to update.
     */
    limit?: number
  }

  /**
   * AddOn updateManyAndReturn
   */
  export type AddOnUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AddOn
     */
    omit?: AddOnOmit<ExtArgs> | null
    /**
     * The data used to update AddOns.
     */
    data: XOR<AddOnUpdateManyMutationInput, AddOnUncheckedUpdateManyInput>
    /**
     * Filter which AddOns to update
     */
    where?: AddOnWhereInput
    /**
     * Limit how many AddOns to update.
     */
    limit?: number
  }

  /**
   * AddOn upsert
   */
  export type AddOnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOn
     */
    omit?: AddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * The filter to search for the AddOn to update in case it exists.
     */
    where: AddOnWhereUniqueInput
    /**
     * In case the AddOn found by the `where` argument doesn't exist, create a new AddOn with this data.
     */
    create: XOR<AddOnCreateInput, AddOnUncheckedCreateInput>
    /**
     * In case the AddOn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddOnUpdateInput, AddOnUncheckedUpdateInput>
  }

  /**
   * AddOn delete
   */
  export type AddOnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOn
     */
    omit?: AddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    /**
     * Filter which AddOn to delete.
     */
    where: AddOnWhereUniqueInput
  }

  /**
   * AddOn deleteMany
   */
  export type AddOnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddOns to delete
     */
    where?: AddOnWhereInput
    /**
     * Limit how many AddOns to delete.
     */
    limit?: number
  }

  /**
   * AddOn.itemLinks
   */
  export type AddOn$itemLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemAddOn
     */
    select?: MenuItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemAddOn
     */
    omit?: MenuItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemAddOnInclude<ExtArgs> | null
    where?: MenuItemAddOnWhereInput
    orderBy?: MenuItemAddOnOrderByWithRelationInput | MenuItemAddOnOrderByWithRelationInput[]
    cursor?: MenuItemAddOnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuItemAddOnScalarFieldEnum | MenuItemAddOnScalarFieldEnum[]
  }

  /**
   * AddOn.orderLinks
   */
  export type AddOn$orderLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemAddOn
     */
    select?: OrderItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemAddOn
     */
    omit?: OrderItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemAddOnInclude<ExtArgs> | null
    where?: OrderItemAddOnWhereInput
    orderBy?: OrderItemAddOnOrderByWithRelationInput | OrderItemAddOnOrderByWithRelationInput[]
    cursor?: OrderItemAddOnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemAddOnScalarFieldEnum | OrderItemAddOnScalarFieldEnum[]
  }

  /**
   * AddOn without action
   */
  export type AddOnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOn
     */
    omit?: AddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
  }


  /**
   * Model MenuItemAddOn
   */

  export type AggregateMenuItemAddOn = {
    _count: MenuItemAddOnCountAggregateOutputType | null
    _avg: MenuItemAddOnAvgAggregateOutputType | null
    _sum: MenuItemAddOnSumAggregateOutputType | null
    _min: MenuItemAddOnMinAggregateOutputType | null
    _max: MenuItemAddOnMaxAggregateOutputType | null
  }

  export type MenuItemAddOnAvgAggregateOutputType = {
    menuItemId: number | null
    addOnId: number | null
    maxQtyPerItem: number | null
  }

  export type MenuItemAddOnSumAggregateOutputType = {
    menuItemId: number | null
    addOnId: number | null
    maxQtyPerItem: number | null
  }

  export type MenuItemAddOnMinAggregateOutputType = {
    menuItemId: number | null
    addOnId: number | null
    maxQtyPerItem: number | null
  }

  export type MenuItemAddOnMaxAggregateOutputType = {
    menuItemId: number | null
    addOnId: number | null
    maxQtyPerItem: number | null
  }

  export type MenuItemAddOnCountAggregateOutputType = {
    menuItemId: number
    addOnId: number
    maxQtyPerItem: number
    _all: number
  }


  export type MenuItemAddOnAvgAggregateInputType = {
    menuItemId?: true
    addOnId?: true
    maxQtyPerItem?: true
  }

  export type MenuItemAddOnSumAggregateInputType = {
    menuItemId?: true
    addOnId?: true
    maxQtyPerItem?: true
  }

  export type MenuItemAddOnMinAggregateInputType = {
    menuItemId?: true
    addOnId?: true
    maxQtyPerItem?: true
  }

  export type MenuItemAddOnMaxAggregateInputType = {
    menuItemId?: true
    addOnId?: true
    maxQtyPerItem?: true
  }

  export type MenuItemAddOnCountAggregateInputType = {
    menuItemId?: true
    addOnId?: true
    maxQtyPerItem?: true
    _all?: true
  }

  export type MenuItemAddOnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuItemAddOn to aggregate.
     */
    where?: MenuItemAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemAddOns to fetch.
     */
    orderBy?: MenuItemAddOnOrderByWithRelationInput | MenuItemAddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuItemAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemAddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuItemAddOns
    **/
    _count?: true | MenuItemAddOnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuItemAddOnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuItemAddOnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuItemAddOnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuItemAddOnMaxAggregateInputType
  }

  export type GetMenuItemAddOnAggregateType<T extends MenuItemAddOnAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuItemAddOn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuItemAddOn[P]>
      : GetScalarType<T[P], AggregateMenuItemAddOn[P]>
  }




  export type MenuItemAddOnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemAddOnWhereInput
    orderBy?: MenuItemAddOnOrderByWithAggregationInput | MenuItemAddOnOrderByWithAggregationInput[]
    by: MenuItemAddOnScalarFieldEnum[] | MenuItemAddOnScalarFieldEnum
    having?: MenuItemAddOnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuItemAddOnCountAggregateInputType | true
    _avg?: MenuItemAddOnAvgAggregateInputType
    _sum?: MenuItemAddOnSumAggregateInputType
    _min?: MenuItemAddOnMinAggregateInputType
    _max?: MenuItemAddOnMaxAggregateInputType
  }

  export type MenuItemAddOnGroupByOutputType = {
    menuItemId: number
    addOnId: number
    maxQtyPerItem: number | null
    _count: MenuItemAddOnCountAggregateOutputType | null
    _avg: MenuItemAddOnAvgAggregateOutputType | null
    _sum: MenuItemAddOnSumAggregateOutputType | null
    _min: MenuItemAddOnMinAggregateOutputType | null
    _max: MenuItemAddOnMaxAggregateOutputType | null
  }

  type GetMenuItemAddOnGroupByPayload<T extends MenuItemAddOnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuItemAddOnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuItemAddOnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuItemAddOnGroupByOutputType[P]>
            : GetScalarType<T[P], MenuItemAddOnGroupByOutputType[P]>
        }
      >
    >


  export type MenuItemAddOnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    menuItemId?: boolean
    addOnId?: boolean
    maxQtyPerItem?: boolean
    menuItem?: boolean | MenuItemDefaultArgs<ExtArgs>
    addOn?: boolean | AddOnDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItemAddOn"]>

  export type MenuItemAddOnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    menuItemId?: boolean
    addOnId?: boolean
    maxQtyPerItem?: boolean
    menuItem?: boolean | MenuItemDefaultArgs<ExtArgs>
    addOn?: boolean | AddOnDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItemAddOn"]>

  export type MenuItemAddOnSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    menuItemId?: boolean
    addOnId?: boolean
    maxQtyPerItem?: boolean
    menuItem?: boolean | MenuItemDefaultArgs<ExtArgs>
    addOn?: boolean | AddOnDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItemAddOn"]>

  export type MenuItemAddOnSelectScalar = {
    menuItemId?: boolean
    addOnId?: boolean
    maxQtyPerItem?: boolean
  }

  export type MenuItemAddOnOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"menuItemId" | "addOnId" | "maxQtyPerItem", ExtArgs["result"]["menuItemAddOn"]>
  export type MenuItemAddOnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menuItem?: boolean | MenuItemDefaultArgs<ExtArgs>
    addOn?: boolean | AddOnDefaultArgs<ExtArgs>
  }
  export type MenuItemAddOnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menuItem?: boolean | MenuItemDefaultArgs<ExtArgs>
    addOn?: boolean | AddOnDefaultArgs<ExtArgs>
  }
  export type MenuItemAddOnIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menuItem?: boolean | MenuItemDefaultArgs<ExtArgs>
    addOn?: boolean | AddOnDefaultArgs<ExtArgs>
  }

  export type $MenuItemAddOnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenuItemAddOn"
    objects: {
      menuItem: Prisma.$MenuItemPayload<ExtArgs>
      addOn: Prisma.$AddOnPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      menuItemId: number
      addOnId: number
      maxQtyPerItem: number | null
    }, ExtArgs["result"]["menuItemAddOn"]>
    composites: {}
  }

  type MenuItemAddOnGetPayload<S extends boolean | null | undefined | MenuItemAddOnDefaultArgs> = $Result.GetResult<Prisma.$MenuItemAddOnPayload, S>

  type MenuItemAddOnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenuItemAddOnFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenuItemAddOnCountAggregateInputType | true
    }

  export interface MenuItemAddOnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenuItemAddOn'], meta: { name: 'MenuItemAddOn' } }
    /**
     * Find zero or one MenuItemAddOn that matches the filter.
     * @param {MenuItemAddOnFindUniqueArgs} args - Arguments to find a MenuItemAddOn
     * @example
     * // Get one MenuItemAddOn
     * const menuItemAddOn = await prisma.menuItemAddOn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuItemAddOnFindUniqueArgs>(args: SelectSubset<T, MenuItemAddOnFindUniqueArgs<ExtArgs>>): Prisma__MenuItemAddOnClient<$Result.GetResult<Prisma.$MenuItemAddOnPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MenuItemAddOn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenuItemAddOnFindUniqueOrThrowArgs} args - Arguments to find a MenuItemAddOn
     * @example
     * // Get one MenuItemAddOn
     * const menuItemAddOn = await prisma.menuItemAddOn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuItemAddOnFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuItemAddOnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuItemAddOnClient<$Result.GetResult<Prisma.$MenuItemAddOnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenuItemAddOn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemAddOnFindFirstArgs} args - Arguments to find a MenuItemAddOn
     * @example
     * // Get one MenuItemAddOn
     * const menuItemAddOn = await prisma.menuItemAddOn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuItemAddOnFindFirstArgs>(args?: SelectSubset<T, MenuItemAddOnFindFirstArgs<ExtArgs>>): Prisma__MenuItemAddOnClient<$Result.GetResult<Prisma.$MenuItemAddOnPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenuItemAddOn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemAddOnFindFirstOrThrowArgs} args - Arguments to find a MenuItemAddOn
     * @example
     * // Get one MenuItemAddOn
     * const menuItemAddOn = await prisma.menuItemAddOn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuItemAddOnFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuItemAddOnFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuItemAddOnClient<$Result.GetResult<Prisma.$MenuItemAddOnPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MenuItemAddOns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemAddOnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuItemAddOns
     * const menuItemAddOns = await prisma.menuItemAddOn.findMany()
     * 
     * // Get first 10 MenuItemAddOns
     * const menuItemAddOns = await prisma.menuItemAddOn.findMany({ take: 10 })
     * 
     * // Only select the `menuItemId`
     * const menuItemAddOnWithMenuItemIdOnly = await prisma.menuItemAddOn.findMany({ select: { menuItemId: true } })
     * 
     */
    findMany<T extends MenuItemAddOnFindManyArgs>(args?: SelectSubset<T, MenuItemAddOnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemAddOnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MenuItemAddOn.
     * @param {MenuItemAddOnCreateArgs} args - Arguments to create a MenuItemAddOn.
     * @example
     * // Create one MenuItemAddOn
     * const MenuItemAddOn = await prisma.menuItemAddOn.create({
     *   data: {
     *     // ... data to create a MenuItemAddOn
     *   }
     * })
     * 
     */
    create<T extends MenuItemAddOnCreateArgs>(args: SelectSubset<T, MenuItemAddOnCreateArgs<ExtArgs>>): Prisma__MenuItemAddOnClient<$Result.GetResult<Prisma.$MenuItemAddOnPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MenuItemAddOns.
     * @param {MenuItemAddOnCreateManyArgs} args - Arguments to create many MenuItemAddOns.
     * @example
     * // Create many MenuItemAddOns
     * const menuItemAddOn = await prisma.menuItemAddOn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuItemAddOnCreateManyArgs>(args?: SelectSubset<T, MenuItemAddOnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenuItemAddOns and returns the data saved in the database.
     * @param {MenuItemAddOnCreateManyAndReturnArgs} args - Arguments to create many MenuItemAddOns.
     * @example
     * // Create many MenuItemAddOns
     * const menuItemAddOn = await prisma.menuItemAddOn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenuItemAddOns and only return the `menuItemId`
     * const menuItemAddOnWithMenuItemIdOnly = await prisma.menuItemAddOn.createManyAndReturn({
     *   select: { menuItemId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuItemAddOnCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuItemAddOnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemAddOnPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MenuItemAddOn.
     * @param {MenuItemAddOnDeleteArgs} args - Arguments to delete one MenuItemAddOn.
     * @example
     * // Delete one MenuItemAddOn
     * const MenuItemAddOn = await prisma.menuItemAddOn.delete({
     *   where: {
     *     // ... filter to delete one MenuItemAddOn
     *   }
     * })
     * 
     */
    delete<T extends MenuItemAddOnDeleteArgs>(args: SelectSubset<T, MenuItemAddOnDeleteArgs<ExtArgs>>): Prisma__MenuItemAddOnClient<$Result.GetResult<Prisma.$MenuItemAddOnPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MenuItemAddOn.
     * @param {MenuItemAddOnUpdateArgs} args - Arguments to update one MenuItemAddOn.
     * @example
     * // Update one MenuItemAddOn
     * const menuItemAddOn = await prisma.menuItemAddOn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuItemAddOnUpdateArgs>(args: SelectSubset<T, MenuItemAddOnUpdateArgs<ExtArgs>>): Prisma__MenuItemAddOnClient<$Result.GetResult<Prisma.$MenuItemAddOnPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MenuItemAddOns.
     * @param {MenuItemAddOnDeleteManyArgs} args - Arguments to filter MenuItemAddOns to delete.
     * @example
     * // Delete a few MenuItemAddOns
     * const { count } = await prisma.menuItemAddOn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuItemAddOnDeleteManyArgs>(args?: SelectSubset<T, MenuItemAddOnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuItemAddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemAddOnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuItemAddOns
     * const menuItemAddOn = await prisma.menuItemAddOn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuItemAddOnUpdateManyArgs>(args: SelectSubset<T, MenuItemAddOnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuItemAddOns and returns the data updated in the database.
     * @param {MenuItemAddOnUpdateManyAndReturnArgs} args - Arguments to update many MenuItemAddOns.
     * @example
     * // Update many MenuItemAddOns
     * const menuItemAddOn = await prisma.menuItemAddOn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MenuItemAddOns and only return the `menuItemId`
     * const menuItemAddOnWithMenuItemIdOnly = await prisma.menuItemAddOn.updateManyAndReturn({
     *   select: { menuItemId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenuItemAddOnUpdateManyAndReturnArgs>(args: SelectSubset<T, MenuItemAddOnUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemAddOnPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MenuItemAddOn.
     * @param {MenuItemAddOnUpsertArgs} args - Arguments to update or create a MenuItemAddOn.
     * @example
     * // Update or create a MenuItemAddOn
     * const menuItemAddOn = await prisma.menuItemAddOn.upsert({
     *   create: {
     *     // ... data to create a MenuItemAddOn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuItemAddOn we want to update
     *   }
     * })
     */
    upsert<T extends MenuItemAddOnUpsertArgs>(args: SelectSubset<T, MenuItemAddOnUpsertArgs<ExtArgs>>): Prisma__MenuItemAddOnClient<$Result.GetResult<Prisma.$MenuItemAddOnPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MenuItemAddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemAddOnCountArgs} args - Arguments to filter MenuItemAddOns to count.
     * @example
     * // Count the number of MenuItemAddOns
     * const count = await prisma.menuItemAddOn.count({
     *   where: {
     *     // ... the filter for the MenuItemAddOns we want to count
     *   }
     * })
    **/
    count<T extends MenuItemAddOnCountArgs>(
      args?: Subset<T, MenuItemAddOnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuItemAddOnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuItemAddOn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemAddOnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuItemAddOnAggregateArgs>(args: Subset<T, MenuItemAddOnAggregateArgs>): Prisma.PrismaPromise<GetMenuItemAddOnAggregateType<T>>

    /**
     * Group by MenuItemAddOn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemAddOnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuItemAddOnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuItemAddOnGroupByArgs['orderBy'] }
        : { orderBy?: MenuItemAddOnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuItemAddOnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuItemAddOnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenuItemAddOn model
   */
  readonly fields: MenuItemAddOnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuItemAddOn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuItemAddOnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menuItem<T extends MenuItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuItemDefaultArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addOn<T extends AddOnDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddOnDefaultArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenuItemAddOn model
   */
  interface MenuItemAddOnFieldRefs {
    readonly menuItemId: FieldRef<"MenuItemAddOn", 'Int'>
    readonly addOnId: FieldRef<"MenuItemAddOn", 'Int'>
    readonly maxQtyPerItem: FieldRef<"MenuItemAddOn", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MenuItemAddOn findUnique
   */
  export type MenuItemAddOnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemAddOn
     */
    select?: MenuItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemAddOn
     */
    omit?: MenuItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemAddOnInclude<ExtArgs> | null
    /**
     * Filter, which MenuItemAddOn to fetch.
     */
    where: MenuItemAddOnWhereUniqueInput
  }

  /**
   * MenuItemAddOn findUniqueOrThrow
   */
  export type MenuItemAddOnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemAddOn
     */
    select?: MenuItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemAddOn
     */
    omit?: MenuItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemAddOnInclude<ExtArgs> | null
    /**
     * Filter, which MenuItemAddOn to fetch.
     */
    where: MenuItemAddOnWhereUniqueInput
  }

  /**
   * MenuItemAddOn findFirst
   */
  export type MenuItemAddOnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemAddOn
     */
    select?: MenuItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemAddOn
     */
    omit?: MenuItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemAddOnInclude<ExtArgs> | null
    /**
     * Filter, which MenuItemAddOn to fetch.
     */
    where?: MenuItemAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemAddOns to fetch.
     */
    orderBy?: MenuItemAddOnOrderByWithRelationInput | MenuItemAddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItemAddOns.
     */
    cursor?: MenuItemAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemAddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItemAddOns.
     */
    distinct?: MenuItemAddOnScalarFieldEnum | MenuItemAddOnScalarFieldEnum[]
  }

  /**
   * MenuItemAddOn findFirstOrThrow
   */
  export type MenuItemAddOnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemAddOn
     */
    select?: MenuItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemAddOn
     */
    omit?: MenuItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemAddOnInclude<ExtArgs> | null
    /**
     * Filter, which MenuItemAddOn to fetch.
     */
    where?: MenuItemAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemAddOns to fetch.
     */
    orderBy?: MenuItemAddOnOrderByWithRelationInput | MenuItemAddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItemAddOns.
     */
    cursor?: MenuItemAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemAddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItemAddOns.
     */
    distinct?: MenuItemAddOnScalarFieldEnum | MenuItemAddOnScalarFieldEnum[]
  }

  /**
   * MenuItemAddOn findMany
   */
  export type MenuItemAddOnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemAddOn
     */
    select?: MenuItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemAddOn
     */
    omit?: MenuItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemAddOnInclude<ExtArgs> | null
    /**
     * Filter, which MenuItemAddOns to fetch.
     */
    where?: MenuItemAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItemAddOns to fetch.
     */
    orderBy?: MenuItemAddOnOrderByWithRelationInput | MenuItemAddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuItemAddOns.
     */
    cursor?: MenuItemAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItemAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItemAddOns.
     */
    skip?: number
    distinct?: MenuItemAddOnScalarFieldEnum | MenuItemAddOnScalarFieldEnum[]
  }

  /**
   * MenuItemAddOn create
   */
  export type MenuItemAddOnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemAddOn
     */
    select?: MenuItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemAddOn
     */
    omit?: MenuItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemAddOnInclude<ExtArgs> | null
    /**
     * The data needed to create a MenuItemAddOn.
     */
    data: XOR<MenuItemAddOnCreateInput, MenuItemAddOnUncheckedCreateInput>
  }

  /**
   * MenuItemAddOn createMany
   */
  export type MenuItemAddOnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenuItemAddOns.
     */
    data: MenuItemAddOnCreateManyInput | MenuItemAddOnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenuItemAddOn createManyAndReturn
   */
  export type MenuItemAddOnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemAddOn
     */
    select?: MenuItemAddOnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemAddOn
     */
    omit?: MenuItemAddOnOmit<ExtArgs> | null
    /**
     * The data used to create many MenuItemAddOns.
     */
    data: MenuItemAddOnCreateManyInput | MenuItemAddOnCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemAddOnIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuItemAddOn update
   */
  export type MenuItemAddOnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemAddOn
     */
    select?: MenuItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemAddOn
     */
    omit?: MenuItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemAddOnInclude<ExtArgs> | null
    /**
     * The data needed to update a MenuItemAddOn.
     */
    data: XOR<MenuItemAddOnUpdateInput, MenuItemAddOnUncheckedUpdateInput>
    /**
     * Choose, which MenuItemAddOn to update.
     */
    where: MenuItemAddOnWhereUniqueInput
  }

  /**
   * MenuItemAddOn updateMany
   */
  export type MenuItemAddOnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenuItemAddOns.
     */
    data: XOR<MenuItemAddOnUpdateManyMutationInput, MenuItemAddOnUncheckedUpdateManyInput>
    /**
     * Filter which MenuItemAddOns to update
     */
    where?: MenuItemAddOnWhereInput
    /**
     * Limit how many MenuItemAddOns to update.
     */
    limit?: number
  }

  /**
   * MenuItemAddOn updateManyAndReturn
   */
  export type MenuItemAddOnUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemAddOn
     */
    select?: MenuItemAddOnSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemAddOn
     */
    omit?: MenuItemAddOnOmit<ExtArgs> | null
    /**
     * The data used to update MenuItemAddOns.
     */
    data: XOR<MenuItemAddOnUpdateManyMutationInput, MenuItemAddOnUncheckedUpdateManyInput>
    /**
     * Filter which MenuItemAddOns to update
     */
    where?: MenuItemAddOnWhereInput
    /**
     * Limit how many MenuItemAddOns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemAddOnIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuItemAddOn upsert
   */
  export type MenuItemAddOnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemAddOn
     */
    select?: MenuItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemAddOn
     */
    omit?: MenuItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemAddOnInclude<ExtArgs> | null
    /**
     * The filter to search for the MenuItemAddOn to update in case it exists.
     */
    where: MenuItemAddOnWhereUniqueInput
    /**
     * In case the MenuItemAddOn found by the `where` argument doesn't exist, create a new MenuItemAddOn with this data.
     */
    create: XOR<MenuItemAddOnCreateInput, MenuItemAddOnUncheckedCreateInput>
    /**
     * In case the MenuItemAddOn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuItemAddOnUpdateInput, MenuItemAddOnUncheckedUpdateInput>
  }

  /**
   * MenuItemAddOn delete
   */
  export type MenuItemAddOnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemAddOn
     */
    select?: MenuItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemAddOn
     */
    omit?: MenuItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemAddOnInclude<ExtArgs> | null
    /**
     * Filter which MenuItemAddOn to delete.
     */
    where: MenuItemAddOnWhereUniqueInput
  }

  /**
   * MenuItemAddOn deleteMany
   */
  export type MenuItemAddOnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuItemAddOns to delete
     */
    where?: MenuItemAddOnWhereInput
    /**
     * Limit how many MenuItemAddOns to delete.
     */
    limit?: number
  }

  /**
   * MenuItemAddOn without action
   */
  export type MenuItemAddOnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemAddOn
     */
    select?: MenuItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItemAddOn
     */
    omit?: MenuItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemAddOnInclude<ExtArgs> | null
  }


  /**
   * Model ServiceDay
   */

  export type AggregateServiceDay = {
    _count: ServiceDayCountAggregateOutputType | null
    _avg: ServiceDayAvgAggregateOutputType | null
    _sum: ServiceDaySumAggregateOutputType | null
    _min: ServiceDayMinAggregateOutputType | null
    _max: ServiceDayMaxAggregateOutputType | null
  }

  export type ServiceDayAvgAggregateOutputType = {
    id: number | null
  }

  export type ServiceDaySumAggregateOutputType = {
    id: number | null
  }

  export type ServiceDayMinAggregateOutputType = {
    id: number | null
    menuDate: Date | null
    serviceDate: Date | null
    label: string | null
    isPublished: boolean | null
    isClosed: boolean | null
    closedReason: string | null
    orderingCutoffAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceDayMaxAggregateOutputType = {
    id: number | null
    menuDate: Date | null
    serviceDate: Date | null
    label: string | null
    isPublished: boolean | null
    isClosed: boolean | null
    closedReason: string | null
    orderingCutoffAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceDayCountAggregateOutputType = {
    id: number
    menuDate: number
    serviceDate: number
    label: number
    isPublished: number
    isClosed: number
    closedReason: number
    orderingCutoffAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceDayAvgAggregateInputType = {
    id?: true
  }

  export type ServiceDaySumAggregateInputType = {
    id?: true
  }

  export type ServiceDayMinAggregateInputType = {
    id?: true
    menuDate?: true
    serviceDate?: true
    label?: true
    isPublished?: true
    isClosed?: true
    closedReason?: true
    orderingCutoffAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceDayMaxAggregateInputType = {
    id?: true
    menuDate?: true
    serviceDate?: true
    label?: true
    isPublished?: true
    isClosed?: true
    closedReason?: true
    orderingCutoffAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceDayCountAggregateInputType = {
    id?: true
    menuDate?: true
    serviceDate?: true
    label?: true
    isPublished?: true
    isClosed?: true
    closedReason?: true
    orderingCutoffAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceDayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceDay to aggregate.
     */
    where?: ServiceDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceDays to fetch.
     */
    orderBy?: ServiceDayOrderByWithRelationInput | ServiceDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceDays
    **/
    _count?: true | ServiceDayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceDayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceDaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceDayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceDayMaxAggregateInputType
  }

  export type GetServiceDayAggregateType<T extends ServiceDayAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceDay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceDay[P]>
      : GetScalarType<T[P], AggregateServiceDay[P]>
  }




  export type ServiceDayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceDayWhereInput
    orderBy?: ServiceDayOrderByWithAggregationInput | ServiceDayOrderByWithAggregationInput[]
    by: ServiceDayScalarFieldEnum[] | ServiceDayScalarFieldEnum
    having?: ServiceDayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceDayCountAggregateInputType | true
    _avg?: ServiceDayAvgAggregateInputType
    _sum?: ServiceDaySumAggregateInputType
    _min?: ServiceDayMinAggregateInputType
    _max?: ServiceDayMaxAggregateInputType
  }

  export type ServiceDayGroupByOutputType = {
    id: number
    menuDate: Date
    serviceDate: Date
    label: string | null
    isPublished: boolean
    isClosed: boolean
    closedReason: string | null
    orderingCutoffAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceDayCountAggregateOutputType | null
    _avg: ServiceDayAvgAggregateOutputType | null
    _sum: ServiceDaySumAggregateOutputType | null
    _min: ServiceDayMinAggregateOutputType | null
    _max: ServiceDayMaxAggregateOutputType | null
  }

  type GetServiceDayGroupByPayload<T extends ServiceDayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceDayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceDayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceDayGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceDayGroupByOutputType[P]>
        }
      >
    >


  export type ServiceDaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuDate?: boolean
    serviceDate?: boolean
    label?: boolean
    isPublished?: boolean
    isClosed?: boolean
    closedReason?: boolean
    orderingCutoffAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menus?: boolean | ServiceDay$menusArgs<ExtArgs>
    slots?: boolean | ServiceDay$slotsArgs<ExtArgs>
    groups?: boolean | ServiceDay$groupsArgs<ExtArgs>
    _count?: boolean | ServiceDayCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceDay"]>

  export type ServiceDaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuDate?: boolean
    serviceDate?: boolean
    label?: boolean
    isPublished?: boolean
    isClosed?: boolean
    closedReason?: boolean
    orderingCutoffAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceDay"]>

  export type ServiceDaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuDate?: boolean
    serviceDate?: boolean
    label?: boolean
    isPublished?: boolean
    isClosed?: boolean
    closedReason?: boolean
    orderingCutoffAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceDay"]>

  export type ServiceDaySelectScalar = {
    id?: boolean
    menuDate?: boolean
    serviceDate?: boolean
    label?: boolean
    isPublished?: boolean
    isClosed?: boolean
    closedReason?: boolean
    orderingCutoffAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceDayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "menuDate" | "serviceDate" | "label" | "isPublished" | "isClosed" | "closedReason" | "orderingCutoffAt" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceDay"]>
  export type ServiceDayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menus?: boolean | ServiceDay$menusArgs<ExtArgs>
    slots?: boolean | ServiceDay$slotsArgs<ExtArgs>
    groups?: boolean | ServiceDay$groupsArgs<ExtArgs>
    _count?: boolean | ServiceDayCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceDayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceDayIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceDayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceDay"
    objects: {
      menus: Prisma.$MenuPayload<ExtArgs>[]
      slots: Prisma.$ServiceSlotPayload<ExtArgs>[]
      groups: Prisma.$FulfillmentGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      menuDate: Date
      serviceDate: Date
      label: string | null
      isPublished: boolean
      isClosed: boolean
      closedReason: string | null
      orderingCutoffAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceDay"]>
    composites: {}
  }

  type ServiceDayGetPayload<S extends boolean | null | undefined | ServiceDayDefaultArgs> = $Result.GetResult<Prisma.$ServiceDayPayload, S>

  type ServiceDayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceDayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceDayCountAggregateInputType | true
    }

  export interface ServiceDayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceDay'], meta: { name: 'ServiceDay' } }
    /**
     * Find zero or one ServiceDay that matches the filter.
     * @param {ServiceDayFindUniqueArgs} args - Arguments to find a ServiceDay
     * @example
     * // Get one ServiceDay
     * const serviceDay = await prisma.serviceDay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceDayFindUniqueArgs>(args: SelectSubset<T, ServiceDayFindUniqueArgs<ExtArgs>>): Prisma__ServiceDayClient<$Result.GetResult<Prisma.$ServiceDayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceDay that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceDayFindUniqueOrThrowArgs} args - Arguments to find a ServiceDay
     * @example
     * // Get one ServiceDay
     * const serviceDay = await prisma.serviceDay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceDayFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceDayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceDayClient<$Result.GetResult<Prisma.$ServiceDayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceDay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDayFindFirstArgs} args - Arguments to find a ServiceDay
     * @example
     * // Get one ServiceDay
     * const serviceDay = await prisma.serviceDay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceDayFindFirstArgs>(args?: SelectSubset<T, ServiceDayFindFirstArgs<ExtArgs>>): Prisma__ServiceDayClient<$Result.GetResult<Prisma.$ServiceDayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceDay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDayFindFirstOrThrowArgs} args - Arguments to find a ServiceDay
     * @example
     * // Get one ServiceDay
     * const serviceDay = await prisma.serviceDay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceDayFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceDayFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceDayClient<$Result.GetResult<Prisma.$ServiceDayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceDays
     * const serviceDays = await prisma.serviceDay.findMany()
     * 
     * // Get first 10 ServiceDays
     * const serviceDays = await prisma.serviceDay.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceDayWithIdOnly = await prisma.serviceDay.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceDayFindManyArgs>(args?: SelectSubset<T, ServiceDayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceDay.
     * @param {ServiceDayCreateArgs} args - Arguments to create a ServiceDay.
     * @example
     * // Create one ServiceDay
     * const ServiceDay = await prisma.serviceDay.create({
     *   data: {
     *     // ... data to create a ServiceDay
     *   }
     * })
     * 
     */
    create<T extends ServiceDayCreateArgs>(args: SelectSubset<T, ServiceDayCreateArgs<ExtArgs>>): Prisma__ServiceDayClient<$Result.GetResult<Prisma.$ServiceDayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceDays.
     * @param {ServiceDayCreateManyArgs} args - Arguments to create many ServiceDays.
     * @example
     * // Create many ServiceDays
     * const serviceDay = await prisma.serviceDay.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceDayCreateManyArgs>(args?: SelectSubset<T, ServiceDayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceDays and returns the data saved in the database.
     * @param {ServiceDayCreateManyAndReturnArgs} args - Arguments to create many ServiceDays.
     * @example
     * // Create many ServiceDays
     * const serviceDay = await prisma.serviceDay.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceDays and only return the `id`
     * const serviceDayWithIdOnly = await prisma.serviceDay.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceDayCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceDayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceDayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceDay.
     * @param {ServiceDayDeleteArgs} args - Arguments to delete one ServiceDay.
     * @example
     * // Delete one ServiceDay
     * const ServiceDay = await prisma.serviceDay.delete({
     *   where: {
     *     // ... filter to delete one ServiceDay
     *   }
     * })
     * 
     */
    delete<T extends ServiceDayDeleteArgs>(args: SelectSubset<T, ServiceDayDeleteArgs<ExtArgs>>): Prisma__ServiceDayClient<$Result.GetResult<Prisma.$ServiceDayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceDay.
     * @param {ServiceDayUpdateArgs} args - Arguments to update one ServiceDay.
     * @example
     * // Update one ServiceDay
     * const serviceDay = await prisma.serviceDay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceDayUpdateArgs>(args: SelectSubset<T, ServiceDayUpdateArgs<ExtArgs>>): Prisma__ServiceDayClient<$Result.GetResult<Prisma.$ServiceDayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceDays.
     * @param {ServiceDayDeleteManyArgs} args - Arguments to filter ServiceDays to delete.
     * @example
     * // Delete a few ServiceDays
     * const { count } = await prisma.serviceDay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDayDeleteManyArgs>(args?: SelectSubset<T, ServiceDayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceDays
     * const serviceDay = await prisma.serviceDay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceDayUpdateManyArgs>(args: SelectSubset<T, ServiceDayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceDays and returns the data updated in the database.
     * @param {ServiceDayUpdateManyAndReturnArgs} args - Arguments to update many ServiceDays.
     * @example
     * // Update many ServiceDays
     * const serviceDay = await prisma.serviceDay.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceDays and only return the `id`
     * const serviceDayWithIdOnly = await prisma.serviceDay.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceDayUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceDayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceDayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceDay.
     * @param {ServiceDayUpsertArgs} args - Arguments to update or create a ServiceDay.
     * @example
     * // Update or create a ServiceDay
     * const serviceDay = await prisma.serviceDay.upsert({
     *   create: {
     *     // ... data to create a ServiceDay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceDay we want to update
     *   }
     * })
     */
    upsert<T extends ServiceDayUpsertArgs>(args: SelectSubset<T, ServiceDayUpsertArgs<ExtArgs>>): Prisma__ServiceDayClient<$Result.GetResult<Prisma.$ServiceDayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDayCountArgs} args - Arguments to filter ServiceDays to count.
     * @example
     * // Count the number of ServiceDays
     * const count = await prisma.serviceDay.count({
     *   where: {
     *     // ... the filter for the ServiceDays we want to count
     *   }
     * })
    **/
    count<T extends ServiceDayCountArgs>(
      args?: Subset<T, ServiceDayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceDayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceDayAggregateArgs>(args: Subset<T, ServiceDayAggregateArgs>): Prisma.PrismaPromise<GetServiceDayAggregateType<T>>

    /**
     * Group by ServiceDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceDayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceDayGroupByArgs['orderBy'] }
        : { orderBy?: ServiceDayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceDayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceDayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceDay model
   */
  readonly fields: ServiceDayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceDay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceDayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menus<T extends ServiceDay$menusArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDay$menusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    slots<T extends ServiceDay$slotsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDay$slotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groups<T extends ServiceDay$groupsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDay$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceDay model
   */
  interface ServiceDayFieldRefs {
    readonly id: FieldRef<"ServiceDay", 'Int'>
    readonly menuDate: FieldRef<"ServiceDay", 'DateTime'>
    readonly serviceDate: FieldRef<"ServiceDay", 'DateTime'>
    readonly label: FieldRef<"ServiceDay", 'String'>
    readonly isPublished: FieldRef<"ServiceDay", 'Boolean'>
    readonly isClosed: FieldRef<"ServiceDay", 'Boolean'>
    readonly closedReason: FieldRef<"ServiceDay", 'String'>
    readonly orderingCutoffAt: FieldRef<"ServiceDay", 'DateTime'>
    readonly createdAt: FieldRef<"ServiceDay", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceDay", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceDay findUnique
   */
  export type ServiceDayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDay
     */
    select?: ServiceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDay
     */
    omit?: ServiceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDayInclude<ExtArgs> | null
    /**
     * Filter, which ServiceDay to fetch.
     */
    where: ServiceDayWhereUniqueInput
  }

  /**
   * ServiceDay findUniqueOrThrow
   */
  export type ServiceDayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDay
     */
    select?: ServiceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDay
     */
    omit?: ServiceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDayInclude<ExtArgs> | null
    /**
     * Filter, which ServiceDay to fetch.
     */
    where: ServiceDayWhereUniqueInput
  }

  /**
   * ServiceDay findFirst
   */
  export type ServiceDayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDay
     */
    select?: ServiceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDay
     */
    omit?: ServiceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDayInclude<ExtArgs> | null
    /**
     * Filter, which ServiceDay to fetch.
     */
    where?: ServiceDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceDays to fetch.
     */
    orderBy?: ServiceDayOrderByWithRelationInput | ServiceDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceDays.
     */
    cursor?: ServiceDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceDays.
     */
    distinct?: ServiceDayScalarFieldEnum | ServiceDayScalarFieldEnum[]
  }

  /**
   * ServiceDay findFirstOrThrow
   */
  export type ServiceDayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDay
     */
    select?: ServiceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDay
     */
    omit?: ServiceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDayInclude<ExtArgs> | null
    /**
     * Filter, which ServiceDay to fetch.
     */
    where?: ServiceDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceDays to fetch.
     */
    orderBy?: ServiceDayOrderByWithRelationInput | ServiceDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceDays.
     */
    cursor?: ServiceDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceDays.
     */
    distinct?: ServiceDayScalarFieldEnum | ServiceDayScalarFieldEnum[]
  }

  /**
   * ServiceDay findMany
   */
  export type ServiceDayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDay
     */
    select?: ServiceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDay
     */
    omit?: ServiceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDayInclude<ExtArgs> | null
    /**
     * Filter, which ServiceDays to fetch.
     */
    where?: ServiceDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceDays to fetch.
     */
    orderBy?: ServiceDayOrderByWithRelationInput | ServiceDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceDays.
     */
    cursor?: ServiceDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceDays.
     */
    skip?: number
    distinct?: ServiceDayScalarFieldEnum | ServiceDayScalarFieldEnum[]
  }

  /**
   * ServiceDay create
   */
  export type ServiceDayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDay
     */
    select?: ServiceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDay
     */
    omit?: ServiceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDayInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceDay.
     */
    data: XOR<ServiceDayCreateInput, ServiceDayUncheckedCreateInput>
  }

  /**
   * ServiceDay createMany
   */
  export type ServiceDayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceDays.
     */
    data: ServiceDayCreateManyInput | ServiceDayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceDay createManyAndReturn
   */
  export type ServiceDayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDay
     */
    select?: ServiceDaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDay
     */
    omit?: ServiceDayOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceDays.
     */
    data: ServiceDayCreateManyInput | ServiceDayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceDay update
   */
  export type ServiceDayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDay
     */
    select?: ServiceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDay
     */
    omit?: ServiceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDayInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceDay.
     */
    data: XOR<ServiceDayUpdateInput, ServiceDayUncheckedUpdateInput>
    /**
     * Choose, which ServiceDay to update.
     */
    where: ServiceDayWhereUniqueInput
  }

  /**
   * ServiceDay updateMany
   */
  export type ServiceDayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceDays.
     */
    data: XOR<ServiceDayUpdateManyMutationInput, ServiceDayUncheckedUpdateManyInput>
    /**
     * Filter which ServiceDays to update
     */
    where?: ServiceDayWhereInput
    /**
     * Limit how many ServiceDays to update.
     */
    limit?: number
  }

  /**
   * ServiceDay updateManyAndReturn
   */
  export type ServiceDayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDay
     */
    select?: ServiceDaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDay
     */
    omit?: ServiceDayOmit<ExtArgs> | null
    /**
     * The data used to update ServiceDays.
     */
    data: XOR<ServiceDayUpdateManyMutationInput, ServiceDayUncheckedUpdateManyInput>
    /**
     * Filter which ServiceDays to update
     */
    where?: ServiceDayWhereInput
    /**
     * Limit how many ServiceDays to update.
     */
    limit?: number
  }

  /**
   * ServiceDay upsert
   */
  export type ServiceDayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDay
     */
    select?: ServiceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDay
     */
    omit?: ServiceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDayInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceDay to update in case it exists.
     */
    where: ServiceDayWhereUniqueInput
    /**
     * In case the ServiceDay found by the `where` argument doesn't exist, create a new ServiceDay with this data.
     */
    create: XOR<ServiceDayCreateInput, ServiceDayUncheckedCreateInput>
    /**
     * In case the ServiceDay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceDayUpdateInput, ServiceDayUncheckedUpdateInput>
  }

  /**
   * ServiceDay delete
   */
  export type ServiceDayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDay
     */
    select?: ServiceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDay
     */
    omit?: ServiceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDayInclude<ExtArgs> | null
    /**
     * Filter which ServiceDay to delete.
     */
    where: ServiceDayWhereUniqueInput
  }

  /**
   * ServiceDay deleteMany
   */
  export type ServiceDayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceDays to delete
     */
    where?: ServiceDayWhereInput
    /**
     * Limit how many ServiceDays to delete.
     */
    limit?: number
  }

  /**
   * ServiceDay.menus
   */
  export type ServiceDay$menusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    cursor?: MenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * ServiceDay.slots
   */
  export type ServiceDay$slotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlot
     */
    select?: ServiceSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSlot
     */
    omit?: ServiceSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSlotInclude<ExtArgs> | null
    where?: ServiceSlotWhereInput
    orderBy?: ServiceSlotOrderByWithRelationInput | ServiceSlotOrderByWithRelationInput[]
    cursor?: ServiceSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceSlotScalarFieldEnum | ServiceSlotScalarFieldEnum[]
  }

  /**
   * ServiceDay.groups
   */
  export type ServiceDay$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupInclude<ExtArgs> | null
    where?: FulfillmentGroupWhereInput
    orderBy?: FulfillmentGroupOrderByWithRelationInput | FulfillmentGroupOrderByWithRelationInput[]
    cursor?: FulfillmentGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FulfillmentGroupScalarFieldEnum | FulfillmentGroupScalarFieldEnum[]
  }

  /**
   * ServiceDay without action
   */
  export type ServiceDayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDay
     */
    select?: ServiceDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDay
     */
    omit?: ServiceDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDayInclude<ExtArgs> | null
  }


  /**
   * Model Menu
   */

  export type AggregateMenu = {
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  export type MenuAvgAggregateOutputType = {
    id: number | null
    serviceDayId: number | null
    displayOrder: number | null
  }

  export type MenuSumAggregateOutputType = {
    id: number | null
    serviceDayId: number | null
    displayOrder: number | null
  }

  export type MenuMinAggregateOutputType = {
    id: number | null
    serviceDayId: number | null
    menuType: $Enums.MenuType | null
    title: string | null
    isPublished: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuMaxAggregateOutputType = {
    id: number | null
    serviceDayId: number | null
    menuType: $Enums.MenuType | null
    title: string | null
    isPublished: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuCountAggregateOutputType = {
    id: number
    serviceDayId: number
    menuType: number
    title: number
    isPublished: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenuAvgAggregateInputType = {
    id?: true
    serviceDayId?: true
    displayOrder?: true
  }

  export type MenuSumAggregateInputType = {
    id?: true
    serviceDayId?: true
    displayOrder?: true
  }

  export type MenuMinAggregateInputType = {
    id?: true
    serviceDayId?: true
    menuType?: true
    title?: true
    isPublished?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuMaxAggregateInputType = {
    id?: true
    serviceDayId?: true
    menuType?: true
    title?: true
    isPublished?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuCountAggregateInputType = {
    id?: true
    serviceDayId?: true
    menuType?: true
    title?: true
    isPublished?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Menu to aggregate.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Menus
    **/
    _count?: true | MenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuMaxAggregateInputType
  }

  export type GetMenuAggregateType<T extends MenuAggregateArgs> = {
        [P in keyof T & keyof AggregateMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu[P]>
      : GetScalarType<T[P], AggregateMenu[P]>
  }




  export type MenuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithAggregationInput | MenuOrderByWithAggregationInput[]
    by: MenuScalarFieldEnum[] | MenuScalarFieldEnum
    having?: MenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuCountAggregateInputType | true
    _avg?: MenuAvgAggregateInputType
    _sum?: MenuSumAggregateInputType
    _min?: MenuMinAggregateInputType
    _max?: MenuMaxAggregateInputType
  }

  export type MenuGroupByOutputType = {
    id: number
    serviceDayId: number
    menuType: $Enums.MenuType
    title: string | null
    isPublished: boolean
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  type GetMenuGroupByPayload<T extends MenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuGroupByOutputType[P]>
            : GetScalarType<T[P], MenuGroupByOutputType[P]>
        }
      >
    >


  export type MenuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceDayId?: boolean
    menuType?: boolean
    title?: boolean
    isPublished?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
    offerings?: boolean | Menu$offeringsArgs<ExtArgs>
    _count?: boolean | MenuCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceDayId?: boolean
    menuType?: boolean
    title?: boolean
    isPublished?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceDayId?: boolean
    menuType?: boolean
    title?: boolean
    isPublished?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectScalar = {
    id?: boolean
    serviceDayId?: boolean
    menuType?: boolean
    title?: boolean
    isPublished?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MenuOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceDayId" | "menuType" | "title" | "isPublished" | "displayOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["menu"]>
  export type MenuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
    offerings?: boolean | Menu$offeringsArgs<ExtArgs>
    _count?: boolean | MenuCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MenuIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
  }
  export type MenuIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
  }

  export type $MenuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Menu"
    objects: {
      serviceDay: Prisma.$ServiceDayPayload<ExtArgs>
      offerings: Prisma.$MenuOfferingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serviceDayId: number
      menuType: $Enums.MenuType
      title: string | null
      isPublished: boolean
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["menu"]>
    composites: {}
  }

  type MenuGetPayload<S extends boolean | null | undefined | MenuDefaultArgs> = $Result.GetResult<Prisma.$MenuPayload, S>

  type MenuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenuFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenuCountAggregateInputType | true
    }

  export interface MenuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Menu'], meta: { name: 'Menu' } }
    /**
     * Find zero or one Menu that matches the filter.
     * @param {MenuFindUniqueArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuFindUniqueArgs>(args: SelectSubset<T, MenuFindUniqueArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Menu that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenuFindUniqueOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuFindFirstArgs>(args?: SelectSubset<T, MenuFindFirstArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menus
     * const menus = await prisma.menu.findMany()
     * 
     * // Get first 10 Menus
     * const menus = await prisma.menu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuWithIdOnly = await prisma.menu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuFindManyArgs>(args?: SelectSubset<T, MenuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Menu.
     * @param {MenuCreateArgs} args - Arguments to create a Menu.
     * @example
     * // Create one Menu
     * const Menu = await prisma.menu.create({
     *   data: {
     *     // ... data to create a Menu
     *   }
     * })
     * 
     */
    create<T extends MenuCreateArgs>(args: SelectSubset<T, MenuCreateArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Menus.
     * @param {MenuCreateManyArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuCreateManyArgs>(args?: SelectSubset<T, MenuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Menus and returns the data saved in the database.
     * @param {MenuCreateManyAndReturnArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Menus and only return the `id`
     * const menuWithIdOnly = await prisma.menu.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Menu.
     * @param {MenuDeleteArgs} args - Arguments to delete one Menu.
     * @example
     * // Delete one Menu
     * const Menu = await prisma.menu.delete({
     *   where: {
     *     // ... filter to delete one Menu
     *   }
     * })
     * 
     */
    delete<T extends MenuDeleteArgs>(args: SelectSubset<T, MenuDeleteArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Menu.
     * @param {MenuUpdateArgs} args - Arguments to update one Menu.
     * @example
     * // Update one Menu
     * const menu = await prisma.menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuUpdateArgs>(args: SelectSubset<T, MenuUpdateArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Menus.
     * @param {MenuDeleteManyArgs} args - Arguments to filter Menus to delete.
     * @example
     * // Delete a few Menus
     * const { count } = await prisma.menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuDeleteManyArgs>(args?: SelectSubset<T, MenuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuUpdateManyArgs>(args: SelectSubset<T, MenuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus and returns the data updated in the database.
     * @param {MenuUpdateManyAndReturnArgs} args - Arguments to update many Menus.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Menus and only return the `id`
     * const menuWithIdOnly = await prisma.menu.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenuUpdateManyAndReturnArgs>(args: SelectSubset<T, MenuUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Menu.
     * @param {MenuUpsertArgs} args - Arguments to update or create a Menu.
     * @example
     * // Update or create a Menu
     * const menu = await prisma.menu.upsert({
     *   create: {
     *     // ... data to create a Menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu we want to update
     *   }
     * })
     */
    upsert<T extends MenuUpsertArgs>(args: SelectSubset<T, MenuUpsertArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuCountArgs} args - Arguments to filter Menus to count.
     * @example
     * // Count the number of Menus
     * const count = await prisma.menu.count({
     *   where: {
     *     // ... the filter for the Menus we want to count
     *   }
     * })
    **/
    count<T extends MenuCountArgs>(
      args?: Subset<T, MenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuAggregateArgs>(args: Subset<T, MenuAggregateArgs>): Prisma.PrismaPromise<GetMenuAggregateType<T>>

    /**
     * Group by Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuGroupByArgs['orderBy'] }
        : { orderBy?: MenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Menu model
   */
  readonly fields: MenuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceDay<T extends ServiceDayDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDayDefaultArgs<ExtArgs>>): Prisma__ServiceDayClient<$Result.GetResult<Prisma.$ServiceDayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offerings<T extends Menu$offeringsArgs<ExtArgs> = {}>(args?: Subset<T, Menu$offeringsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Menu model
   */
  interface MenuFieldRefs {
    readonly id: FieldRef<"Menu", 'Int'>
    readonly serviceDayId: FieldRef<"Menu", 'Int'>
    readonly menuType: FieldRef<"Menu", 'MenuType'>
    readonly title: FieldRef<"Menu", 'String'>
    readonly isPublished: FieldRef<"Menu", 'Boolean'>
    readonly displayOrder: FieldRef<"Menu", 'Int'>
    readonly createdAt: FieldRef<"Menu", 'DateTime'>
    readonly updatedAt: FieldRef<"Menu", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Menu findUnique
   */
  export type MenuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu findUniqueOrThrow
   */
  export type MenuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu findFirst
   */
  export type MenuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu findFirstOrThrow
   */
  export type MenuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu findMany
   */
  export type MenuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menus to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu create
   */
  export type MenuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The data needed to create a Menu.
     */
    data: XOR<MenuCreateInput, MenuUncheckedCreateInput>
  }

  /**
   * Menu createMany
   */
  export type MenuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Menu createManyAndReturn
   */
  export type MenuCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Menu update
   */
  export type MenuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The data needed to update a Menu.
     */
    data: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
    /**
     * Choose, which Menu to update.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu updateMany
   */
  export type MenuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to update.
     */
    limit?: number
  }

  /**
   * Menu updateManyAndReturn
   */
  export type MenuUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Menu upsert
   */
  export type MenuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The filter to search for the Menu to update in case it exists.
     */
    where: MenuWhereUniqueInput
    /**
     * In case the Menu found by the `where` argument doesn't exist, create a new Menu with this data.
     */
    create: XOR<MenuCreateInput, MenuUncheckedCreateInput>
    /**
     * In case the Menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
  }

  /**
   * Menu delete
   */
  export type MenuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter which Menu to delete.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu deleteMany
   */
  export type MenuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Menus to delete
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to delete.
     */
    limit?: number
  }

  /**
   * Menu.offerings
   */
  export type Menu$offeringsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuOffering
     */
    select?: MenuOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuOffering
     */
    omit?: MenuOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuOfferingInclude<ExtArgs> | null
    where?: MenuOfferingWhereInput
    orderBy?: MenuOfferingOrderByWithRelationInput | MenuOfferingOrderByWithRelationInput[]
    cursor?: MenuOfferingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuOfferingScalarFieldEnum | MenuOfferingScalarFieldEnum[]
  }

  /**
   * Menu without action
   */
  export type MenuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
  }


  /**
   * Model MenuOffering
   */

  export type AggregateMenuOffering = {
    _count: MenuOfferingCountAggregateOutputType | null
    _avg: MenuOfferingAvgAggregateOutputType | null
    _sum: MenuOfferingSumAggregateOutputType | null
    _min: MenuOfferingMinAggregateOutputType | null
    _max: MenuOfferingMaxAggregateOutputType | null
  }

  export type MenuOfferingAvgAggregateOutputType = {
    id: number | null
    menuId: number | null
    menuVariantId: number | null
    priceOverrideCents: number | null
    capacityOverride: number | null
    maxPerOrder: number | null
    position: number | null
  }

  export type MenuOfferingSumAggregateOutputType = {
    id: number | null
    menuId: number | null
    menuVariantId: number | null
    priceOverrideCents: number | null
    capacityOverride: number | null
    maxPerOrder: number | null
    position: number | null
  }

  export type MenuOfferingMinAggregateOutputType = {
    id: number | null
    menuId: number | null
    menuVariantId: number | null
    priceOverrideCents: number | null
    capacityOverride: number | null
    isAvailable: boolean | null
    maxPerOrder: number | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuOfferingMaxAggregateOutputType = {
    id: number | null
    menuId: number | null
    menuVariantId: number | null
    priceOverrideCents: number | null
    capacityOverride: number | null
    isAvailable: boolean | null
    maxPerOrder: number | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuOfferingCountAggregateOutputType = {
    id: number
    menuId: number
    menuVariantId: number
    priceOverrideCents: number
    capacityOverride: number
    isAvailable: number
    maxPerOrder: number
    position: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenuOfferingAvgAggregateInputType = {
    id?: true
    menuId?: true
    menuVariantId?: true
    priceOverrideCents?: true
    capacityOverride?: true
    maxPerOrder?: true
    position?: true
  }

  export type MenuOfferingSumAggregateInputType = {
    id?: true
    menuId?: true
    menuVariantId?: true
    priceOverrideCents?: true
    capacityOverride?: true
    maxPerOrder?: true
    position?: true
  }

  export type MenuOfferingMinAggregateInputType = {
    id?: true
    menuId?: true
    menuVariantId?: true
    priceOverrideCents?: true
    capacityOverride?: true
    isAvailable?: true
    maxPerOrder?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuOfferingMaxAggregateInputType = {
    id?: true
    menuId?: true
    menuVariantId?: true
    priceOverrideCents?: true
    capacityOverride?: true
    isAvailable?: true
    maxPerOrder?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuOfferingCountAggregateInputType = {
    id?: true
    menuId?: true
    menuVariantId?: true
    priceOverrideCents?: true
    capacityOverride?: true
    isAvailable?: true
    maxPerOrder?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuOfferingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuOffering to aggregate.
     */
    where?: MenuOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuOfferings to fetch.
     */
    orderBy?: MenuOfferingOrderByWithRelationInput | MenuOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuOfferings
    **/
    _count?: true | MenuOfferingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuOfferingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuOfferingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuOfferingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuOfferingMaxAggregateInputType
  }

  export type GetMenuOfferingAggregateType<T extends MenuOfferingAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuOffering]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuOffering[P]>
      : GetScalarType<T[P], AggregateMenuOffering[P]>
  }




  export type MenuOfferingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuOfferingWhereInput
    orderBy?: MenuOfferingOrderByWithAggregationInput | MenuOfferingOrderByWithAggregationInput[]
    by: MenuOfferingScalarFieldEnum[] | MenuOfferingScalarFieldEnum
    having?: MenuOfferingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuOfferingCountAggregateInputType | true
    _avg?: MenuOfferingAvgAggregateInputType
    _sum?: MenuOfferingSumAggregateInputType
    _min?: MenuOfferingMinAggregateInputType
    _max?: MenuOfferingMaxAggregateInputType
  }

  export type MenuOfferingGroupByOutputType = {
    id: number
    menuId: number
    menuVariantId: number
    priceOverrideCents: number | null
    capacityOverride: number | null
    isAvailable: boolean
    maxPerOrder: number | null
    position: number
    createdAt: Date
    updatedAt: Date
    _count: MenuOfferingCountAggregateOutputType | null
    _avg: MenuOfferingAvgAggregateOutputType | null
    _sum: MenuOfferingSumAggregateOutputType | null
    _min: MenuOfferingMinAggregateOutputType | null
    _max: MenuOfferingMaxAggregateOutputType | null
  }

  type GetMenuOfferingGroupByPayload<T extends MenuOfferingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuOfferingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuOfferingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuOfferingGroupByOutputType[P]>
            : GetScalarType<T[P], MenuOfferingGroupByOutputType[P]>
        }
      >
    >


  export type MenuOfferingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuId?: boolean
    menuVariantId?: boolean
    priceOverrideCents?: boolean
    capacityOverride?: boolean
    isAvailable?: boolean
    maxPerOrder?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    variant?: boolean | MenuVariantDefaultArgs<ExtArgs>
    holds?: boolean | MenuOffering$holdsArgs<ExtArgs>
    _count?: boolean | MenuOfferingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuOffering"]>

  export type MenuOfferingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuId?: boolean
    menuVariantId?: boolean
    priceOverrideCents?: boolean
    capacityOverride?: boolean
    isAvailable?: boolean
    maxPerOrder?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    variant?: boolean | MenuVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuOffering"]>

  export type MenuOfferingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuId?: boolean
    menuVariantId?: boolean
    priceOverrideCents?: boolean
    capacityOverride?: boolean
    isAvailable?: boolean
    maxPerOrder?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    variant?: boolean | MenuVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuOffering"]>

  export type MenuOfferingSelectScalar = {
    id?: boolean
    menuId?: boolean
    menuVariantId?: boolean
    priceOverrideCents?: boolean
    capacityOverride?: boolean
    isAvailable?: boolean
    maxPerOrder?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MenuOfferingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "menuId" | "menuVariantId" | "priceOverrideCents" | "capacityOverride" | "isAvailable" | "maxPerOrder" | "position" | "createdAt" | "updatedAt", ExtArgs["result"]["menuOffering"]>
  export type MenuOfferingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    variant?: boolean | MenuVariantDefaultArgs<ExtArgs>
    holds?: boolean | MenuOffering$holdsArgs<ExtArgs>
    _count?: boolean | MenuOfferingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MenuOfferingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    variant?: boolean | MenuVariantDefaultArgs<ExtArgs>
  }
  export type MenuOfferingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    variant?: boolean | MenuVariantDefaultArgs<ExtArgs>
  }

  export type $MenuOfferingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenuOffering"
    objects: {
      menu: Prisma.$MenuPayload<ExtArgs>
      variant: Prisma.$MenuVariantPayload<ExtArgs>
      holds: Prisma.$CapacityHoldPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      menuId: number
      menuVariantId: number
      priceOverrideCents: number | null
      capacityOverride: number | null
      isAvailable: boolean
      maxPerOrder: number | null
      position: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["menuOffering"]>
    composites: {}
  }

  type MenuOfferingGetPayload<S extends boolean | null | undefined | MenuOfferingDefaultArgs> = $Result.GetResult<Prisma.$MenuOfferingPayload, S>

  type MenuOfferingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenuOfferingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenuOfferingCountAggregateInputType | true
    }

  export interface MenuOfferingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenuOffering'], meta: { name: 'MenuOffering' } }
    /**
     * Find zero or one MenuOffering that matches the filter.
     * @param {MenuOfferingFindUniqueArgs} args - Arguments to find a MenuOffering
     * @example
     * // Get one MenuOffering
     * const menuOffering = await prisma.menuOffering.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuOfferingFindUniqueArgs>(args: SelectSubset<T, MenuOfferingFindUniqueArgs<ExtArgs>>): Prisma__MenuOfferingClient<$Result.GetResult<Prisma.$MenuOfferingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MenuOffering that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenuOfferingFindUniqueOrThrowArgs} args - Arguments to find a MenuOffering
     * @example
     * // Get one MenuOffering
     * const menuOffering = await prisma.menuOffering.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuOfferingFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuOfferingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuOfferingClient<$Result.GetResult<Prisma.$MenuOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenuOffering that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuOfferingFindFirstArgs} args - Arguments to find a MenuOffering
     * @example
     * // Get one MenuOffering
     * const menuOffering = await prisma.menuOffering.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuOfferingFindFirstArgs>(args?: SelectSubset<T, MenuOfferingFindFirstArgs<ExtArgs>>): Prisma__MenuOfferingClient<$Result.GetResult<Prisma.$MenuOfferingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenuOffering that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuOfferingFindFirstOrThrowArgs} args - Arguments to find a MenuOffering
     * @example
     * // Get one MenuOffering
     * const menuOffering = await prisma.menuOffering.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuOfferingFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuOfferingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuOfferingClient<$Result.GetResult<Prisma.$MenuOfferingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MenuOfferings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuOfferingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuOfferings
     * const menuOfferings = await prisma.menuOffering.findMany()
     * 
     * // Get first 10 MenuOfferings
     * const menuOfferings = await prisma.menuOffering.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuOfferingWithIdOnly = await prisma.menuOffering.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuOfferingFindManyArgs>(args?: SelectSubset<T, MenuOfferingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MenuOffering.
     * @param {MenuOfferingCreateArgs} args - Arguments to create a MenuOffering.
     * @example
     * // Create one MenuOffering
     * const MenuOffering = await prisma.menuOffering.create({
     *   data: {
     *     // ... data to create a MenuOffering
     *   }
     * })
     * 
     */
    create<T extends MenuOfferingCreateArgs>(args: SelectSubset<T, MenuOfferingCreateArgs<ExtArgs>>): Prisma__MenuOfferingClient<$Result.GetResult<Prisma.$MenuOfferingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MenuOfferings.
     * @param {MenuOfferingCreateManyArgs} args - Arguments to create many MenuOfferings.
     * @example
     * // Create many MenuOfferings
     * const menuOffering = await prisma.menuOffering.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuOfferingCreateManyArgs>(args?: SelectSubset<T, MenuOfferingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenuOfferings and returns the data saved in the database.
     * @param {MenuOfferingCreateManyAndReturnArgs} args - Arguments to create many MenuOfferings.
     * @example
     * // Create many MenuOfferings
     * const menuOffering = await prisma.menuOffering.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenuOfferings and only return the `id`
     * const menuOfferingWithIdOnly = await prisma.menuOffering.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuOfferingCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuOfferingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuOfferingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MenuOffering.
     * @param {MenuOfferingDeleteArgs} args - Arguments to delete one MenuOffering.
     * @example
     * // Delete one MenuOffering
     * const MenuOffering = await prisma.menuOffering.delete({
     *   where: {
     *     // ... filter to delete one MenuOffering
     *   }
     * })
     * 
     */
    delete<T extends MenuOfferingDeleteArgs>(args: SelectSubset<T, MenuOfferingDeleteArgs<ExtArgs>>): Prisma__MenuOfferingClient<$Result.GetResult<Prisma.$MenuOfferingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MenuOffering.
     * @param {MenuOfferingUpdateArgs} args - Arguments to update one MenuOffering.
     * @example
     * // Update one MenuOffering
     * const menuOffering = await prisma.menuOffering.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuOfferingUpdateArgs>(args: SelectSubset<T, MenuOfferingUpdateArgs<ExtArgs>>): Prisma__MenuOfferingClient<$Result.GetResult<Prisma.$MenuOfferingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MenuOfferings.
     * @param {MenuOfferingDeleteManyArgs} args - Arguments to filter MenuOfferings to delete.
     * @example
     * // Delete a few MenuOfferings
     * const { count } = await prisma.menuOffering.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuOfferingDeleteManyArgs>(args?: SelectSubset<T, MenuOfferingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuOfferings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuOfferingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuOfferings
     * const menuOffering = await prisma.menuOffering.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuOfferingUpdateManyArgs>(args: SelectSubset<T, MenuOfferingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuOfferings and returns the data updated in the database.
     * @param {MenuOfferingUpdateManyAndReturnArgs} args - Arguments to update many MenuOfferings.
     * @example
     * // Update many MenuOfferings
     * const menuOffering = await prisma.menuOffering.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MenuOfferings and only return the `id`
     * const menuOfferingWithIdOnly = await prisma.menuOffering.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenuOfferingUpdateManyAndReturnArgs>(args: SelectSubset<T, MenuOfferingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuOfferingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MenuOffering.
     * @param {MenuOfferingUpsertArgs} args - Arguments to update or create a MenuOffering.
     * @example
     * // Update or create a MenuOffering
     * const menuOffering = await prisma.menuOffering.upsert({
     *   create: {
     *     // ... data to create a MenuOffering
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuOffering we want to update
     *   }
     * })
     */
    upsert<T extends MenuOfferingUpsertArgs>(args: SelectSubset<T, MenuOfferingUpsertArgs<ExtArgs>>): Prisma__MenuOfferingClient<$Result.GetResult<Prisma.$MenuOfferingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MenuOfferings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuOfferingCountArgs} args - Arguments to filter MenuOfferings to count.
     * @example
     * // Count the number of MenuOfferings
     * const count = await prisma.menuOffering.count({
     *   where: {
     *     // ... the filter for the MenuOfferings we want to count
     *   }
     * })
    **/
    count<T extends MenuOfferingCountArgs>(
      args?: Subset<T, MenuOfferingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuOfferingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuOffering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuOfferingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuOfferingAggregateArgs>(args: Subset<T, MenuOfferingAggregateArgs>): Prisma.PrismaPromise<GetMenuOfferingAggregateType<T>>

    /**
     * Group by MenuOffering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuOfferingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuOfferingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuOfferingGroupByArgs['orderBy'] }
        : { orderBy?: MenuOfferingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuOfferingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuOfferingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenuOffering model
   */
  readonly fields: MenuOfferingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuOffering.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuOfferingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menu<T extends MenuDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuDefaultArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    variant<T extends MenuVariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuVariantDefaultArgs<ExtArgs>>): Prisma__MenuVariantClient<$Result.GetResult<Prisma.$MenuVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    holds<T extends MenuOffering$holdsArgs<ExtArgs> = {}>(args?: Subset<T, MenuOffering$holdsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapacityHoldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenuOffering model
   */
  interface MenuOfferingFieldRefs {
    readonly id: FieldRef<"MenuOffering", 'Int'>
    readonly menuId: FieldRef<"MenuOffering", 'Int'>
    readonly menuVariantId: FieldRef<"MenuOffering", 'Int'>
    readonly priceOverrideCents: FieldRef<"MenuOffering", 'Int'>
    readonly capacityOverride: FieldRef<"MenuOffering", 'Int'>
    readonly isAvailable: FieldRef<"MenuOffering", 'Boolean'>
    readonly maxPerOrder: FieldRef<"MenuOffering", 'Int'>
    readonly position: FieldRef<"MenuOffering", 'Int'>
    readonly createdAt: FieldRef<"MenuOffering", 'DateTime'>
    readonly updatedAt: FieldRef<"MenuOffering", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MenuOffering findUnique
   */
  export type MenuOfferingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuOffering
     */
    select?: MenuOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuOffering
     */
    omit?: MenuOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuOfferingInclude<ExtArgs> | null
    /**
     * Filter, which MenuOffering to fetch.
     */
    where: MenuOfferingWhereUniqueInput
  }

  /**
   * MenuOffering findUniqueOrThrow
   */
  export type MenuOfferingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuOffering
     */
    select?: MenuOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuOffering
     */
    omit?: MenuOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuOfferingInclude<ExtArgs> | null
    /**
     * Filter, which MenuOffering to fetch.
     */
    where: MenuOfferingWhereUniqueInput
  }

  /**
   * MenuOffering findFirst
   */
  export type MenuOfferingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuOffering
     */
    select?: MenuOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuOffering
     */
    omit?: MenuOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuOfferingInclude<ExtArgs> | null
    /**
     * Filter, which MenuOffering to fetch.
     */
    where?: MenuOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuOfferings to fetch.
     */
    orderBy?: MenuOfferingOrderByWithRelationInput | MenuOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuOfferings.
     */
    cursor?: MenuOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuOfferings.
     */
    distinct?: MenuOfferingScalarFieldEnum | MenuOfferingScalarFieldEnum[]
  }

  /**
   * MenuOffering findFirstOrThrow
   */
  export type MenuOfferingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuOffering
     */
    select?: MenuOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuOffering
     */
    omit?: MenuOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuOfferingInclude<ExtArgs> | null
    /**
     * Filter, which MenuOffering to fetch.
     */
    where?: MenuOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuOfferings to fetch.
     */
    orderBy?: MenuOfferingOrderByWithRelationInput | MenuOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuOfferings.
     */
    cursor?: MenuOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuOfferings.
     */
    distinct?: MenuOfferingScalarFieldEnum | MenuOfferingScalarFieldEnum[]
  }

  /**
   * MenuOffering findMany
   */
  export type MenuOfferingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuOffering
     */
    select?: MenuOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuOffering
     */
    omit?: MenuOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuOfferingInclude<ExtArgs> | null
    /**
     * Filter, which MenuOfferings to fetch.
     */
    where?: MenuOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuOfferings to fetch.
     */
    orderBy?: MenuOfferingOrderByWithRelationInput | MenuOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuOfferings.
     */
    cursor?: MenuOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuOfferings.
     */
    skip?: number
    distinct?: MenuOfferingScalarFieldEnum | MenuOfferingScalarFieldEnum[]
  }

  /**
   * MenuOffering create
   */
  export type MenuOfferingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuOffering
     */
    select?: MenuOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuOffering
     */
    omit?: MenuOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuOfferingInclude<ExtArgs> | null
    /**
     * The data needed to create a MenuOffering.
     */
    data: XOR<MenuOfferingCreateInput, MenuOfferingUncheckedCreateInput>
  }

  /**
   * MenuOffering createMany
   */
  export type MenuOfferingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenuOfferings.
     */
    data: MenuOfferingCreateManyInput | MenuOfferingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenuOffering createManyAndReturn
   */
  export type MenuOfferingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuOffering
     */
    select?: MenuOfferingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenuOffering
     */
    omit?: MenuOfferingOmit<ExtArgs> | null
    /**
     * The data used to create many MenuOfferings.
     */
    data: MenuOfferingCreateManyInput | MenuOfferingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuOfferingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuOffering update
   */
  export type MenuOfferingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuOffering
     */
    select?: MenuOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuOffering
     */
    omit?: MenuOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuOfferingInclude<ExtArgs> | null
    /**
     * The data needed to update a MenuOffering.
     */
    data: XOR<MenuOfferingUpdateInput, MenuOfferingUncheckedUpdateInput>
    /**
     * Choose, which MenuOffering to update.
     */
    where: MenuOfferingWhereUniqueInput
  }

  /**
   * MenuOffering updateMany
   */
  export type MenuOfferingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenuOfferings.
     */
    data: XOR<MenuOfferingUpdateManyMutationInput, MenuOfferingUncheckedUpdateManyInput>
    /**
     * Filter which MenuOfferings to update
     */
    where?: MenuOfferingWhereInput
    /**
     * Limit how many MenuOfferings to update.
     */
    limit?: number
  }

  /**
   * MenuOffering updateManyAndReturn
   */
  export type MenuOfferingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuOffering
     */
    select?: MenuOfferingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenuOffering
     */
    omit?: MenuOfferingOmit<ExtArgs> | null
    /**
     * The data used to update MenuOfferings.
     */
    data: XOR<MenuOfferingUpdateManyMutationInput, MenuOfferingUncheckedUpdateManyInput>
    /**
     * Filter which MenuOfferings to update
     */
    where?: MenuOfferingWhereInput
    /**
     * Limit how many MenuOfferings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuOfferingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuOffering upsert
   */
  export type MenuOfferingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuOffering
     */
    select?: MenuOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuOffering
     */
    omit?: MenuOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuOfferingInclude<ExtArgs> | null
    /**
     * The filter to search for the MenuOffering to update in case it exists.
     */
    where: MenuOfferingWhereUniqueInput
    /**
     * In case the MenuOffering found by the `where` argument doesn't exist, create a new MenuOffering with this data.
     */
    create: XOR<MenuOfferingCreateInput, MenuOfferingUncheckedCreateInput>
    /**
     * In case the MenuOffering was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuOfferingUpdateInput, MenuOfferingUncheckedUpdateInput>
  }

  /**
   * MenuOffering delete
   */
  export type MenuOfferingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuOffering
     */
    select?: MenuOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuOffering
     */
    omit?: MenuOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuOfferingInclude<ExtArgs> | null
    /**
     * Filter which MenuOffering to delete.
     */
    where: MenuOfferingWhereUniqueInput
  }

  /**
   * MenuOffering deleteMany
   */
  export type MenuOfferingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuOfferings to delete
     */
    where?: MenuOfferingWhereInput
    /**
     * Limit how many MenuOfferings to delete.
     */
    limit?: number
  }

  /**
   * MenuOffering.holds
   */
  export type MenuOffering$holdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapacityHold
     */
    select?: CapacityHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapacityHold
     */
    omit?: CapacityHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapacityHoldInclude<ExtArgs> | null
    where?: CapacityHoldWhereInput
    orderBy?: CapacityHoldOrderByWithRelationInput | CapacityHoldOrderByWithRelationInput[]
    cursor?: CapacityHoldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CapacityHoldScalarFieldEnum | CapacityHoldScalarFieldEnum[]
  }

  /**
   * MenuOffering without action
   */
  export type MenuOfferingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuOffering
     */
    select?: MenuOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuOffering
     */
    omit?: MenuOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuOfferingInclude<ExtArgs> | null
  }


  /**
   * Model PickupLocation
   */

  export type AggregatePickupLocation = {
    _count: PickupLocationCountAggregateOutputType | null
    _avg: PickupLocationAvgAggregateOutputType | null
    _sum: PickupLocationSumAggregateOutputType | null
    _min: PickupLocationMinAggregateOutputType | null
    _max: PickupLocationMaxAggregateOutputType | null
  }

  export type PickupLocationAvgAggregateOutputType = {
    id: number | null
  }

  export type PickupLocationSumAggregateOutputType = {
    id: number | null
  }

  export type PickupLocationMinAggregateOutputType = {
    id: number | null
    name: string | null
    line1: string | null
    line2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    timezone: string | null
    instructions: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PickupLocationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    line1: string | null
    line2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    timezone: string | null
    instructions: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PickupLocationCountAggregateOutputType = {
    id: number
    name: number
    line1: number
    line2: number
    city: number
    state: number
    postalCode: number
    country: number
    timezone: number
    instructions: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PickupLocationAvgAggregateInputType = {
    id?: true
  }

  export type PickupLocationSumAggregateInputType = {
    id?: true
  }

  export type PickupLocationMinAggregateInputType = {
    id?: true
    name?: true
    line1?: true
    line2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    timezone?: true
    instructions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PickupLocationMaxAggregateInputType = {
    id?: true
    name?: true
    line1?: true
    line2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    timezone?: true
    instructions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PickupLocationCountAggregateInputType = {
    id?: true
    name?: true
    line1?: true
    line2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    timezone?: true
    instructions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PickupLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PickupLocation to aggregate.
     */
    where?: PickupLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickupLocations to fetch.
     */
    orderBy?: PickupLocationOrderByWithRelationInput | PickupLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PickupLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickupLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickupLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PickupLocations
    **/
    _count?: true | PickupLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PickupLocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PickupLocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PickupLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PickupLocationMaxAggregateInputType
  }

  export type GetPickupLocationAggregateType<T extends PickupLocationAggregateArgs> = {
        [P in keyof T & keyof AggregatePickupLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePickupLocation[P]>
      : GetScalarType<T[P], AggregatePickupLocation[P]>
  }




  export type PickupLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PickupLocationWhereInput
    orderBy?: PickupLocationOrderByWithAggregationInput | PickupLocationOrderByWithAggregationInput[]
    by: PickupLocationScalarFieldEnum[] | PickupLocationScalarFieldEnum
    having?: PickupLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PickupLocationCountAggregateInputType | true
    _avg?: PickupLocationAvgAggregateInputType
    _sum?: PickupLocationSumAggregateInputType
    _min?: PickupLocationMinAggregateInputType
    _max?: PickupLocationMaxAggregateInputType
  }

  export type PickupLocationGroupByOutputType = {
    id: number
    name: string
    line1: string
    line2: string | null
    city: string
    state: string
    postalCode: string
    country: string
    timezone: string | null
    instructions: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PickupLocationCountAggregateOutputType | null
    _avg: PickupLocationAvgAggregateOutputType | null
    _sum: PickupLocationSumAggregateOutputType | null
    _min: PickupLocationMinAggregateOutputType | null
    _max: PickupLocationMaxAggregateOutputType | null
  }

  type GetPickupLocationGroupByPayload<T extends PickupLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PickupLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PickupLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PickupLocationGroupByOutputType[P]>
            : GetScalarType<T[P], PickupLocationGroupByOutputType[P]>
        }
      >
    >


  export type PickupLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    timezone?: boolean
    instructions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceSlots?: boolean | PickupLocation$serviceSlotsArgs<ExtArgs>
    orders?: boolean | PickupLocation$ordersArgs<ExtArgs>
    _count?: boolean | PickupLocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pickupLocation"]>

  export type PickupLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    timezone?: boolean
    instructions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pickupLocation"]>

  export type PickupLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    timezone?: boolean
    instructions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pickupLocation"]>

  export type PickupLocationSelectScalar = {
    id?: boolean
    name?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    timezone?: boolean
    instructions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PickupLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "line1" | "line2" | "city" | "state" | "postalCode" | "country" | "timezone" | "instructions" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["pickupLocation"]>
  export type PickupLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceSlots?: boolean | PickupLocation$serviceSlotsArgs<ExtArgs>
    orders?: boolean | PickupLocation$ordersArgs<ExtArgs>
    _count?: boolean | PickupLocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PickupLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PickupLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PickupLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PickupLocation"
    objects: {
      serviceSlots: Prisma.$ServiceSlotPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      line1: string
      line2: string | null
      city: string
      state: string
      postalCode: string
      country: string
      timezone: string | null
      instructions: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pickupLocation"]>
    composites: {}
  }

  type PickupLocationGetPayload<S extends boolean | null | undefined | PickupLocationDefaultArgs> = $Result.GetResult<Prisma.$PickupLocationPayload, S>

  type PickupLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PickupLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PickupLocationCountAggregateInputType | true
    }

  export interface PickupLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PickupLocation'], meta: { name: 'PickupLocation' } }
    /**
     * Find zero or one PickupLocation that matches the filter.
     * @param {PickupLocationFindUniqueArgs} args - Arguments to find a PickupLocation
     * @example
     * // Get one PickupLocation
     * const pickupLocation = await prisma.pickupLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PickupLocationFindUniqueArgs>(args: SelectSubset<T, PickupLocationFindUniqueArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PickupLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PickupLocationFindUniqueOrThrowArgs} args - Arguments to find a PickupLocation
     * @example
     * // Get one PickupLocation
     * const pickupLocation = await prisma.pickupLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PickupLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, PickupLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PickupLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupLocationFindFirstArgs} args - Arguments to find a PickupLocation
     * @example
     * // Get one PickupLocation
     * const pickupLocation = await prisma.pickupLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PickupLocationFindFirstArgs>(args?: SelectSubset<T, PickupLocationFindFirstArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PickupLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupLocationFindFirstOrThrowArgs} args - Arguments to find a PickupLocation
     * @example
     * // Get one PickupLocation
     * const pickupLocation = await prisma.pickupLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PickupLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, PickupLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PickupLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PickupLocations
     * const pickupLocations = await prisma.pickupLocation.findMany()
     * 
     * // Get first 10 PickupLocations
     * const pickupLocations = await prisma.pickupLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pickupLocationWithIdOnly = await prisma.pickupLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PickupLocationFindManyArgs>(args?: SelectSubset<T, PickupLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PickupLocation.
     * @param {PickupLocationCreateArgs} args - Arguments to create a PickupLocation.
     * @example
     * // Create one PickupLocation
     * const PickupLocation = await prisma.pickupLocation.create({
     *   data: {
     *     // ... data to create a PickupLocation
     *   }
     * })
     * 
     */
    create<T extends PickupLocationCreateArgs>(args: SelectSubset<T, PickupLocationCreateArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PickupLocations.
     * @param {PickupLocationCreateManyArgs} args - Arguments to create many PickupLocations.
     * @example
     * // Create many PickupLocations
     * const pickupLocation = await prisma.pickupLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PickupLocationCreateManyArgs>(args?: SelectSubset<T, PickupLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PickupLocations and returns the data saved in the database.
     * @param {PickupLocationCreateManyAndReturnArgs} args - Arguments to create many PickupLocations.
     * @example
     * // Create many PickupLocations
     * const pickupLocation = await prisma.pickupLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PickupLocations and only return the `id`
     * const pickupLocationWithIdOnly = await prisma.pickupLocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PickupLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, PickupLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PickupLocation.
     * @param {PickupLocationDeleteArgs} args - Arguments to delete one PickupLocation.
     * @example
     * // Delete one PickupLocation
     * const PickupLocation = await prisma.pickupLocation.delete({
     *   where: {
     *     // ... filter to delete one PickupLocation
     *   }
     * })
     * 
     */
    delete<T extends PickupLocationDeleteArgs>(args: SelectSubset<T, PickupLocationDeleteArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PickupLocation.
     * @param {PickupLocationUpdateArgs} args - Arguments to update one PickupLocation.
     * @example
     * // Update one PickupLocation
     * const pickupLocation = await prisma.pickupLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PickupLocationUpdateArgs>(args: SelectSubset<T, PickupLocationUpdateArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PickupLocations.
     * @param {PickupLocationDeleteManyArgs} args - Arguments to filter PickupLocations to delete.
     * @example
     * // Delete a few PickupLocations
     * const { count } = await prisma.pickupLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PickupLocationDeleteManyArgs>(args?: SelectSubset<T, PickupLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PickupLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PickupLocations
     * const pickupLocation = await prisma.pickupLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PickupLocationUpdateManyArgs>(args: SelectSubset<T, PickupLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PickupLocations and returns the data updated in the database.
     * @param {PickupLocationUpdateManyAndReturnArgs} args - Arguments to update many PickupLocations.
     * @example
     * // Update many PickupLocations
     * const pickupLocation = await prisma.pickupLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PickupLocations and only return the `id`
     * const pickupLocationWithIdOnly = await prisma.pickupLocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PickupLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, PickupLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PickupLocation.
     * @param {PickupLocationUpsertArgs} args - Arguments to update or create a PickupLocation.
     * @example
     * // Update or create a PickupLocation
     * const pickupLocation = await prisma.pickupLocation.upsert({
     *   create: {
     *     // ... data to create a PickupLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PickupLocation we want to update
     *   }
     * })
     */
    upsert<T extends PickupLocationUpsertArgs>(args: SelectSubset<T, PickupLocationUpsertArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PickupLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupLocationCountArgs} args - Arguments to filter PickupLocations to count.
     * @example
     * // Count the number of PickupLocations
     * const count = await prisma.pickupLocation.count({
     *   where: {
     *     // ... the filter for the PickupLocations we want to count
     *   }
     * })
    **/
    count<T extends PickupLocationCountArgs>(
      args?: Subset<T, PickupLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PickupLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PickupLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PickupLocationAggregateArgs>(args: Subset<T, PickupLocationAggregateArgs>): Prisma.PrismaPromise<GetPickupLocationAggregateType<T>>

    /**
     * Group by PickupLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PickupLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PickupLocationGroupByArgs['orderBy'] }
        : { orderBy?: PickupLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PickupLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPickupLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PickupLocation model
   */
  readonly fields: PickupLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PickupLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PickupLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceSlots<T extends PickupLocation$serviceSlotsArgs<ExtArgs> = {}>(args?: Subset<T, PickupLocation$serviceSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends PickupLocation$ordersArgs<ExtArgs> = {}>(args?: Subset<T, PickupLocation$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PickupLocation model
   */
  interface PickupLocationFieldRefs {
    readonly id: FieldRef<"PickupLocation", 'Int'>
    readonly name: FieldRef<"PickupLocation", 'String'>
    readonly line1: FieldRef<"PickupLocation", 'String'>
    readonly line2: FieldRef<"PickupLocation", 'String'>
    readonly city: FieldRef<"PickupLocation", 'String'>
    readonly state: FieldRef<"PickupLocation", 'String'>
    readonly postalCode: FieldRef<"PickupLocation", 'String'>
    readonly country: FieldRef<"PickupLocation", 'String'>
    readonly timezone: FieldRef<"PickupLocation", 'String'>
    readonly instructions: FieldRef<"PickupLocation", 'String'>
    readonly isActive: FieldRef<"PickupLocation", 'Boolean'>
    readonly createdAt: FieldRef<"PickupLocation", 'DateTime'>
    readonly updatedAt: FieldRef<"PickupLocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PickupLocation findUnique
   */
  export type PickupLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickupLocation
     */
    omit?: PickupLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * Filter, which PickupLocation to fetch.
     */
    where: PickupLocationWhereUniqueInput
  }

  /**
   * PickupLocation findUniqueOrThrow
   */
  export type PickupLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickupLocation
     */
    omit?: PickupLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * Filter, which PickupLocation to fetch.
     */
    where: PickupLocationWhereUniqueInput
  }

  /**
   * PickupLocation findFirst
   */
  export type PickupLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickupLocation
     */
    omit?: PickupLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * Filter, which PickupLocation to fetch.
     */
    where?: PickupLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickupLocations to fetch.
     */
    orderBy?: PickupLocationOrderByWithRelationInput | PickupLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PickupLocations.
     */
    cursor?: PickupLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickupLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickupLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PickupLocations.
     */
    distinct?: PickupLocationScalarFieldEnum | PickupLocationScalarFieldEnum[]
  }

  /**
   * PickupLocation findFirstOrThrow
   */
  export type PickupLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickupLocation
     */
    omit?: PickupLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * Filter, which PickupLocation to fetch.
     */
    where?: PickupLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickupLocations to fetch.
     */
    orderBy?: PickupLocationOrderByWithRelationInput | PickupLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PickupLocations.
     */
    cursor?: PickupLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickupLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickupLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PickupLocations.
     */
    distinct?: PickupLocationScalarFieldEnum | PickupLocationScalarFieldEnum[]
  }

  /**
   * PickupLocation findMany
   */
  export type PickupLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickupLocation
     */
    omit?: PickupLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * Filter, which PickupLocations to fetch.
     */
    where?: PickupLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickupLocations to fetch.
     */
    orderBy?: PickupLocationOrderByWithRelationInput | PickupLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PickupLocations.
     */
    cursor?: PickupLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickupLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickupLocations.
     */
    skip?: number
    distinct?: PickupLocationScalarFieldEnum | PickupLocationScalarFieldEnum[]
  }

  /**
   * PickupLocation create
   */
  export type PickupLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickupLocation
     */
    omit?: PickupLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a PickupLocation.
     */
    data: XOR<PickupLocationCreateInput, PickupLocationUncheckedCreateInput>
  }

  /**
   * PickupLocation createMany
   */
  export type PickupLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PickupLocations.
     */
    data: PickupLocationCreateManyInput | PickupLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PickupLocation createManyAndReturn
   */
  export type PickupLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PickupLocation
     */
    omit?: PickupLocationOmit<ExtArgs> | null
    /**
     * The data used to create many PickupLocations.
     */
    data: PickupLocationCreateManyInput | PickupLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PickupLocation update
   */
  export type PickupLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickupLocation
     */
    omit?: PickupLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a PickupLocation.
     */
    data: XOR<PickupLocationUpdateInput, PickupLocationUncheckedUpdateInput>
    /**
     * Choose, which PickupLocation to update.
     */
    where: PickupLocationWhereUniqueInput
  }

  /**
   * PickupLocation updateMany
   */
  export type PickupLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PickupLocations.
     */
    data: XOR<PickupLocationUpdateManyMutationInput, PickupLocationUncheckedUpdateManyInput>
    /**
     * Filter which PickupLocations to update
     */
    where?: PickupLocationWhereInput
    /**
     * Limit how many PickupLocations to update.
     */
    limit?: number
  }

  /**
   * PickupLocation updateManyAndReturn
   */
  export type PickupLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PickupLocation
     */
    omit?: PickupLocationOmit<ExtArgs> | null
    /**
     * The data used to update PickupLocations.
     */
    data: XOR<PickupLocationUpdateManyMutationInput, PickupLocationUncheckedUpdateManyInput>
    /**
     * Filter which PickupLocations to update
     */
    where?: PickupLocationWhereInput
    /**
     * Limit how many PickupLocations to update.
     */
    limit?: number
  }

  /**
   * PickupLocation upsert
   */
  export type PickupLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickupLocation
     */
    omit?: PickupLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the PickupLocation to update in case it exists.
     */
    where: PickupLocationWhereUniqueInput
    /**
     * In case the PickupLocation found by the `where` argument doesn't exist, create a new PickupLocation with this data.
     */
    create: XOR<PickupLocationCreateInput, PickupLocationUncheckedCreateInput>
    /**
     * In case the PickupLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PickupLocationUpdateInput, PickupLocationUncheckedUpdateInput>
  }

  /**
   * PickupLocation delete
   */
  export type PickupLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickupLocation
     */
    omit?: PickupLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    /**
     * Filter which PickupLocation to delete.
     */
    where: PickupLocationWhereUniqueInput
  }

  /**
   * PickupLocation deleteMany
   */
  export type PickupLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PickupLocations to delete
     */
    where?: PickupLocationWhereInput
    /**
     * Limit how many PickupLocations to delete.
     */
    limit?: number
  }

  /**
   * PickupLocation.serviceSlots
   */
  export type PickupLocation$serviceSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlot
     */
    select?: ServiceSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSlot
     */
    omit?: ServiceSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSlotInclude<ExtArgs> | null
    where?: ServiceSlotWhereInput
    orderBy?: ServiceSlotOrderByWithRelationInput | ServiceSlotOrderByWithRelationInput[]
    cursor?: ServiceSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceSlotScalarFieldEnum | ServiceSlotScalarFieldEnum[]
  }

  /**
   * PickupLocation.orders
   */
  export type PickupLocation$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * PickupLocation without action
   */
  export type PickupLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickupLocation
     */
    omit?: PickupLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    lat: number | null
    lng: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number | null
    userId: number | null
    lat: number | null
    lng: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number | null
    userId: number | null
    label: string | null
    line1: string | null
    line2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    lat: number | null
    lng: number | null
    isDefault: boolean | null
    isSnapshot: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    label: string | null
    line1: string | null
    line2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    lat: number | null
    lng: number | null
    isDefault: boolean | null
    isSnapshot: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    userId: number
    label: number
    line1: number
    line2: number
    city: number
    state: number
    postalCode: number
    country: number
    lat: number
    lng: number
    isDefault: number
    isSnapshot: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    userId?: true
    lat?: true
    lng?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    userId?: true
    lat?: true
    lng?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    userId?: true
    label?: true
    line1?: true
    line2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    lat?: true
    lng?: true
    isDefault?: true
    isSnapshot?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    userId?: true
    label?: true
    line1?: true
    line2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    lat?: true
    lng?: true
    isDefault?: true
    isSnapshot?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    userId?: true
    label?: true
    line1?: true
    line2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    lat?: true
    lng?: true
    isDefault?: true
    isSnapshot?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: number
    userId: number | null
    label: string | null
    line1: string
    line2: string | null
    city: string
    state: string
    postalCode: string
    country: string
    lat: number | null
    lng: number | null
    isDefault: boolean
    isSnapshot: boolean
    createdAt: Date
    updatedAt: Date
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    label?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    lat?: boolean
    lng?: boolean
    isDefault?: boolean
    isSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Address$userArgs<ExtArgs>
    deliveryOrders?: boolean | Address$deliveryOrdersArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    label?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    lat?: boolean
    lng?: boolean
    isDefault?: boolean
    isSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Address$userArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    label?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    lat?: boolean
    lng?: boolean
    isDefault?: boolean
    isSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Address$userArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    userId?: boolean
    label?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    lat?: boolean
    lng?: boolean
    isDefault?: boolean
    isSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "label" | "line1" | "line2" | "city" | "state" | "postalCode" | "country" | "lat" | "lng" | "isDefault" | "isSnapshot" | "createdAt" | "updatedAt", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Address$userArgs<ExtArgs>
    deliveryOrders?: boolean | Address$deliveryOrdersArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Address$userArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Address$userArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      deliveryOrders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      label: string | null
      line1: string
      line2: string | null
      city: string
      state: string
      postalCode: string
      country: string
      lat: number | null
      lng: number | null
      isDefault: boolean
      isSnapshot: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Address$userArgs<ExtArgs> = {}>(args?: Subset<T, Address$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deliveryOrders<T extends Address$deliveryOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Address$deliveryOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'Int'>
    readonly userId: FieldRef<"Address", 'Int'>
    readonly label: FieldRef<"Address", 'String'>
    readonly line1: FieldRef<"Address", 'String'>
    readonly line2: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly state: FieldRef<"Address", 'String'>
    readonly postalCode: FieldRef<"Address", 'String'>
    readonly country: FieldRef<"Address", 'String'>
    readonly lat: FieldRef<"Address", 'Float'>
    readonly lng: FieldRef<"Address", 'Float'>
    readonly isDefault: FieldRef<"Address", 'Boolean'>
    readonly isSnapshot: FieldRef<"Address", 'Boolean'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
    readonly updatedAt: FieldRef<"Address", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address.user
   */
  export type Address$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Address.deliveryOrders
   */
  export type Address$deliveryOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model SlotTemplate
   */

  export type AggregateSlotTemplate = {
    _count: SlotTemplateCountAggregateOutputType | null
    _avg: SlotTemplateAvgAggregateOutputType | null
    _sum: SlotTemplateSumAggregateOutputType | null
    _min: SlotTemplateMinAggregateOutputType | null
    _max: SlotTemplateMaxAggregateOutputType | null
  }

  export type SlotTemplateAvgAggregateOutputType = {
    id: number | null
    startMin: number | null
    endMin: number | null
    defaultCapacity: number | null
  }

  export type SlotTemplateSumAggregateOutputType = {
    id: number | null
    startMin: number | null
    endMin: number | null
    defaultCapacity: number | null
  }

  export type SlotTemplateMinAggregateOutputType = {
    id: number | null
    label: string | null
    startMin: number | null
    endMin: number | null
    defaultCapacity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SlotTemplateMaxAggregateOutputType = {
    id: number | null
    label: string | null
    startMin: number | null
    endMin: number | null
    defaultCapacity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SlotTemplateCountAggregateOutputType = {
    id: number
    label: number
    startMin: number
    endMin: number
    defaultCapacity: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SlotTemplateAvgAggregateInputType = {
    id?: true
    startMin?: true
    endMin?: true
    defaultCapacity?: true
  }

  export type SlotTemplateSumAggregateInputType = {
    id?: true
    startMin?: true
    endMin?: true
    defaultCapacity?: true
  }

  export type SlotTemplateMinAggregateInputType = {
    id?: true
    label?: true
    startMin?: true
    endMin?: true
    defaultCapacity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SlotTemplateMaxAggregateInputType = {
    id?: true
    label?: true
    startMin?: true
    endMin?: true
    defaultCapacity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SlotTemplateCountAggregateInputType = {
    id?: true
    label?: true
    startMin?: true
    endMin?: true
    defaultCapacity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SlotTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SlotTemplate to aggregate.
     */
    where?: SlotTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlotTemplates to fetch.
     */
    orderBy?: SlotTemplateOrderByWithRelationInput | SlotTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SlotTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlotTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlotTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SlotTemplates
    **/
    _count?: true | SlotTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SlotTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SlotTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SlotTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SlotTemplateMaxAggregateInputType
  }

  export type GetSlotTemplateAggregateType<T extends SlotTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateSlotTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSlotTemplate[P]>
      : GetScalarType<T[P], AggregateSlotTemplate[P]>
  }




  export type SlotTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlotTemplateWhereInput
    orderBy?: SlotTemplateOrderByWithAggregationInput | SlotTemplateOrderByWithAggregationInput[]
    by: SlotTemplateScalarFieldEnum[] | SlotTemplateScalarFieldEnum
    having?: SlotTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SlotTemplateCountAggregateInputType | true
    _avg?: SlotTemplateAvgAggregateInputType
    _sum?: SlotTemplateSumAggregateInputType
    _min?: SlotTemplateMinAggregateInputType
    _max?: SlotTemplateMaxAggregateInputType
  }

  export type SlotTemplateGroupByOutputType = {
    id: number
    label: string
    startMin: number
    endMin: number
    defaultCapacity: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SlotTemplateCountAggregateOutputType | null
    _avg: SlotTemplateAvgAggregateOutputType | null
    _sum: SlotTemplateSumAggregateOutputType | null
    _min: SlotTemplateMinAggregateOutputType | null
    _max: SlotTemplateMaxAggregateOutputType | null
  }

  type GetSlotTemplateGroupByPayload<T extends SlotTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SlotTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SlotTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SlotTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], SlotTemplateGroupByOutputType[P]>
        }
      >
    >


  export type SlotTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    startMin?: boolean
    endMin?: boolean
    defaultCapacity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceSlots?: boolean | SlotTemplate$serviceSlotsArgs<ExtArgs>
    _count?: boolean | SlotTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["slotTemplate"]>

  export type SlotTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    startMin?: boolean
    endMin?: boolean
    defaultCapacity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["slotTemplate"]>

  export type SlotTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    startMin?: boolean
    endMin?: boolean
    defaultCapacity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["slotTemplate"]>

  export type SlotTemplateSelectScalar = {
    id?: boolean
    label?: boolean
    startMin?: boolean
    endMin?: boolean
    defaultCapacity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SlotTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "startMin" | "endMin" | "defaultCapacity" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["slotTemplate"]>
  export type SlotTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceSlots?: boolean | SlotTemplate$serviceSlotsArgs<ExtArgs>
    _count?: boolean | SlotTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SlotTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SlotTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SlotTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SlotTemplate"
    objects: {
      serviceSlots: Prisma.$ServiceSlotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label: string
      startMin: number
      endMin: number
      defaultCapacity: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["slotTemplate"]>
    composites: {}
  }

  type SlotTemplateGetPayload<S extends boolean | null | undefined | SlotTemplateDefaultArgs> = $Result.GetResult<Prisma.$SlotTemplatePayload, S>

  type SlotTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SlotTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SlotTemplateCountAggregateInputType | true
    }

  export interface SlotTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SlotTemplate'], meta: { name: 'SlotTemplate' } }
    /**
     * Find zero or one SlotTemplate that matches the filter.
     * @param {SlotTemplateFindUniqueArgs} args - Arguments to find a SlotTemplate
     * @example
     * // Get one SlotTemplate
     * const slotTemplate = await prisma.slotTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SlotTemplateFindUniqueArgs>(args: SelectSubset<T, SlotTemplateFindUniqueArgs<ExtArgs>>): Prisma__SlotTemplateClient<$Result.GetResult<Prisma.$SlotTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SlotTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SlotTemplateFindUniqueOrThrowArgs} args - Arguments to find a SlotTemplate
     * @example
     * // Get one SlotTemplate
     * const slotTemplate = await prisma.slotTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SlotTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, SlotTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SlotTemplateClient<$Result.GetResult<Prisma.$SlotTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SlotTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotTemplateFindFirstArgs} args - Arguments to find a SlotTemplate
     * @example
     * // Get one SlotTemplate
     * const slotTemplate = await prisma.slotTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SlotTemplateFindFirstArgs>(args?: SelectSubset<T, SlotTemplateFindFirstArgs<ExtArgs>>): Prisma__SlotTemplateClient<$Result.GetResult<Prisma.$SlotTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SlotTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotTemplateFindFirstOrThrowArgs} args - Arguments to find a SlotTemplate
     * @example
     * // Get one SlotTemplate
     * const slotTemplate = await prisma.slotTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SlotTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, SlotTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__SlotTemplateClient<$Result.GetResult<Prisma.$SlotTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SlotTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SlotTemplates
     * const slotTemplates = await prisma.slotTemplate.findMany()
     * 
     * // Get first 10 SlotTemplates
     * const slotTemplates = await prisma.slotTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const slotTemplateWithIdOnly = await prisma.slotTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SlotTemplateFindManyArgs>(args?: SelectSubset<T, SlotTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlotTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SlotTemplate.
     * @param {SlotTemplateCreateArgs} args - Arguments to create a SlotTemplate.
     * @example
     * // Create one SlotTemplate
     * const SlotTemplate = await prisma.slotTemplate.create({
     *   data: {
     *     // ... data to create a SlotTemplate
     *   }
     * })
     * 
     */
    create<T extends SlotTemplateCreateArgs>(args: SelectSubset<T, SlotTemplateCreateArgs<ExtArgs>>): Prisma__SlotTemplateClient<$Result.GetResult<Prisma.$SlotTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SlotTemplates.
     * @param {SlotTemplateCreateManyArgs} args - Arguments to create many SlotTemplates.
     * @example
     * // Create many SlotTemplates
     * const slotTemplate = await prisma.slotTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SlotTemplateCreateManyArgs>(args?: SelectSubset<T, SlotTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SlotTemplates and returns the data saved in the database.
     * @param {SlotTemplateCreateManyAndReturnArgs} args - Arguments to create many SlotTemplates.
     * @example
     * // Create many SlotTemplates
     * const slotTemplate = await prisma.slotTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SlotTemplates and only return the `id`
     * const slotTemplateWithIdOnly = await prisma.slotTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SlotTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, SlotTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlotTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SlotTemplate.
     * @param {SlotTemplateDeleteArgs} args - Arguments to delete one SlotTemplate.
     * @example
     * // Delete one SlotTemplate
     * const SlotTemplate = await prisma.slotTemplate.delete({
     *   where: {
     *     // ... filter to delete one SlotTemplate
     *   }
     * })
     * 
     */
    delete<T extends SlotTemplateDeleteArgs>(args: SelectSubset<T, SlotTemplateDeleteArgs<ExtArgs>>): Prisma__SlotTemplateClient<$Result.GetResult<Prisma.$SlotTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SlotTemplate.
     * @param {SlotTemplateUpdateArgs} args - Arguments to update one SlotTemplate.
     * @example
     * // Update one SlotTemplate
     * const slotTemplate = await prisma.slotTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SlotTemplateUpdateArgs>(args: SelectSubset<T, SlotTemplateUpdateArgs<ExtArgs>>): Prisma__SlotTemplateClient<$Result.GetResult<Prisma.$SlotTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SlotTemplates.
     * @param {SlotTemplateDeleteManyArgs} args - Arguments to filter SlotTemplates to delete.
     * @example
     * // Delete a few SlotTemplates
     * const { count } = await prisma.slotTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SlotTemplateDeleteManyArgs>(args?: SelectSubset<T, SlotTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SlotTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SlotTemplates
     * const slotTemplate = await prisma.slotTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SlotTemplateUpdateManyArgs>(args: SelectSubset<T, SlotTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SlotTemplates and returns the data updated in the database.
     * @param {SlotTemplateUpdateManyAndReturnArgs} args - Arguments to update many SlotTemplates.
     * @example
     * // Update many SlotTemplates
     * const slotTemplate = await prisma.slotTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SlotTemplates and only return the `id`
     * const slotTemplateWithIdOnly = await prisma.slotTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SlotTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, SlotTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlotTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SlotTemplate.
     * @param {SlotTemplateUpsertArgs} args - Arguments to update or create a SlotTemplate.
     * @example
     * // Update or create a SlotTemplate
     * const slotTemplate = await prisma.slotTemplate.upsert({
     *   create: {
     *     // ... data to create a SlotTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SlotTemplate we want to update
     *   }
     * })
     */
    upsert<T extends SlotTemplateUpsertArgs>(args: SelectSubset<T, SlotTemplateUpsertArgs<ExtArgs>>): Prisma__SlotTemplateClient<$Result.GetResult<Prisma.$SlotTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SlotTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotTemplateCountArgs} args - Arguments to filter SlotTemplates to count.
     * @example
     * // Count the number of SlotTemplates
     * const count = await prisma.slotTemplate.count({
     *   where: {
     *     // ... the filter for the SlotTemplates we want to count
     *   }
     * })
    **/
    count<T extends SlotTemplateCountArgs>(
      args?: Subset<T, SlotTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SlotTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SlotTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SlotTemplateAggregateArgs>(args: Subset<T, SlotTemplateAggregateArgs>): Prisma.PrismaPromise<GetSlotTemplateAggregateType<T>>

    /**
     * Group by SlotTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SlotTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SlotTemplateGroupByArgs['orderBy'] }
        : { orderBy?: SlotTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SlotTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSlotTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SlotTemplate model
   */
  readonly fields: SlotTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SlotTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SlotTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceSlots<T extends SlotTemplate$serviceSlotsArgs<ExtArgs> = {}>(args?: Subset<T, SlotTemplate$serviceSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SlotTemplate model
   */
  interface SlotTemplateFieldRefs {
    readonly id: FieldRef<"SlotTemplate", 'Int'>
    readonly label: FieldRef<"SlotTemplate", 'String'>
    readonly startMin: FieldRef<"SlotTemplate", 'Int'>
    readonly endMin: FieldRef<"SlotTemplate", 'Int'>
    readonly defaultCapacity: FieldRef<"SlotTemplate", 'Int'>
    readonly isActive: FieldRef<"SlotTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"SlotTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"SlotTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SlotTemplate findUnique
   */
  export type SlotTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotTemplate
     */
    select?: SlotTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotTemplate
     */
    omit?: SlotTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotTemplateInclude<ExtArgs> | null
    /**
     * Filter, which SlotTemplate to fetch.
     */
    where: SlotTemplateWhereUniqueInput
  }

  /**
   * SlotTemplate findUniqueOrThrow
   */
  export type SlotTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotTemplate
     */
    select?: SlotTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotTemplate
     */
    omit?: SlotTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotTemplateInclude<ExtArgs> | null
    /**
     * Filter, which SlotTemplate to fetch.
     */
    where: SlotTemplateWhereUniqueInput
  }

  /**
   * SlotTemplate findFirst
   */
  export type SlotTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotTemplate
     */
    select?: SlotTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotTemplate
     */
    omit?: SlotTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotTemplateInclude<ExtArgs> | null
    /**
     * Filter, which SlotTemplate to fetch.
     */
    where?: SlotTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlotTemplates to fetch.
     */
    orderBy?: SlotTemplateOrderByWithRelationInput | SlotTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SlotTemplates.
     */
    cursor?: SlotTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlotTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlotTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SlotTemplates.
     */
    distinct?: SlotTemplateScalarFieldEnum | SlotTemplateScalarFieldEnum[]
  }

  /**
   * SlotTemplate findFirstOrThrow
   */
  export type SlotTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotTemplate
     */
    select?: SlotTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotTemplate
     */
    omit?: SlotTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotTemplateInclude<ExtArgs> | null
    /**
     * Filter, which SlotTemplate to fetch.
     */
    where?: SlotTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlotTemplates to fetch.
     */
    orderBy?: SlotTemplateOrderByWithRelationInput | SlotTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SlotTemplates.
     */
    cursor?: SlotTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlotTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlotTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SlotTemplates.
     */
    distinct?: SlotTemplateScalarFieldEnum | SlotTemplateScalarFieldEnum[]
  }

  /**
   * SlotTemplate findMany
   */
  export type SlotTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotTemplate
     */
    select?: SlotTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotTemplate
     */
    omit?: SlotTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotTemplateInclude<ExtArgs> | null
    /**
     * Filter, which SlotTemplates to fetch.
     */
    where?: SlotTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlotTemplates to fetch.
     */
    orderBy?: SlotTemplateOrderByWithRelationInput | SlotTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SlotTemplates.
     */
    cursor?: SlotTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlotTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlotTemplates.
     */
    skip?: number
    distinct?: SlotTemplateScalarFieldEnum | SlotTemplateScalarFieldEnum[]
  }

  /**
   * SlotTemplate create
   */
  export type SlotTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotTemplate
     */
    select?: SlotTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotTemplate
     */
    omit?: SlotTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a SlotTemplate.
     */
    data: XOR<SlotTemplateCreateInput, SlotTemplateUncheckedCreateInput>
  }

  /**
   * SlotTemplate createMany
   */
  export type SlotTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SlotTemplates.
     */
    data: SlotTemplateCreateManyInput | SlotTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SlotTemplate createManyAndReturn
   */
  export type SlotTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotTemplate
     */
    select?: SlotTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SlotTemplate
     */
    omit?: SlotTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many SlotTemplates.
     */
    data: SlotTemplateCreateManyInput | SlotTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SlotTemplate update
   */
  export type SlotTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotTemplate
     */
    select?: SlotTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotTemplate
     */
    omit?: SlotTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a SlotTemplate.
     */
    data: XOR<SlotTemplateUpdateInput, SlotTemplateUncheckedUpdateInput>
    /**
     * Choose, which SlotTemplate to update.
     */
    where: SlotTemplateWhereUniqueInput
  }

  /**
   * SlotTemplate updateMany
   */
  export type SlotTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SlotTemplates.
     */
    data: XOR<SlotTemplateUpdateManyMutationInput, SlotTemplateUncheckedUpdateManyInput>
    /**
     * Filter which SlotTemplates to update
     */
    where?: SlotTemplateWhereInput
    /**
     * Limit how many SlotTemplates to update.
     */
    limit?: number
  }

  /**
   * SlotTemplate updateManyAndReturn
   */
  export type SlotTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotTemplate
     */
    select?: SlotTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SlotTemplate
     */
    omit?: SlotTemplateOmit<ExtArgs> | null
    /**
     * The data used to update SlotTemplates.
     */
    data: XOR<SlotTemplateUpdateManyMutationInput, SlotTemplateUncheckedUpdateManyInput>
    /**
     * Filter which SlotTemplates to update
     */
    where?: SlotTemplateWhereInput
    /**
     * Limit how many SlotTemplates to update.
     */
    limit?: number
  }

  /**
   * SlotTemplate upsert
   */
  export type SlotTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotTemplate
     */
    select?: SlotTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotTemplate
     */
    omit?: SlotTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the SlotTemplate to update in case it exists.
     */
    where: SlotTemplateWhereUniqueInput
    /**
     * In case the SlotTemplate found by the `where` argument doesn't exist, create a new SlotTemplate with this data.
     */
    create: XOR<SlotTemplateCreateInput, SlotTemplateUncheckedCreateInput>
    /**
     * In case the SlotTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SlotTemplateUpdateInput, SlotTemplateUncheckedUpdateInput>
  }

  /**
   * SlotTemplate delete
   */
  export type SlotTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotTemplate
     */
    select?: SlotTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotTemplate
     */
    omit?: SlotTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotTemplateInclude<ExtArgs> | null
    /**
     * Filter which SlotTemplate to delete.
     */
    where: SlotTemplateWhereUniqueInput
  }

  /**
   * SlotTemplate deleteMany
   */
  export type SlotTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SlotTemplates to delete
     */
    where?: SlotTemplateWhereInput
    /**
     * Limit how many SlotTemplates to delete.
     */
    limit?: number
  }

  /**
   * SlotTemplate.serviceSlots
   */
  export type SlotTemplate$serviceSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlot
     */
    select?: ServiceSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSlot
     */
    omit?: ServiceSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSlotInclude<ExtArgs> | null
    where?: ServiceSlotWhereInput
    orderBy?: ServiceSlotOrderByWithRelationInput | ServiceSlotOrderByWithRelationInput[]
    cursor?: ServiceSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceSlotScalarFieldEnum | ServiceSlotScalarFieldEnum[]
  }

  /**
   * SlotTemplate without action
   */
  export type SlotTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotTemplate
     */
    select?: SlotTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlotTemplate
     */
    omit?: SlotTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotTemplateInclude<ExtArgs> | null
  }


  /**
   * Model ServiceSlot
   */

  export type AggregateServiceSlot = {
    _count: ServiceSlotCountAggregateOutputType | null
    _avg: ServiceSlotAvgAggregateOutputType | null
    _sum: ServiceSlotSumAggregateOutputType | null
    _min: ServiceSlotMinAggregateOutputType | null
    _max: ServiceSlotMaxAggregateOutputType | null
  }

  export type ServiceSlotAvgAggregateOutputType = {
    id: number | null
    serviceDayId: number | null
    slotTemplateId: number | null
    pickupLocationId: number | null
    capacityOverride: number | null
  }

  export type ServiceSlotSumAggregateOutputType = {
    id: number | null
    serviceDayId: number | null
    slotTemplateId: number | null
    pickupLocationId: number | null
    capacityOverride: number | null
  }

  export type ServiceSlotMinAggregateOutputType = {
    id: number | null
    serviceDayId: number | null
    slotTemplateId: number | null
    fulfillmentType: $Enums.FulfillmentType | null
    pickupLocationId: number | null
    slotKey: string | null
    capacityOverride: number | null
    isClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceSlotMaxAggregateOutputType = {
    id: number | null
    serviceDayId: number | null
    slotTemplateId: number | null
    fulfillmentType: $Enums.FulfillmentType | null
    pickupLocationId: number | null
    slotKey: string | null
    capacityOverride: number | null
    isClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceSlotCountAggregateOutputType = {
    id: number
    serviceDayId: number
    slotTemplateId: number
    fulfillmentType: number
    pickupLocationId: number
    slotKey: number
    capacityOverride: number
    isClosed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceSlotAvgAggregateInputType = {
    id?: true
    serviceDayId?: true
    slotTemplateId?: true
    pickupLocationId?: true
    capacityOverride?: true
  }

  export type ServiceSlotSumAggregateInputType = {
    id?: true
    serviceDayId?: true
    slotTemplateId?: true
    pickupLocationId?: true
    capacityOverride?: true
  }

  export type ServiceSlotMinAggregateInputType = {
    id?: true
    serviceDayId?: true
    slotTemplateId?: true
    fulfillmentType?: true
    pickupLocationId?: true
    slotKey?: true
    capacityOverride?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceSlotMaxAggregateInputType = {
    id?: true
    serviceDayId?: true
    slotTemplateId?: true
    fulfillmentType?: true
    pickupLocationId?: true
    slotKey?: true
    capacityOverride?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceSlotCountAggregateInputType = {
    id?: true
    serviceDayId?: true
    slotTemplateId?: true
    fulfillmentType?: true
    pickupLocationId?: true
    slotKey?: true
    capacityOverride?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceSlot to aggregate.
     */
    where?: ServiceSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSlots to fetch.
     */
    orderBy?: ServiceSlotOrderByWithRelationInput | ServiceSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceSlots
    **/
    _count?: true | ServiceSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceSlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceSlotMaxAggregateInputType
  }

  export type GetServiceSlotAggregateType<T extends ServiceSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceSlot[P]>
      : GetScalarType<T[P], AggregateServiceSlot[P]>
  }




  export type ServiceSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceSlotWhereInput
    orderBy?: ServiceSlotOrderByWithAggregationInput | ServiceSlotOrderByWithAggregationInput[]
    by: ServiceSlotScalarFieldEnum[] | ServiceSlotScalarFieldEnum
    having?: ServiceSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceSlotCountAggregateInputType | true
    _avg?: ServiceSlotAvgAggregateInputType
    _sum?: ServiceSlotSumAggregateInputType
    _min?: ServiceSlotMinAggregateInputType
    _max?: ServiceSlotMaxAggregateInputType
  }

  export type ServiceSlotGroupByOutputType = {
    id: number
    serviceDayId: number
    slotTemplateId: number
    fulfillmentType: $Enums.FulfillmentType
    pickupLocationId: number | null
    slotKey: string
    capacityOverride: number | null
    isClosed: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceSlotCountAggregateOutputType | null
    _avg: ServiceSlotAvgAggregateOutputType | null
    _sum: ServiceSlotSumAggregateOutputType | null
    _min: ServiceSlotMinAggregateOutputType | null
    _max: ServiceSlotMaxAggregateOutputType | null
  }

  type GetServiceSlotGroupByPayload<T extends ServiceSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceSlotGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceSlotGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceDayId?: boolean
    slotTemplateId?: boolean
    fulfillmentType?: boolean
    pickupLocationId?: boolean
    slotKey?: boolean
    capacityOverride?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
    template?: boolean | SlotTemplateDefaultArgs<ExtArgs>
    pickupLocation?: boolean | ServiceSlot$pickupLocationArgs<ExtArgs>
    groups?: boolean | ServiceSlot$groupsArgs<ExtArgs>
    _count?: boolean | ServiceSlotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceSlot"]>

  export type ServiceSlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceDayId?: boolean
    slotTemplateId?: boolean
    fulfillmentType?: boolean
    pickupLocationId?: boolean
    slotKey?: boolean
    capacityOverride?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
    template?: boolean | SlotTemplateDefaultArgs<ExtArgs>
    pickupLocation?: boolean | ServiceSlot$pickupLocationArgs<ExtArgs>
  }, ExtArgs["result"]["serviceSlot"]>

  export type ServiceSlotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceDayId?: boolean
    slotTemplateId?: boolean
    fulfillmentType?: boolean
    pickupLocationId?: boolean
    slotKey?: boolean
    capacityOverride?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
    template?: boolean | SlotTemplateDefaultArgs<ExtArgs>
    pickupLocation?: boolean | ServiceSlot$pickupLocationArgs<ExtArgs>
  }, ExtArgs["result"]["serviceSlot"]>

  export type ServiceSlotSelectScalar = {
    id?: boolean
    serviceDayId?: boolean
    slotTemplateId?: boolean
    fulfillmentType?: boolean
    pickupLocationId?: boolean
    slotKey?: boolean
    capacityOverride?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceSlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceDayId" | "slotTemplateId" | "fulfillmentType" | "pickupLocationId" | "slotKey" | "capacityOverride" | "isClosed" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceSlot"]>
  export type ServiceSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
    template?: boolean | SlotTemplateDefaultArgs<ExtArgs>
    pickupLocation?: boolean | ServiceSlot$pickupLocationArgs<ExtArgs>
    groups?: boolean | ServiceSlot$groupsArgs<ExtArgs>
    _count?: boolean | ServiceSlotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceSlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
    template?: boolean | SlotTemplateDefaultArgs<ExtArgs>
    pickupLocation?: boolean | ServiceSlot$pickupLocationArgs<ExtArgs>
  }
  export type ServiceSlotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
    template?: boolean | SlotTemplateDefaultArgs<ExtArgs>
    pickupLocation?: boolean | ServiceSlot$pickupLocationArgs<ExtArgs>
  }

  export type $ServiceSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceSlot"
    objects: {
      serviceDay: Prisma.$ServiceDayPayload<ExtArgs>
      template: Prisma.$SlotTemplatePayload<ExtArgs>
      pickupLocation: Prisma.$PickupLocationPayload<ExtArgs> | null
      groups: Prisma.$FulfillmentGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serviceDayId: number
      slotTemplateId: number
      fulfillmentType: $Enums.FulfillmentType
      pickupLocationId: number | null
      slotKey: string
      capacityOverride: number | null
      isClosed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceSlot"]>
    composites: {}
  }

  type ServiceSlotGetPayload<S extends boolean | null | undefined | ServiceSlotDefaultArgs> = $Result.GetResult<Prisma.$ServiceSlotPayload, S>

  type ServiceSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceSlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceSlotCountAggregateInputType | true
    }

  export interface ServiceSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceSlot'], meta: { name: 'ServiceSlot' } }
    /**
     * Find zero or one ServiceSlot that matches the filter.
     * @param {ServiceSlotFindUniqueArgs} args - Arguments to find a ServiceSlot
     * @example
     * // Get one ServiceSlot
     * const serviceSlot = await prisma.serviceSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceSlotFindUniqueArgs>(args: SelectSubset<T, ServiceSlotFindUniqueArgs<ExtArgs>>): Prisma__ServiceSlotClient<$Result.GetResult<Prisma.$ServiceSlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceSlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceSlotFindUniqueOrThrowArgs} args - Arguments to find a ServiceSlot
     * @example
     * // Get one ServiceSlot
     * const serviceSlot = await prisma.serviceSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceSlotClient<$Result.GetResult<Prisma.$ServiceSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSlotFindFirstArgs} args - Arguments to find a ServiceSlot
     * @example
     * // Get one ServiceSlot
     * const serviceSlot = await prisma.serviceSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceSlotFindFirstArgs>(args?: SelectSubset<T, ServiceSlotFindFirstArgs<ExtArgs>>): Prisma__ServiceSlotClient<$Result.GetResult<Prisma.$ServiceSlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSlotFindFirstOrThrowArgs} args - Arguments to find a ServiceSlot
     * @example
     * // Get one ServiceSlot
     * const serviceSlot = await prisma.serviceSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceSlotClient<$Result.GetResult<Prisma.$ServiceSlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceSlots
     * const serviceSlots = await prisma.serviceSlot.findMany()
     * 
     * // Get first 10 ServiceSlots
     * const serviceSlots = await prisma.serviceSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceSlotWithIdOnly = await prisma.serviceSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceSlotFindManyArgs>(args?: SelectSubset<T, ServiceSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceSlot.
     * @param {ServiceSlotCreateArgs} args - Arguments to create a ServiceSlot.
     * @example
     * // Create one ServiceSlot
     * const ServiceSlot = await prisma.serviceSlot.create({
     *   data: {
     *     // ... data to create a ServiceSlot
     *   }
     * })
     * 
     */
    create<T extends ServiceSlotCreateArgs>(args: SelectSubset<T, ServiceSlotCreateArgs<ExtArgs>>): Prisma__ServiceSlotClient<$Result.GetResult<Prisma.$ServiceSlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceSlots.
     * @param {ServiceSlotCreateManyArgs} args - Arguments to create many ServiceSlots.
     * @example
     * // Create many ServiceSlots
     * const serviceSlot = await prisma.serviceSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceSlotCreateManyArgs>(args?: SelectSubset<T, ServiceSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceSlots and returns the data saved in the database.
     * @param {ServiceSlotCreateManyAndReturnArgs} args - Arguments to create many ServiceSlots.
     * @example
     * // Create many ServiceSlots
     * const serviceSlot = await prisma.serviceSlot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceSlots and only return the `id`
     * const serviceSlotWithIdOnly = await prisma.serviceSlot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceSlotCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceSlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSlotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceSlot.
     * @param {ServiceSlotDeleteArgs} args - Arguments to delete one ServiceSlot.
     * @example
     * // Delete one ServiceSlot
     * const ServiceSlot = await prisma.serviceSlot.delete({
     *   where: {
     *     // ... filter to delete one ServiceSlot
     *   }
     * })
     * 
     */
    delete<T extends ServiceSlotDeleteArgs>(args: SelectSubset<T, ServiceSlotDeleteArgs<ExtArgs>>): Prisma__ServiceSlotClient<$Result.GetResult<Prisma.$ServiceSlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceSlot.
     * @param {ServiceSlotUpdateArgs} args - Arguments to update one ServiceSlot.
     * @example
     * // Update one ServiceSlot
     * const serviceSlot = await prisma.serviceSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceSlotUpdateArgs>(args: SelectSubset<T, ServiceSlotUpdateArgs<ExtArgs>>): Prisma__ServiceSlotClient<$Result.GetResult<Prisma.$ServiceSlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceSlots.
     * @param {ServiceSlotDeleteManyArgs} args - Arguments to filter ServiceSlots to delete.
     * @example
     * // Delete a few ServiceSlots
     * const { count } = await prisma.serviceSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceSlotDeleteManyArgs>(args?: SelectSubset<T, ServiceSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceSlots
     * const serviceSlot = await prisma.serviceSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceSlotUpdateManyArgs>(args: SelectSubset<T, ServiceSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceSlots and returns the data updated in the database.
     * @param {ServiceSlotUpdateManyAndReturnArgs} args - Arguments to update many ServiceSlots.
     * @example
     * // Update many ServiceSlots
     * const serviceSlot = await prisma.serviceSlot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceSlots and only return the `id`
     * const serviceSlotWithIdOnly = await prisma.serviceSlot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceSlotUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceSlotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSlotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceSlot.
     * @param {ServiceSlotUpsertArgs} args - Arguments to update or create a ServiceSlot.
     * @example
     * // Update or create a ServiceSlot
     * const serviceSlot = await prisma.serviceSlot.upsert({
     *   create: {
     *     // ... data to create a ServiceSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceSlot we want to update
     *   }
     * })
     */
    upsert<T extends ServiceSlotUpsertArgs>(args: SelectSubset<T, ServiceSlotUpsertArgs<ExtArgs>>): Prisma__ServiceSlotClient<$Result.GetResult<Prisma.$ServiceSlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSlotCountArgs} args - Arguments to filter ServiceSlots to count.
     * @example
     * // Count the number of ServiceSlots
     * const count = await prisma.serviceSlot.count({
     *   where: {
     *     // ... the filter for the ServiceSlots we want to count
     *   }
     * })
    **/
    count<T extends ServiceSlotCountArgs>(
      args?: Subset<T, ServiceSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceSlotAggregateArgs>(args: Subset<T, ServiceSlotAggregateArgs>): Prisma.PrismaPromise<GetServiceSlotAggregateType<T>>

    /**
     * Group by ServiceSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceSlotGroupByArgs['orderBy'] }
        : { orderBy?: ServiceSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceSlot model
   */
  readonly fields: ServiceSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceDay<T extends ServiceDayDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDayDefaultArgs<ExtArgs>>): Prisma__ServiceDayClient<$Result.GetResult<Prisma.$ServiceDayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    template<T extends SlotTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SlotTemplateDefaultArgs<ExtArgs>>): Prisma__SlotTemplateClient<$Result.GetResult<Prisma.$SlotTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pickupLocation<T extends ServiceSlot$pickupLocationArgs<ExtArgs> = {}>(args?: Subset<T, ServiceSlot$pickupLocationArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    groups<T extends ServiceSlot$groupsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceSlot$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceSlot model
   */
  interface ServiceSlotFieldRefs {
    readonly id: FieldRef<"ServiceSlot", 'Int'>
    readonly serviceDayId: FieldRef<"ServiceSlot", 'Int'>
    readonly slotTemplateId: FieldRef<"ServiceSlot", 'Int'>
    readonly fulfillmentType: FieldRef<"ServiceSlot", 'FulfillmentType'>
    readonly pickupLocationId: FieldRef<"ServiceSlot", 'Int'>
    readonly slotKey: FieldRef<"ServiceSlot", 'String'>
    readonly capacityOverride: FieldRef<"ServiceSlot", 'Int'>
    readonly isClosed: FieldRef<"ServiceSlot", 'Boolean'>
    readonly createdAt: FieldRef<"ServiceSlot", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceSlot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceSlot findUnique
   */
  export type ServiceSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlot
     */
    select?: ServiceSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSlot
     */
    omit?: ServiceSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSlotInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSlot to fetch.
     */
    where: ServiceSlotWhereUniqueInput
  }

  /**
   * ServiceSlot findUniqueOrThrow
   */
  export type ServiceSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlot
     */
    select?: ServiceSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSlot
     */
    omit?: ServiceSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSlotInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSlot to fetch.
     */
    where: ServiceSlotWhereUniqueInput
  }

  /**
   * ServiceSlot findFirst
   */
  export type ServiceSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlot
     */
    select?: ServiceSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSlot
     */
    omit?: ServiceSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSlotInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSlot to fetch.
     */
    where?: ServiceSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSlots to fetch.
     */
    orderBy?: ServiceSlotOrderByWithRelationInput | ServiceSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSlots.
     */
    cursor?: ServiceSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSlots.
     */
    distinct?: ServiceSlotScalarFieldEnum | ServiceSlotScalarFieldEnum[]
  }

  /**
   * ServiceSlot findFirstOrThrow
   */
  export type ServiceSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlot
     */
    select?: ServiceSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSlot
     */
    omit?: ServiceSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSlotInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSlot to fetch.
     */
    where?: ServiceSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSlots to fetch.
     */
    orderBy?: ServiceSlotOrderByWithRelationInput | ServiceSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSlots.
     */
    cursor?: ServiceSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSlots.
     */
    distinct?: ServiceSlotScalarFieldEnum | ServiceSlotScalarFieldEnum[]
  }

  /**
   * ServiceSlot findMany
   */
  export type ServiceSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlot
     */
    select?: ServiceSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSlot
     */
    omit?: ServiceSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSlotInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSlots to fetch.
     */
    where?: ServiceSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSlots to fetch.
     */
    orderBy?: ServiceSlotOrderByWithRelationInput | ServiceSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceSlots.
     */
    cursor?: ServiceSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSlots.
     */
    skip?: number
    distinct?: ServiceSlotScalarFieldEnum | ServiceSlotScalarFieldEnum[]
  }

  /**
   * ServiceSlot create
   */
  export type ServiceSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlot
     */
    select?: ServiceSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSlot
     */
    omit?: ServiceSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceSlot.
     */
    data: XOR<ServiceSlotCreateInput, ServiceSlotUncheckedCreateInput>
  }

  /**
   * ServiceSlot createMany
   */
  export type ServiceSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceSlots.
     */
    data: ServiceSlotCreateManyInput | ServiceSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceSlot createManyAndReturn
   */
  export type ServiceSlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlot
     */
    select?: ServiceSlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSlot
     */
    omit?: ServiceSlotOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceSlots.
     */
    data: ServiceSlotCreateManyInput | ServiceSlotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceSlot update
   */
  export type ServiceSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlot
     */
    select?: ServiceSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSlot
     */
    omit?: ServiceSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceSlot.
     */
    data: XOR<ServiceSlotUpdateInput, ServiceSlotUncheckedUpdateInput>
    /**
     * Choose, which ServiceSlot to update.
     */
    where: ServiceSlotWhereUniqueInput
  }

  /**
   * ServiceSlot updateMany
   */
  export type ServiceSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceSlots.
     */
    data: XOR<ServiceSlotUpdateManyMutationInput, ServiceSlotUncheckedUpdateManyInput>
    /**
     * Filter which ServiceSlots to update
     */
    where?: ServiceSlotWhereInput
    /**
     * Limit how many ServiceSlots to update.
     */
    limit?: number
  }

  /**
   * ServiceSlot updateManyAndReturn
   */
  export type ServiceSlotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlot
     */
    select?: ServiceSlotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSlot
     */
    omit?: ServiceSlotOmit<ExtArgs> | null
    /**
     * The data used to update ServiceSlots.
     */
    data: XOR<ServiceSlotUpdateManyMutationInput, ServiceSlotUncheckedUpdateManyInput>
    /**
     * Filter which ServiceSlots to update
     */
    where?: ServiceSlotWhereInput
    /**
     * Limit how many ServiceSlots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSlotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceSlot upsert
   */
  export type ServiceSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlot
     */
    select?: ServiceSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSlot
     */
    omit?: ServiceSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceSlot to update in case it exists.
     */
    where: ServiceSlotWhereUniqueInput
    /**
     * In case the ServiceSlot found by the `where` argument doesn't exist, create a new ServiceSlot with this data.
     */
    create: XOR<ServiceSlotCreateInput, ServiceSlotUncheckedCreateInput>
    /**
     * In case the ServiceSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceSlotUpdateInput, ServiceSlotUncheckedUpdateInput>
  }

  /**
   * ServiceSlot delete
   */
  export type ServiceSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlot
     */
    select?: ServiceSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSlot
     */
    omit?: ServiceSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSlotInclude<ExtArgs> | null
    /**
     * Filter which ServiceSlot to delete.
     */
    where: ServiceSlotWhereUniqueInput
  }

  /**
   * ServiceSlot deleteMany
   */
  export type ServiceSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceSlots to delete
     */
    where?: ServiceSlotWhereInput
    /**
     * Limit how many ServiceSlots to delete.
     */
    limit?: number
  }

  /**
   * ServiceSlot.pickupLocation
   */
  export type ServiceSlot$pickupLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickupLocation
     */
    omit?: PickupLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    where?: PickupLocationWhereInput
  }

  /**
   * ServiceSlot.groups
   */
  export type ServiceSlot$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupInclude<ExtArgs> | null
    where?: FulfillmentGroupWhereInput
    orderBy?: FulfillmentGroupOrderByWithRelationInput | FulfillmentGroupOrderByWithRelationInput[]
    cursor?: FulfillmentGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FulfillmentGroupScalarFieldEnum | FulfillmentGroupScalarFieldEnum[]
  }

  /**
   * ServiceSlot without action
   */
  export type ServiceSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlot
     */
    select?: ServiceSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSlot
     */
    omit?: ServiceSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSlotInclude<ExtArgs> | null
  }


  /**
   * Model DeliverySettings
   */

  export type AggregateDeliverySettings = {
    _count: DeliverySettingsCountAggregateOutputType | null
    _avg: DeliverySettingsAvgAggregateOutputType | null
    _sum: DeliverySettingsSumAggregateOutputType | null
    _min: DeliverySettingsMinAggregateOutputType | null
    _max: DeliverySettingsMaxAggregateOutputType | null
  }

  export type DeliverySettingsAvgAggregateOutputType = {
    id: number | null
    originLat: number | null
    originLng: number | null
    maxRadiusMiles: number | null
  }

  export type DeliverySettingsSumAggregateOutputType = {
    id: number | null
    originLat: number | null
    originLng: number | null
    maxRadiusMiles: number | null
  }

  export type DeliverySettingsMinAggregateOutputType = {
    id: number | null
    originAddress: string | null
    originLat: number | null
    originLng: number | null
    maxRadiusMiles: number | null
    pricingMode: $Enums.DeliveryPricingMode | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliverySettingsMaxAggregateOutputType = {
    id: number | null
    originAddress: string | null
    originLat: number | null
    originLng: number | null
    maxRadiusMiles: number | null
    pricingMode: $Enums.DeliveryPricingMode | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliverySettingsCountAggregateOutputType = {
    id: number
    originAddress: number
    originLat: number
    originLng: number
    maxRadiusMiles: number
    feeTiers: number
    bundlePolicy: number
    pricingMode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeliverySettingsAvgAggregateInputType = {
    id?: true
    originLat?: true
    originLng?: true
    maxRadiusMiles?: true
  }

  export type DeliverySettingsSumAggregateInputType = {
    id?: true
    originLat?: true
    originLng?: true
    maxRadiusMiles?: true
  }

  export type DeliverySettingsMinAggregateInputType = {
    id?: true
    originAddress?: true
    originLat?: true
    originLng?: true
    maxRadiusMiles?: true
    pricingMode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliverySettingsMaxAggregateInputType = {
    id?: true
    originAddress?: true
    originLat?: true
    originLng?: true
    maxRadiusMiles?: true
    pricingMode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliverySettingsCountAggregateInputType = {
    id?: true
    originAddress?: true
    originLat?: true
    originLng?: true
    maxRadiusMiles?: true
    feeTiers?: true
    bundlePolicy?: true
    pricingMode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeliverySettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliverySettings to aggregate.
     */
    where?: DeliverySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliverySettings to fetch.
     */
    orderBy?: DeliverySettingsOrderByWithRelationInput | DeliverySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliverySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliverySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliverySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliverySettings
    **/
    _count?: true | DeliverySettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliverySettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliverySettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliverySettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliverySettingsMaxAggregateInputType
  }

  export type GetDeliverySettingsAggregateType<T extends DeliverySettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliverySettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliverySettings[P]>
      : GetScalarType<T[P], AggregateDeliverySettings[P]>
  }




  export type DeliverySettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliverySettingsWhereInput
    orderBy?: DeliverySettingsOrderByWithAggregationInput | DeliverySettingsOrderByWithAggregationInput[]
    by: DeliverySettingsScalarFieldEnum[] | DeliverySettingsScalarFieldEnum
    having?: DeliverySettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliverySettingsCountAggregateInputType | true
    _avg?: DeliverySettingsAvgAggregateInputType
    _sum?: DeliverySettingsSumAggregateInputType
    _min?: DeliverySettingsMinAggregateInputType
    _max?: DeliverySettingsMaxAggregateInputType
  }

  export type DeliverySettingsGroupByOutputType = {
    id: number
    originAddress: string
    originLat: number | null
    originLng: number | null
    maxRadiusMiles: number
    feeTiers: JsonValue
    bundlePolicy: JsonValue | null
    pricingMode: $Enums.DeliveryPricingMode
    createdAt: Date
    updatedAt: Date
    _count: DeliverySettingsCountAggregateOutputType | null
    _avg: DeliverySettingsAvgAggregateOutputType | null
    _sum: DeliverySettingsSumAggregateOutputType | null
    _min: DeliverySettingsMinAggregateOutputType | null
    _max: DeliverySettingsMaxAggregateOutputType | null
  }

  type GetDeliverySettingsGroupByPayload<T extends DeliverySettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliverySettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliverySettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliverySettingsGroupByOutputType[P]>
            : GetScalarType<T[P], DeliverySettingsGroupByOutputType[P]>
        }
      >
    >


  export type DeliverySettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originAddress?: boolean
    originLat?: boolean
    originLng?: boolean
    maxRadiusMiles?: boolean
    feeTiers?: boolean
    bundlePolicy?: boolean
    pricingMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deliverySettings"]>

  export type DeliverySettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originAddress?: boolean
    originLat?: boolean
    originLng?: boolean
    maxRadiusMiles?: boolean
    feeTiers?: boolean
    bundlePolicy?: boolean
    pricingMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deliverySettings"]>

  export type DeliverySettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originAddress?: boolean
    originLat?: boolean
    originLng?: boolean
    maxRadiusMiles?: boolean
    feeTiers?: boolean
    bundlePolicy?: boolean
    pricingMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deliverySettings"]>

  export type DeliverySettingsSelectScalar = {
    id?: boolean
    originAddress?: boolean
    originLat?: boolean
    originLng?: boolean
    maxRadiusMiles?: boolean
    feeTiers?: boolean
    bundlePolicy?: boolean
    pricingMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeliverySettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "originAddress" | "originLat" | "originLng" | "maxRadiusMiles" | "feeTiers" | "bundlePolicy" | "pricingMode" | "createdAt" | "updatedAt", ExtArgs["result"]["deliverySettings"]>

  export type $DeliverySettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliverySettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      originAddress: string
      originLat: number | null
      originLng: number | null
      maxRadiusMiles: number
      feeTiers: Prisma.JsonValue
      bundlePolicy: Prisma.JsonValue | null
      pricingMode: $Enums.DeliveryPricingMode
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deliverySettings"]>
    composites: {}
  }

  type DeliverySettingsGetPayload<S extends boolean | null | undefined | DeliverySettingsDefaultArgs> = $Result.GetResult<Prisma.$DeliverySettingsPayload, S>

  type DeliverySettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliverySettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliverySettingsCountAggregateInputType | true
    }

  export interface DeliverySettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliverySettings'], meta: { name: 'DeliverySettings' } }
    /**
     * Find zero or one DeliverySettings that matches the filter.
     * @param {DeliverySettingsFindUniqueArgs} args - Arguments to find a DeliverySettings
     * @example
     * // Get one DeliverySettings
     * const deliverySettings = await prisma.deliverySettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliverySettingsFindUniqueArgs>(args: SelectSubset<T, DeliverySettingsFindUniqueArgs<ExtArgs>>): Prisma__DeliverySettingsClient<$Result.GetResult<Prisma.$DeliverySettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliverySettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliverySettingsFindUniqueOrThrowArgs} args - Arguments to find a DeliverySettings
     * @example
     * // Get one DeliverySettings
     * const deliverySettings = await prisma.deliverySettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliverySettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliverySettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliverySettingsClient<$Result.GetResult<Prisma.$DeliverySettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliverySettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverySettingsFindFirstArgs} args - Arguments to find a DeliverySettings
     * @example
     * // Get one DeliverySettings
     * const deliverySettings = await prisma.deliverySettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliverySettingsFindFirstArgs>(args?: SelectSubset<T, DeliverySettingsFindFirstArgs<ExtArgs>>): Prisma__DeliverySettingsClient<$Result.GetResult<Prisma.$DeliverySettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliverySettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverySettingsFindFirstOrThrowArgs} args - Arguments to find a DeliverySettings
     * @example
     * // Get one DeliverySettings
     * const deliverySettings = await prisma.deliverySettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliverySettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliverySettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliverySettingsClient<$Result.GetResult<Prisma.$DeliverySettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliverySettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverySettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliverySettings
     * const deliverySettings = await prisma.deliverySettings.findMany()
     * 
     * // Get first 10 DeliverySettings
     * const deliverySettings = await prisma.deliverySettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliverySettingsWithIdOnly = await prisma.deliverySettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliverySettingsFindManyArgs>(args?: SelectSubset<T, DeliverySettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliverySettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliverySettings.
     * @param {DeliverySettingsCreateArgs} args - Arguments to create a DeliverySettings.
     * @example
     * // Create one DeliverySettings
     * const DeliverySettings = await prisma.deliverySettings.create({
     *   data: {
     *     // ... data to create a DeliverySettings
     *   }
     * })
     * 
     */
    create<T extends DeliverySettingsCreateArgs>(args: SelectSubset<T, DeliverySettingsCreateArgs<ExtArgs>>): Prisma__DeliverySettingsClient<$Result.GetResult<Prisma.$DeliverySettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliverySettings.
     * @param {DeliverySettingsCreateManyArgs} args - Arguments to create many DeliverySettings.
     * @example
     * // Create many DeliverySettings
     * const deliverySettings = await prisma.deliverySettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliverySettingsCreateManyArgs>(args?: SelectSubset<T, DeliverySettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliverySettings and returns the data saved in the database.
     * @param {DeliverySettingsCreateManyAndReturnArgs} args - Arguments to create many DeliverySettings.
     * @example
     * // Create many DeliverySettings
     * const deliverySettings = await prisma.deliverySettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliverySettings and only return the `id`
     * const deliverySettingsWithIdOnly = await prisma.deliverySettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliverySettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliverySettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliverySettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliverySettings.
     * @param {DeliverySettingsDeleteArgs} args - Arguments to delete one DeliverySettings.
     * @example
     * // Delete one DeliverySettings
     * const DeliverySettings = await prisma.deliverySettings.delete({
     *   where: {
     *     // ... filter to delete one DeliverySettings
     *   }
     * })
     * 
     */
    delete<T extends DeliverySettingsDeleteArgs>(args: SelectSubset<T, DeliverySettingsDeleteArgs<ExtArgs>>): Prisma__DeliverySettingsClient<$Result.GetResult<Prisma.$DeliverySettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliverySettings.
     * @param {DeliverySettingsUpdateArgs} args - Arguments to update one DeliverySettings.
     * @example
     * // Update one DeliverySettings
     * const deliverySettings = await prisma.deliverySettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliverySettingsUpdateArgs>(args: SelectSubset<T, DeliverySettingsUpdateArgs<ExtArgs>>): Prisma__DeliverySettingsClient<$Result.GetResult<Prisma.$DeliverySettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliverySettings.
     * @param {DeliverySettingsDeleteManyArgs} args - Arguments to filter DeliverySettings to delete.
     * @example
     * // Delete a few DeliverySettings
     * const { count } = await prisma.deliverySettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliverySettingsDeleteManyArgs>(args?: SelectSubset<T, DeliverySettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliverySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverySettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliverySettings
     * const deliverySettings = await prisma.deliverySettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliverySettingsUpdateManyArgs>(args: SelectSubset<T, DeliverySettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliverySettings and returns the data updated in the database.
     * @param {DeliverySettingsUpdateManyAndReturnArgs} args - Arguments to update many DeliverySettings.
     * @example
     * // Update many DeliverySettings
     * const deliverySettings = await prisma.deliverySettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliverySettings and only return the `id`
     * const deliverySettingsWithIdOnly = await prisma.deliverySettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliverySettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliverySettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliverySettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliverySettings.
     * @param {DeliverySettingsUpsertArgs} args - Arguments to update or create a DeliverySettings.
     * @example
     * // Update or create a DeliverySettings
     * const deliverySettings = await prisma.deliverySettings.upsert({
     *   create: {
     *     // ... data to create a DeliverySettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliverySettings we want to update
     *   }
     * })
     */
    upsert<T extends DeliverySettingsUpsertArgs>(args: SelectSubset<T, DeliverySettingsUpsertArgs<ExtArgs>>): Prisma__DeliverySettingsClient<$Result.GetResult<Prisma.$DeliverySettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliverySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverySettingsCountArgs} args - Arguments to filter DeliverySettings to count.
     * @example
     * // Count the number of DeliverySettings
     * const count = await prisma.deliverySettings.count({
     *   where: {
     *     // ... the filter for the DeliverySettings we want to count
     *   }
     * })
    **/
    count<T extends DeliverySettingsCountArgs>(
      args?: Subset<T, DeliverySettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliverySettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliverySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverySettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliverySettingsAggregateArgs>(args: Subset<T, DeliverySettingsAggregateArgs>): Prisma.PrismaPromise<GetDeliverySettingsAggregateType<T>>

    /**
     * Group by DeliverySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverySettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliverySettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliverySettingsGroupByArgs['orderBy'] }
        : { orderBy?: DeliverySettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliverySettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliverySettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliverySettings model
   */
  readonly fields: DeliverySettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliverySettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliverySettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliverySettings model
   */
  interface DeliverySettingsFieldRefs {
    readonly id: FieldRef<"DeliverySettings", 'Int'>
    readonly originAddress: FieldRef<"DeliverySettings", 'String'>
    readonly originLat: FieldRef<"DeliverySettings", 'Float'>
    readonly originLng: FieldRef<"DeliverySettings", 'Float'>
    readonly maxRadiusMiles: FieldRef<"DeliverySettings", 'Float'>
    readonly feeTiers: FieldRef<"DeliverySettings", 'Json'>
    readonly bundlePolicy: FieldRef<"DeliverySettings", 'Json'>
    readonly pricingMode: FieldRef<"DeliverySettings", 'DeliveryPricingMode'>
    readonly createdAt: FieldRef<"DeliverySettings", 'DateTime'>
    readonly updatedAt: FieldRef<"DeliverySettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliverySettings findUnique
   */
  export type DeliverySettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliverySettings
     */
    select?: DeliverySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliverySettings
     */
    omit?: DeliverySettingsOmit<ExtArgs> | null
    /**
     * Filter, which DeliverySettings to fetch.
     */
    where: DeliverySettingsWhereUniqueInput
  }

  /**
   * DeliverySettings findUniqueOrThrow
   */
  export type DeliverySettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliverySettings
     */
    select?: DeliverySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliverySettings
     */
    omit?: DeliverySettingsOmit<ExtArgs> | null
    /**
     * Filter, which DeliverySettings to fetch.
     */
    where: DeliverySettingsWhereUniqueInput
  }

  /**
   * DeliverySettings findFirst
   */
  export type DeliverySettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliverySettings
     */
    select?: DeliverySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliverySettings
     */
    omit?: DeliverySettingsOmit<ExtArgs> | null
    /**
     * Filter, which DeliverySettings to fetch.
     */
    where?: DeliverySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliverySettings to fetch.
     */
    orderBy?: DeliverySettingsOrderByWithRelationInput | DeliverySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliverySettings.
     */
    cursor?: DeliverySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliverySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliverySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliverySettings.
     */
    distinct?: DeliverySettingsScalarFieldEnum | DeliverySettingsScalarFieldEnum[]
  }

  /**
   * DeliverySettings findFirstOrThrow
   */
  export type DeliverySettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliverySettings
     */
    select?: DeliverySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliverySettings
     */
    omit?: DeliverySettingsOmit<ExtArgs> | null
    /**
     * Filter, which DeliverySettings to fetch.
     */
    where?: DeliverySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliverySettings to fetch.
     */
    orderBy?: DeliverySettingsOrderByWithRelationInput | DeliverySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliverySettings.
     */
    cursor?: DeliverySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliverySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliverySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliverySettings.
     */
    distinct?: DeliverySettingsScalarFieldEnum | DeliverySettingsScalarFieldEnum[]
  }

  /**
   * DeliverySettings findMany
   */
  export type DeliverySettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliverySettings
     */
    select?: DeliverySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliverySettings
     */
    omit?: DeliverySettingsOmit<ExtArgs> | null
    /**
     * Filter, which DeliverySettings to fetch.
     */
    where?: DeliverySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliverySettings to fetch.
     */
    orderBy?: DeliverySettingsOrderByWithRelationInput | DeliverySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliverySettings.
     */
    cursor?: DeliverySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliverySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliverySettings.
     */
    skip?: number
    distinct?: DeliverySettingsScalarFieldEnum | DeliverySettingsScalarFieldEnum[]
  }

  /**
   * DeliverySettings create
   */
  export type DeliverySettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliverySettings
     */
    select?: DeliverySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliverySettings
     */
    omit?: DeliverySettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a DeliverySettings.
     */
    data: XOR<DeliverySettingsCreateInput, DeliverySettingsUncheckedCreateInput>
  }

  /**
   * DeliverySettings createMany
   */
  export type DeliverySettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliverySettings.
     */
    data: DeliverySettingsCreateManyInput | DeliverySettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliverySettings createManyAndReturn
   */
  export type DeliverySettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliverySettings
     */
    select?: DeliverySettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliverySettings
     */
    omit?: DeliverySettingsOmit<ExtArgs> | null
    /**
     * The data used to create many DeliverySettings.
     */
    data: DeliverySettingsCreateManyInput | DeliverySettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliverySettings update
   */
  export type DeliverySettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliverySettings
     */
    select?: DeliverySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliverySettings
     */
    omit?: DeliverySettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a DeliverySettings.
     */
    data: XOR<DeliverySettingsUpdateInput, DeliverySettingsUncheckedUpdateInput>
    /**
     * Choose, which DeliverySettings to update.
     */
    where: DeliverySettingsWhereUniqueInput
  }

  /**
   * DeliverySettings updateMany
   */
  export type DeliverySettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliverySettings.
     */
    data: XOR<DeliverySettingsUpdateManyMutationInput, DeliverySettingsUncheckedUpdateManyInput>
    /**
     * Filter which DeliverySettings to update
     */
    where?: DeliverySettingsWhereInput
    /**
     * Limit how many DeliverySettings to update.
     */
    limit?: number
  }

  /**
   * DeliverySettings updateManyAndReturn
   */
  export type DeliverySettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliverySettings
     */
    select?: DeliverySettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliverySettings
     */
    omit?: DeliverySettingsOmit<ExtArgs> | null
    /**
     * The data used to update DeliverySettings.
     */
    data: XOR<DeliverySettingsUpdateManyMutationInput, DeliverySettingsUncheckedUpdateManyInput>
    /**
     * Filter which DeliverySettings to update
     */
    where?: DeliverySettingsWhereInput
    /**
     * Limit how many DeliverySettings to update.
     */
    limit?: number
  }

  /**
   * DeliverySettings upsert
   */
  export type DeliverySettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliverySettings
     */
    select?: DeliverySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliverySettings
     */
    omit?: DeliverySettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the DeliverySettings to update in case it exists.
     */
    where: DeliverySettingsWhereUniqueInput
    /**
     * In case the DeliverySettings found by the `where` argument doesn't exist, create a new DeliverySettings with this data.
     */
    create: XOR<DeliverySettingsCreateInput, DeliverySettingsUncheckedCreateInput>
    /**
     * In case the DeliverySettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliverySettingsUpdateInput, DeliverySettingsUncheckedUpdateInput>
  }

  /**
   * DeliverySettings delete
   */
  export type DeliverySettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliverySettings
     */
    select?: DeliverySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliverySettings
     */
    omit?: DeliverySettingsOmit<ExtArgs> | null
    /**
     * Filter which DeliverySettings to delete.
     */
    where: DeliverySettingsWhereUniqueInput
  }

  /**
   * DeliverySettings deleteMany
   */
  export type DeliverySettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliverySettings to delete
     */
    where?: DeliverySettingsWhereInput
    /**
     * Limit how many DeliverySettings to delete.
     */
    limit?: number
  }

  /**
   * DeliverySettings without action
   */
  export type DeliverySettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliverySettings
     */
    select?: DeliverySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliverySettings
     */
    omit?: DeliverySettingsOmit<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    createdByUserId: number | null
    pickupLocationId: number | null
    deliveryAddressId: number | null
    deliveryDistanceMiles: number | null
    subtotalCents: number | null
    adjustmentsCents: number | null
    totalCents: number | null
    refundedCents: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    userId: number | null
    createdByUserId: number | null
    pickupLocationId: number | null
    deliveryAddressId: number | null
    deliveryDistanceMiles: number | null
    subtotalCents: number | null
    adjustmentsCents: number | null
    totalCents: number | null
    refundedCents: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    userId: number | null
    createdByUserId: number | null
    source: $Enums.OrderSource | null
    sourceRef: string | null
    currency: string | null
    checkoutStatus: $Enums.OrderCheckoutStatus | null
    deliveryPricingMode: $Enums.DeliveryPricingMode | null
    fulfillmentType: $Enums.FulfillmentType | null
    pickupLocationId: number | null
    deliveryAddressId: number | null
    deliveryDistanceMiles: number | null
    customerName: string | null
    customerEmail: string | null
    customerPhone: string | null
    customerNotes: string | null
    internalNotes: string | null
    subtotalCents: number | null
    adjustmentsCents: number | null
    totalCents: number | null
    refundedCents: number | null
    placedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    createdByUserId: number | null
    source: $Enums.OrderSource | null
    sourceRef: string | null
    currency: string | null
    checkoutStatus: $Enums.OrderCheckoutStatus | null
    deliveryPricingMode: $Enums.DeliveryPricingMode | null
    fulfillmentType: $Enums.FulfillmentType | null
    pickupLocationId: number | null
    deliveryAddressId: number | null
    deliveryDistanceMiles: number | null
    customerName: string | null
    customerEmail: string | null
    customerPhone: string | null
    customerNotes: string | null
    internalNotes: string | null
    subtotalCents: number | null
    adjustmentsCents: number | null
    totalCents: number | null
    refundedCents: number | null
    placedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    userId: number
    createdByUserId: number
    source: number
    sourceRef: number
    currency: number
    checkoutStatus: number
    deliveryPricingMode: number
    fulfillmentType: number
    pickupLocationId: number
    deliveryAddressId: number
    deliveryDistanceMiles: number
    customerName: number
    customerEmail: number
    customerPhone: number
    customerNotes: number
    internalNotes: number
    subtotalCents: number
    adjustmentsCents: number
    totalCents: number
    refundedCents: number
    placedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    userId?: true
    createdByUserId?: true
    pickupLocationId?: true
    deliveryAddressId?: true
    deliveryDistanceMiles?: true
    subtotalCents?: true
    adjustmentsCents?: true
    totalCents?: true
    refundedCents?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    userId?: true
    createdByUserId?: true
    pickupLocationId?: true
    deliveryAddressId?: true
    deliveryDistanceMiles?: true
    subtotalCents?: true
    adjustmentsCents?: true
    totalCents?: true
    refundedCents?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    userId?: true
    createdByUserId?: true
    source?: true
    sourceRef?: true
    currency?: true
    checkoutStatus?: true
    deliveryPricingMode?: true
    fulfillmentType?: true
    pickupLocationId?: true
    deliveryAddressId?: true
    deliveryDistanceMiles?: true
    customerName?: true
    customerEmail?: true
    customerPhone?: true
    customerNotes?: true
    internalNotes?: true
    subtotalCents?: true
    adjustmentsCents?: true
    totalCents?: true
    refundedCents?: true
    placedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    userId?: true
    createdByUserId?: true
    source?: true
    sourceRef?: true
    currency?: true
    checkoutStatus?: true
    deliveryPricingMode?: true
    fulfillmentType?: true
    pickupLocationId?: true
    deliveryAddressId?: true
    deliveryDistanceMiles?: true
    customerName?: true
    customerEmail?: true
    customerPhone?: true
    customerNotes?: true
    internalNotes?: true
    subtotalCents?: true
    adjustmentsCents?: true
    totalCents?: true
    refundedCents?: true
    placedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    userId?: true
    createdByUserId?: true
    source?: true
    sourceRef?: true
    currency?: true
    checkoutStatus?: true
    deliveryPricingMode?: true
    fulfillmentType?: true
    pickupLocationId?: true
    deliveryAddressId?: true
    deliveryDistanceMiles?: true
    customerName?: true
    customerEmail?: true
    customerPhone?: true
    customerNotes?: true
    internalNotes?: true
    subtotalCents?: true
    adjustmentsCents?: true
    totalCents?: true
    refundedCents?: true
    placedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    userId: number | null
    createdByUserId: number | null
    source: $Enums.OrderSource
    sourceRef: string | null
    currency: string
    checkoutStatus: $Enums.OrderCheckoutStatus
    deliveryPricingMode: $Enums.DeliveryPricingMode
    fulfillmentType: $Enums.FulfillmentType | null
    pickupLocationId: number | null
    deliveryAddressId: number | null
    deliveryDistanceMiles: number | null
    customerName: string | null
    customerEmail: string | null
    customerPhone: string | null
    customerNotes: string | null
    internalNotes: string | null
    subtotalCents: number
    adjustmentsCents: number
    totalCents: number
    refundedCents: number
    placedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdByUserId?: boolean
    source?: boolean
    sourceRef?: boolean
    currency?: boolean
    checkoutStatus?: boolean
    deliveryPricingMode?: boolean
    fulfillmentType?: boolean
    pickupLocationId?: boolean
    deliveryAddressId?: boolean
    deliveryDistanceMiles?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhone?: boolean
    customerNotes?: boolean
    internalNotes?: boolean
    subtotalCents?: boolean
    adjustmentsCents?: boolean
    totalCents?: boolean
    refundedCents?: boolean
    placedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Order$userArgs<ExtArgs>
    createdBy?: boolean | Order$createdByArgs<ExtArgs>
    pickupLocation?: boolean | Order$pickupLocationArgs<ExtArgs>
    deliveryAddress?: boolean | Order$deliveryAddressArgs<ExtArgs>
    groups?: boolean | Order$groupsArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    adjustments?: boolean | Order$adjustmentsArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    events?: boolean | Order$eventsArgs<ExtArgs>
    promoRedemptions?: boolean | Order$promoRedemptionsArgs<ExtArgs>
    capacityHolds?: boolean | Order$capacityHoldsArgs<ExtArgs>
    rewardTransactions?: boolean | Order$rewardTransactionsArgs<ExtArgs>
    reviews?: boolean | Order$reviewsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdByUserId?: boolean
    source?: boolean
    sourceRef?: boolean
    currency?: boolean
    checkoutStatus?: boolean
    deliveryPricingMode?: boolean
    fulfillmentType?: boolean
    pickupLocationId?: boolean
    deliveryAddressId?: boolean
    deliveryDistanceMiles?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhone?: boolean
    customerNotes?: boolean
    internalNotes?: boolean
    subtotalCents?: boolean
    adjustmentsCents?: boolean
    totalCents?: boolean
    refundedCents?: boolean
    placedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Order$userArgs<ExtArgs>
    createdBy?: boolean | Order$createdByArgs<ExtArgs>
    pickupLocation?: boolean | Order$pickupLocationArgs<ExtArgs>
    deliveryAddress?: boolean | Order$deliveryAddressArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdByUserId?: boolean
    source?: boolean
    sourceRef?: boolean
    currency?: boolean
    checkoutStatus?: boolean
    deliveryPricingMode?: boolean
    fulfillmentType?: boolean
    pickupLocationId?: boolean
    deliveryAddressId?: boolean
    deliveryDistanceMiles?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhone?: boolean
    customerNotes?: boolean
    internalNotes?: boolean
    subtotalCents?: boolean
    adjustmentsCents?: boolean
    totalCents?: boolean
    refundedCents?: boolean
    placedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Order$userArgs<ExtArgs>
    createdBy?: boolean | Order$createdByArgs<ExtArgs>
    pickupLocation?: boolean | Order$pickupLocationArgs<ExtArgs>
    deliveryAddress?: boolean | Order$deliveryAddressArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    userId?: boolean
    createdByUserId?: boolean
    source?: boolean
    sourceRef?: boolean
    currency?: boolean
    checkoutStatus?: boolean
    deliveryPricingMode?: boolean
    fulfillmentType?: boolean
    pickupLocationId?: boolean
    deliveryAddressId?: boolean
    deliveryDistanceMiles?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhone?: boolean
    customerNotes?: boolean
    internalNotes?: boolean
    subtotalCents?: boolean
    adjustmentsCents?: boolean
    totalCents?: boolean
    refundedCents?: boolean
    placedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdByUserId" | "source" | "sourceRef" | "currency" | "checkoutStatus" | "deliveryPricingMode" | "fulfillmentType" | "pickupLocationId" | "deliveryAddressId" | "deliveryDistanceMiles" | "customerName" | "customerEmail" | "customerPhone" | "customerNotes" | "internalNotes" | "subtotalCents" | "adjustmentsCents" | "totalCents" | "refundedCents" | "placedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Order$userArgs<ExtArgs>
    createdBy?: boolean | Order$createdByArgs<ExtArgs>
    pickupLocation?: boolean | Order$pickupLocationArgs<ExtArgs>
    deliveryAddress?: boolean | Order$deliveryAddressArgs<ExtArgs>
    groups?: boolean | Order$groupsArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    adjustments?: boolean | Order$adjustmentsArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    events?: boolean | Order$eventsArgs<ExtArgs>
    promoRedemptions?: boolean | Order$promoRedemptionsArgs<ExtArgs>
    capacityHolds?: boolean | Order$capacityHoldsArgs<ExtArgs>
    rewardTransactions?: boolean | Order$rewardTransactionsArgs<ExtArgs>
    reviews?: boolean | Order$reviewsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Order$userArgs<ExtArgs>
    createdBy?: boolean | Order$createdByArgs<ExtArgs>
    pickupLocation?: boolean | Order$pickupLocationArgs<ExtArgs>
    deliveryAddress?: boolean | Order$deliveryAddressArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Order$userArgs<ExtArgs>
    createdBy?: boolean | Order$createdByArgs<ExtArgs>
    pickupLocation?: boolean | Order$pickupLocationArgs<ExtArgs>
    deliveryAddress?: boolean | Order$deliveryAddressArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      pickupLocation: Prisma.$PickupLocationPayload<ExtArgs> | null
      deliveryAddress: Prisma.$AddressPayload<ExtArgs> | null
      groups: Prisma.$FulfillmentGroupPayload<ExtArgs>[]
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      adjustments: Prisma.$OrderAdjustmentPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      events: Prisma.$OrderEventPayload<ExtArgs>[]
      promoRedemptions: Prisma.$PromotionRedemptionPayload<ExtArgs>[]
      capacityHolds: Prisma.$CapacityHoldPayload<ExtArgs>[]
      rewardTransactions: Prisma.$RewardTransactionPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      createdByUserId: number | null
      source: $Enums.OrderSource
      sourceRef: string | null
      currency: string
      checkoutStatus: $Enums.OrderCheckoutStatus
      deliveryPricingMode: $Enums.DeliveryPricingMode
      fulfillmentType: $Enums.FulfillmentType | null
      pickupLocationId: number | null
      deliveryAddressId: number | null
      deliveryDistanceMiles: number | null
      customerName: string | null
      customerEmail: string | null
      customerPhone: string | null
      customerNotes: string | null
      internalNotes: string | null
      subtotalCents: number
      adjustmentsCents: number
      totalCents: number
      refundedCents: number
      placedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Order$userArgs<ExtArgs> = {}>(args?: Subset<T, Order$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Order$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Order$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pickupLocation<T extends Order$pickupLocationArgs<ExtArgs> = {}>(args?: Subset<T, Order$pickupLocationArgs<ExtArgs>>): Prisma__PickupLocationClient<$Result.GetResult<Prisma.$PickupLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deliveryAddress<T extends Order$deliveryAddressArgs<ExtArgs> = {}>(args?: Subset<T, Order$deliveryAddressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    groups<T extends Order$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Order$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adjustments<T extends Order$adjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$adjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Order$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends Order$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Order$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promoRedemptions<T extends Order$promoRedemptionsArgs<ExtArgs> = {}>(args?: Subset<T, Order$promoRedemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    capacityHolds<T extends Order$capacityHoldsArgs<ExtArgs> = {}>(args?: Subset<T, Order$capacityHoldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapacityHoldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rewardTransactions<T extends Order$rewardTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Order$rewardTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Order$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Order$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly userId: FieldRef<"Order", 'Int'>
    readonly createdByUserId: FieldRef<"Order", 'Int'>
    readonly source: FieldRef<"Order", 'OrderSource'>
    readonly sourceRef: FieldRef<"Order", 'String'>
    readonly currency: FieldRef<"Order", 'String'>
    readonly checkoutStatus: FieldRef<"Order", 'OrderCheckoutStatus'>
    readonly deliveryPricingMode: FieldRef<"Order", 'DeliveryPricingMode'>
    readonly fulfillmentType: FieldRef<"Order", 'FulfillmentType'>
    readonly pickupLocationId: FieldRef<"Order", 'Int'>
    readonly deliveryAddressId: FieldRef<"Order", 'Int'>
    readonly deliveryDistanceMiles: FieldRef<"Order", 'Float'>
    readonly customerName: FieldRef<"Order", 'String'>
    readonly customerEmail: FieldRef<"Order", 'String'>
    readonly customerPhone: FieldRef<"Order", 'String'>
    readonly customerNotes: FieldRef<"Order", 'String'>
    readonly internalNotes: FieldRef<"Order", 'String'>
    readonly subtotalCents: FieldRef<"Order", 'Int'>
    readonly adjustmentsCents: FieldRef<"Order", 'Int'>
    readonly totalCents: FieldRef<"Order", 'Int'>
    readonly refundedCents: FieldRef<"Order", 'Int'>
    readonly placedAt: FieldRef<"Order", 'DateTime'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.user
   */
  export type Order$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Order.createdBy
   */
  export type Order$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Order.pickupLocation
   */
  export type Order$pickupLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupLocation
     */
    select?: PickupLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PickupLocation
     */
    omit?: PickupLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupLocationInclude<ExtArgs> | null
    where?: PickupLocationWhereInput
  }

  /**
   * Order.deliveryAddress
   */
  export type Order$deliveryAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Order.groups
   */
  export type Order$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupInclude<ExtArgs> | null
    where?: FulfillmentGroupWhereInput
    orderBy?: FulfillmentGroupOrderByWithRelationInput | FulfillmentGroupOrderByWithRelationInput[]
    cursor?: FulfillmentGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FulfillmentGroupScalarFieldEnum | FulfillmentGroupScalarFieldEnum[]
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.adjustments
   */
  export type Order$adjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAdjustment
     */
    select?: OrderAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAdjustment
     */
    omit?: OrderAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAdjustmentInclude<ExtArgs> | null
    where?: OrderAdjustmentWhereInput
    orderBy?: OrderAdjustmentOrderByWithRelationInput | OrderAdjustmentOrderByWithRelationInput[]
    cursor?: OrderAdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderAdjustmentScalarFieldEnum | OrderAdjustmentScalarFieldEnum[]
  }

  /**
   * Order.payments
   */
  export type Order$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Order.events
   */
  export type Order$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderEvent
     */
    select?: OrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderEvent
     */
    omit?: OrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderEventInclude<ExtArgs> | null
    where?: OrderEventWhereInput
    orderBy?: OrderEventOrderByWithRelationInput | OrderEventOrderByWithRelationInput[]
    cursor?: OrderEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderEventScalarFieldEnum | OrderEventScalarFieldEnum[]
  }

  /**
   * Order.promoRedemptions
   */
  export type Order$promoRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    where?: PromotionRedemptionWhereInput
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    cursor?: PromotionRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * Order.capacityHolds
   */
  export type Order$capacityHoldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapacityHold
     */
    select?: CapacityHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapacityHold
     */
    omit?: CapacityHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapacityHoldInclude<ExtArgs> | null
    where?: CapacityHoldWhereInput
    orderBy?: CapacityHoldOrderByWithRelationInput | CapacityHoldOrderByWithRelationInput[]
    cursor?: CapacityHoldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CapacityHoldScalarFieldEnum | CapacityHoldScalarFieldEnum[]
  }

  /**
   * Order.rewardTransactions
   */
  export type Order$rewardTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardTransaction
     */
    omit?: RewardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    where?: RewardTransactionWhereInput
    orderBy?: RewardTransactionOrderByWithRelationInput | RewardTransactionOrderByWithRelationInput[]
    cursor?: RewardTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardTransactionScalarFieldEnum | RewardTransactionScalarFieldEnum[]
  }

  /**
   * Order.reviews
   */
  export type Order$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model FulfillmentGroup
   */

  export type AggregateFulfillmentGroup = {
    _count: FulfillmentGroupCountAggregateOutputType | null
    _avg: FulfillmentGroupAvgAggregateOutputType | null
    _sum: FulfillmentGroupSumAggregateOutputType | null
    _min: FulfillmentGroupMinAggregateOutputType | null
    _max: FulfillmentGroupMaxAggregateOutputType | null
  }

  export type FulfillmentGroupAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    serviceDayId: number | null
    serviceSlotId: number | null
    sequence: number | null
  }

  export type FulfillmentGroupSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    serviceDayId: number | null
    serviceSlotId: number | null
    sequence: number | null
  }

  export type FulfillmentGroupMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    serviceDayId: number | null
    serviceSlotId: number | null
    status: $Enums.FulfillmentGroupStatus | null
    sequence: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FulfillmentGroupMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    serviceDayId: number | null
    serviceSlotId: number | null
    status: $Enums.FulfillmentGroupStatus | null
    sequence: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FulfillmentGroupCountAggregateOutputType = {
    id: number
    orderId: number
    serviceDayId: number
    serviceSlotId: number
    status: number
    sequence: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FulfillmentGroupAvgAggregateInputType = {
    id?: true
    orderId?: true
    serviceDayId?: true
    serviceSlotId?: true
    sequence?: true
  }

  export type FulfillmentGroupSumAggregateInputType = {
    id?: true
    orderId?: true
    serviceDayId?: true
    serviceSlotId?: true
    sequence?: true
  }

  export type FulfillmentGroupMinAggregateInputType = {
    id?: true
    orderId?: true
    serviceDayId?: true
    serviceSlotId?: true
    status?: true
    sequence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FulfillmentGroupMaxAggregateInputType = {
    id?: true
    orderId?: true
    serviceDayId?: true
    serviceSlotId?: true
    status?: true
    sequence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FulfillmentGroupCountAggregateInputType = {
    id?: true
    orderId?: true
    serviceDayId?: true
    serviceSlotId?: true
    status?: true
    sequence?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FulfillmentGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FulfillmentGroup to aggregate.
     */
    where?: FulfillmentGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FulfillmentGroups to fetch.
     */
    orderBy?: FulfillmentGroupOrderByWithRelationInput | FulfillmentGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FulfillmentGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FulfillmentGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FulfillmentGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FulfillmentGroups
    **/
    _count?: true | FulfillmentGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FulfillmentGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FulfillmentGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FulfillmentGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FulfillmentGroupMaxAggregateInputType
  }

  export type GetFulfillmentGroupAggregateType<T extends FulfillmentGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateFulfillmentGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFulfillmentGroup[P]>
      : GetScalarType<T[P], AggregateFulfillmentGroup[P]>
  }




  export type FulfillmentGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FulfillmentGroupWhereInput
    orderBy?: FulfillmentGroupOrderByWithAggregationInput | FulfillmentGroupOrderByWithAggregationInput[]
    by: FulfillmentGroupScalarFieldEnum[] | FulfillmentGroupScalarFieldEnum
    having?: FulfillmentGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FulfillmentGroupCountAggregateInputType | true
    _avg?: FulfillmentGroupAvgAggregateInputType
    _sum?: FulfillmentGroupSumAggregateInputType
    _min?: FulfillmentGroupMinAggregateInputType
    _max?: FulfillmentGroupMaxAggregateInputType
  }

  export type FulfillmentGroupGroupByOutputType = {
    id: number
    orderId: number
    serviceDayId: number
    serviceSlotId: number | null
    status: $Enums.FulfillmentGroupStatus
    sequence: number
    createdAt: Date
    updatedAt: Date
    _count: FulfillmentGroupCountAggregateOutputType | null
    _avg: FulfillmentGroupAvgAggregateOutputType | null
    _sum: FulfillmentGroupSumAggregateOutputType | null
    _min: FulfillmentGroupMinAggregateOutputType | null
    _max: FulfillmentGroupMaxAggregateOutputType | null
  }

  type GetFulfillmentGroupGroupByPayload<T extends FulfillmentGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FulfillmentGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FulfillmentGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FulfillmentGroupGroupByOutputType[P]>
            : GetScalarType<T[P], FulfillmentGroupGroupByOutputType[P]>
        }
      >
    >


  export type FulfillmentGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    serviceDayId?: boolean
    serviceSlotId?: boolean
    status?: boolean
    sequence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
    serviceSlot?: boolean | FulfillmentGroup$serviceSlotArgs<ExtArgs>
    items?: boolean | FulfillmentGroup$itemsArgs<ExtArgs>
    adjustments?: boolean | FulfillmentGroup$adjustmentsArgs<ExtArgs>
    events?: boolean | FulfillmentGroup$eventsArgs<ExtArgs>
    _count?: boolean | FulfillmentGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fulfillmentGroup"]>

  export type FulfillmentGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    serviceDayId?: boolean
    serviceSlotId?: boolean
    status?: boolean
    sequence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
    serviceSlot?: boolean | FulfillmentGroup$serviceSlotArgs<ExtArgs>
  }, ExtArgs["result"]["fulfillmentGroup"]>

  export type FulfillmentGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    serviceDayId?: boolean
    serviceSlotId?: boolean
    status?: boolean
    sequence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
    serviceSlot?: boolean | FulfillmentGroup$serviceSlotArgs<ExtArgs>
  }, ExtArgs["result"]["fulfillmentGroup"]>

  export type FulfillmentGroupSelectScalar = {
    id?: boolean
    orderId?: boolean
    serviceDayId?: boolean
    serviceSlotId?: boolean
    status?: boolean
    sequence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FulfillmentGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "serviceDayId" | "serviceSlotId" | "status" | "sequence" | "createdAt" | "updatedAt", ExtArgs["result"]["fulfillmentGroup"]>
  export type FulfillmentGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
    serviceSlot?: boolean | FulfillmentGroup$serviceSlotArgs<ExtArgs>
    items?: boolean | FulfillmentGroup$itemsArgs<ExtArgs>
    adjustments?: boolean | FulfillmentGroup$adjustmentsArgs<ExtArgs>
    events?: boolean | FulfillmentGroup$eventsArgs<ExtArgs>
    _count?: boolean | FulfillmentGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FulfillmentGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
    serviceSlot?: boolean | FulfillmentGroup$serviceSlotArgs<ExtArgs>
  }
  export type FulfillmentGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    serviceDay?: boolean | ServiceDayDefaultArgs<ExtArgs>
    serviceSlot?: boolean | FulfillmentGroup$serviceSlotArgs<ExtArgs>
  }

  export type $FulfillmentGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FulfillmentGroup"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      serviceDay: Prisma.$ServiceDayPayload<ExtArgs>
      serviceSlot: Prisma.$ServiceSlotPayload<ExtArgs> | null
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      adjustments: Prisma.$OrderAdjustmentPayload<ExtArgs>[]
      events: Prisma.$OrderEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      serviceDayId: number
      serviceSlotId: number | null
      status: $Enums.FulfillmentGroupStatus
      sequence: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fulfillmentGroup"]>
    composites: {}
  }

  type FulfillmentGroupGetPayload<S extends boolean | null | undefined | FulfillmentGroupDefaultArgs> = $Result.GetResult<Prisma.$FulfillmentGroupPayload, S>

  type FulfillmentGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FulfillmentGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FulfillmentGroupCountAggregateInputType | true
    }

  export interface FulfillmentGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FulfillmentGroup'], meta: { name: 'FulfillmentGroup' } }
    /**
     * Find zero or one FulfillmentGroup that matches the filter.
     * @param {FulfillmentGroupFindUniqueArgs} args - Arguments to find a FulfillmentGroup
     * @example
     * // Get one FulfillmentGroup
     * const fulfillmentGroup = await prisma.fulfillmentGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FulfillmentGroupFindUniqueArgs>(args: SelectSubset<T, FulfillmentGroupFindUniqueArgs<ExtArgs>>): Prisma__FulfillmentGroupClient<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FulfillmentGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FulfillmentGroupFindUniqueOrThrowArgs} args - Arguments to find a FulfillmentGroup
     * @example
     * // Get one FulfillmentGroup
     * const fulfillmentGroup = await prisma.fulfillmentGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FulfillmentGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, FulfillmentGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FulfillmentGroupClient<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FulfillmentGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FulfillmentGroupFindFirstArgs} args - Arguments to find a FulfillmentGroup
     * @example
     * // Get one FulfillmentGroup
     * const fulfillmentGroup = await prisma.fulfillmentGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FulfillmentGroupFindFirstArgs>(args?: SelectSubset<T, FulfillmentGroupFindFirstArgs<ExtArgs>>): Prisma__FulfillmentGroupClient<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FulfillmentGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FulfillmentGroupFindFirstOrThrowArgs} args - Arguments to find a FulfillmentGroup
     * @example
     * // Get one FulfillmentGroup
     * const fulfillmentGroup = await prisma.fulfillmentGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FulfillmentGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, FulfillmentGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__FulfillmentGroupClient<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FulfillmentGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FulfillmentGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FulfillmentGroups
     * const fulfillmentGroups = await prisma.fulfillmentGroup.findMany()
     * 
     * // Get first 10 FulfillmentGroups
     * const fulfillmentGroups = await prisma.fulfillmentGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fulfillmentGroupWithIdOnly = await prisma.fulfillmentGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FulfillmentGroupFindManyArgs>(args?: SelectSubset<T, FulfillmentGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FulfillmentGroup.
     * @param {FulfillmentGroupCreateArgs} args - Arguments to create a FulfillmentGroup.
     * @example
     * // Create one FulfillmentGroup
     * const FulfillmentGroup = await prisma.fulfillmentGroup.create({
     *   data: {
     *     // ... data to create a FulfillmentGroup
     *   }
     * })
     * 
     */
    create<T extends FulfillmentGroupCreateArgs>(args: SelectSubset<T, FulfillmentGroupCreateArgs<ExtArgs>>): Prisma__FulfillmentGroupClient<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FulfillmentGroups.
     * @param {FulfillmentGroupCreateManyArgs} args - Arguments to create many FulfillmentGroups.
     * @example
     * // Create many FulfillmentGroups
     * const fulfillmentGroup = await prisma.fulfillmentGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FulfillmentGroupCreateManyArgs>(args?: SelectSubset<T, FulfillmentGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FulfillmentGroups and returns the data saved in the database.
     * @param {FulfillmentGroupCreateManyAndReturnArgs} args - Arguments to create many FulfillmentGroups.
     * @example
     * // Create many FulfillmentGroups
     * const fulfillmentGroup = await prisma.fulfillmentGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FulfillmentGroups and only return the `id`
     * const fulfillmentGroupWithIdOnly = await prisma.fulfillmentGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FulfillmentGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, FulfillmentGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FulfillmentGroup.
     * @param {FulfillmentGroupDeleteArgs} args - Arguments to delete one FulfillmentGroup.
     * @example
     * // Delete one FulfillmentGroup
     * const FulfillmentGroup = await prisma.fulfillmentGroup.delete({
     *   where: {
     *     // ... filter to delete one FulfillmentGroup
     *   }
     * })
     * 
     */
    delete<T extends FulfillmentGroupDeleteArgs>(args: SelectSubset<T, FulfillmentGroupDeleteArgs<ExtArgs>>): Prisma__FulfillmentGroupClient<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FulfillmentGroup.
     * @param {FulfillmentGroupUpdateArgs} args - Arguments to update one FulfillmentGroup.
     * @example
     * // Update one FulfillmentGroup
     * const fulfillmentGroup = await prisma.fulfillmentGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FulfillmentGroupUpdateArgs>(args: SelectSubset<T, FulfillmentGroupUpdateArgs<ExtArgs>>): Prisma__FulfillmentGroupClient<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FulfillmentGroups.
     * @param {FulfillmentGroupDeleteManyArgs} args - Arguments to filter FulfillmentGroups to delete.
     * @example
     * // Delete a few FulfillmentGroups
     * const { count } = await prisma.fulfillmentGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FulfillmentGroupDeleteManyArgs>(args?: SelectSubset<T, FulfillmentGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FulfillmentGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FulfillmentGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FulfillmentGroups
     * const fulfillmentGroup = await prisma.fulfillmentGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FulfillmentGroupUpdateManyArgs>(args: SelectSubset<T, FulfillmentGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FulfillmentGroups and returns the data updated in the database.
     * @param {FulfillmentGroupUpdateManyAndReturnArgs} args - Arguments to update many FulfillmentGroups.
     * @example
     * // Update many FulfillmentGroups
     * const fulfillmentGroup = await prisma.fulfillmentGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FulfillmentGroups and only return the `id`
     * const fulfillmentGroupWithIdOnly = await prisma.fulfillmentGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FulfillmentGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, FulfillmentGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FulfillmentGroup.
     * @param {FulfillmentGroupUpsertArgs} args - Arguments to update or create a FulfillmentGroup.
     * @example
     * // Update or create a FulfillmentGroup
     * const fulfillmentGroup = await prisma.fulfillmentGroup.upsert({
     *   create: {
     *     // ... data to create a FulfillmentGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FulfillmentGroup we want to update
     *   }
     * })
     */
    upsert<T extends FulfillmentGroupUpsertArgs>(args: SelectSubset<T, FulfillmentGroupUpsertArgs<ExtArgs>>): Prisma__FulfillmentGroupClient<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FulfillmentGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FulfillmentGroupCountArgs} args - Arguments to filter FulfillmentGroups to count.
     * @example
     * // Count the number of FulfillmentGroups
     * const count = await prisma.fulfillmentGroup.count({
     *   where: {
     *     // ... the filter for the FulfillmentGroups we want to count
     *   }
     * })
    **/
    count<T extends FulfillmentGroupCountArgs>(
      args?: Subset<T, FulfillmentGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FulfillmentGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FulfillmentGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FulfillmentGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FulfillmentGroupAggregateArgs>(args: Subset<T, FulfillmentGroupAggregateArgs>): Prisma.PrismaPromise<GetFulfillmentGroupAggregateType<T>>

    /**
     * Group by FulfillmentGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FulfillmentGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FulfillmentGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FulfillmentGroupGroupByArgs['orderBy'] }
        : { orderBy?: FulfillmentGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FulfillmentGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFulfillmentGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FulfillmentGroup model
   */
  readonly fields: FulfillmentGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FulfillmentGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FulfillmentGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceDay<T extends ServiceDayDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDayDefaultArgs<ExtArgs>>): Prisma__ServiceDayClient<$Result.GetResult<Prisma.$ServiceDayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceSlot<T extends FulfillmentGroup$serviceSlotArgs<ExtArgs> = {}>(args?: Subset<T, FulfillmentGroup$serviceSlotArgs<ExtArgs>>): Prisma__ServiceSlotClient<$Result.GetResult<Prisma.$ServiceSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends FulfillmentGroup$itemsArgs<ExtArgs> = {}>(args?: Subset<T, FulfillmentGroup$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adjustments<T extends FulfillmentGroup$adjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, FulfillmentGroup$adjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends FulfillmentGroup$eventsArgs<ExtArgs> = {}>(args?: Subset<T, FulfillmentGroup$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FulfillmentGroup model
   */
  interface FulfillmentGroupFieldRefs {
    readonly id: FieldRef<"FulfillmentGroup", 'Int'>
    readonly orderId: FieldRef<"FulfillmentGroup", 'Int'>
    readonly serviceDayId: FieldRef<"FulfillmentGroup", 'Int'>
    readonly serviceSlotId: FieldRef<"FulfillmentGroup", 'Int'>
    readonly status: FieldRef<"FulfillmentGroup", 'FulfillmentGroupStatus'>
    readonly sequence: FieldRef<"FulfillmentGroup", 'Int'>
    readonly createdAt: FieldRef<"FulfillmentGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"FulfillmentGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FulfillmentGroup findUnique
   */
  export type FulfillmentGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupInclude<ExtArgs> | null
    /**
     * Filter, which FulfillmentGroup to fetch.
     */
    where: FulfillmentGroupWhereUniqueInput
  }

  /**
   * FulfillmentGroup findUniqueOrThrow
   */
  export type FulfillmentGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupInclude<ExtArgs> | null
    /**
     * Filter, which FulfillmentGroup to fetch.
     */
    where: FulfillmentGroupWhereUniqueInput
  }

  /**
   * FulfillmentGroup findFirst
   */
  export type FulfillmentGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupInclude<ExtArgs> | null
    /**
     * Filter, which FulfillmentGroup to fetch.
     */
    where?: FulfillmentGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FulfillmentGroups to fetch.
     */
    orderBy?: FulfillmentGroupOrderByWithRelationInput | FulfillmentGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FulfillmentGroups.
     */
    cursor?: FulfillmentGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FulfillmentGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FulfillmentGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FulfillmentGroups.
     */
    distinct?: FulfillmentGroupScalarFieldEnum | FulfillmentGroupScalarFieldEnum[]
  }

  /**
   * FulfillmentGroup findFirstOrThrow
   */
  export type FulfillmentGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupInclude<ExtArgs> | null
    /**
     * Filter, which FulfillmentGroup to fetch.
     */
    where?: FulfillmentGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FulfillmentGroups to fetch.
     */
    orderBy?: FulfillmentGroupOrderByWithRelationInput | FulfillmentGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FulfillmentGroups.
     */
    cursor?: FulfillmentGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FulfillmentGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FulfillmentGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FulfillmentGroups.
     */
    distinct?: FulfillmentGroupScalarFieldEnum | FulfillmentGroupScalarFieldEnum[]
  }

  /**
   * FulfillmentGroup findMany
   */
  export type FulfillmentGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupInclude<ExtArgs> | null
    /**
     * Filter, which FulfillmentGroups to fetch.
     */
    where?: FulfillmentGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FulfillmentGroups to fetch.
     */
    orderBy?: FulfillmentGroupOrderByWithRelationInput | FulfillmentGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FulfillmentGroups.
     */
    cursor?: FulfillmentGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FulfillmentGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FulfillmentGroups.
     */
    skip?: number
    distinct?: FulfillmentGroupScalarFieldEnum | FulfillmentGroupScalarFieldEnum[]
  }

  /**
   * FulfillmentGroup create
   */
  export type FulfillmentGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a FulfillmentGroup.
     */
    data: XOR<FulfillmentGroupCreateInput, FulfillmentGroupUncheckedCreateInput>
  }

  /**
   * FulfillmentGroup createMany
   */
  export type FulfillmentGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FulfillmentGroups.
     */
    data: FulfillmentGroupCreateManyInput | FulfillmentGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FulfillmentGroup createManyAndReturn
   */
  export type FulfillmentGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * The data used to create many FulfillmentGroups.
     */
    data: FulfillmentGroupCreateManyInput | FulfillmentGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FulfillmentGroup update
   */
  export type FulfillmentGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a FulfillmentGroup.
     */
    data: XOR<FulfillmentGroupUpdateInput, FulfillmentGroupUncheckedUpdateInput>
    /**
     * Choose, which FulfillmentGroup to update.
     */
    where: FulfillmentGroupWhereUniqueInput
  }

  /**
   * FulfillmentGroup updateMany
   */
  export type FulfillmentGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FulfillmentGroups.
     */
    data: XOR<FulfillmentGroupUpdateManyMutationInput, FulfillmentGroupUncheckedUpdateManyInput>
    /**
     * Filter which FulfillmentGroups to update
     */
    where?: FulfillmentGroupWhereInput
    /**
     * Limit how many FulfillmentGroups to update.
     */
    limit?: number
  }

  /**
   * FulfillmentGroup updateManyAndReturn
   */
  export type FulfillmentGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * The data used to update FulfillmentGroups.
     */
    data: XOR<FulfillmentGroupUpdateManyMutationInput, FulfillmentGroupUncheckedUpdateManyInput>
    /**
     * Filter which FulfillmentGroups to update
     */
    where?: FulfillmentGroupWhereInput
    /**
     * Limit how many FulfillmentGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FulfillmentGroup upsert
   */
  export type FulfillmentGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the FulfillmentGroup to update in case it exists.
     */
    where: FulfillmentGroupWhereUniqueInput
    /**
     * In case the FulfillmentGroup found by the `where` argument doesn't exist, create a new FulfillmentGroup with this data.
     */
    create: XOR<FulfillmentGroupCreateInput, FulfillmentGroupUncheckedCreateInput>
    /**
     * In case the FulfillmentGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FulfillmentGroupUpdateInput, FulfillmentGroupUncheckedUpdateInput>
  }

  /**
   * FulfillmentGroup delete
   */
  export type FulfillmentGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupInclude<ExtArgs> | null
    /**
     * Filter which FulfillmentGroup to delete.
     */
    where: FulfillmentGroupWhereUniqueInput
  }

  /**
   * FulfillmentGroup deleteMany
   */
  export type FulfillmentGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FulfillmentGroups to delete
     */
    where?: FulfillmentGroupWhereInput
    /**
     * Limit how many FulfillmentGroups to delete.
     */
    limit?: number
  }

  /**
   * FulfillmentGroup.serviceSlot
   */
  export type FulfillmentGroup$serviceSlotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSlot
     */
    select?: ServiceSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSlot
     */
    omit?: ServiceSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSlotInclude<ExtArgs> | null
    where?: ServiceSlotWhereInput
  }

  /**
   * FulfillmentGroup.items
   */
  export type FulfillmentGroup$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * FulfillmentGroup.adjustments
   */
  export type FulfillmentGroup$adjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAdjustment
     */
    select?: OrderAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAdjustment
     */
    omit?: OrderAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAdjustmentInclude<ExtArgs> | null
    where?: OrderAdjustmentWhereInput
    orderBy?: OrderAdjustmentOrderByWithRelationInput | OrderAdjustmentOrderByWithRelationInput[]
    cursor?: OrderAdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderAdjustmentScalarFieldEnum | OrderAdjustmentScalarFieldEnum[]
  }

  /**
   * FulfillmentGroup.events
   */
  export type FulfillmentGroup$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderEvent
     */
    select?: OrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderEvent
     */
    omit?: OrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderEventInclude<ExtArgs> | null
    where?: OrderEventWhereInput
    orderBy?: OrderEventOrderByWithRelationInput | OrderEventOrderByWithRelationInput[]
    cursor?: OrderEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderEventScalarFieldEnum | OrderEventScalarFieldEnum[]
  }

  /**
   * FulfillmentGroup without action
   */
  export type FulfillmentGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    fulfillmentGroupId: number | null
    menuVariantId: number | null
    quantity: number | null
    unitPriceCents: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    fulfillmentGroupId: number | null
    menuVariantId: number | null
    quantity: number | null
    unitPriceCents: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    fulfillmentGroupId: number | null
    menuVariantId: number | null
    quantity: number | null
    unitPriceCents: number | null
    nameSnapshot: string | null
    variantLabelSnapshot: string | null
    imageUrlSnapshot: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    fulfillmentGroupId: number | null
    menuVariantId: number | null
    quantity: number | null
    unitPriceCents: number | null
    nameSnapshot: string | null
    variantLabelSnapshot: string | null
    imageUrlSnapshot: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    fulfillmentGroupId: number
    menuVariantId: number
    quantity: number
    unitPriceCents: number
    nameSnapshot: number
    variantLabelSnapshot: number
    imageUrlSnapshot: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    id?: true
    orderId?: true
    fulfillmentGroupId?: true
    menuVariantId?: true
    quantity?: true
    unitPriceCents?: true
  }

  export type OrderItemSumAggregateInputType = {
    id?: true
    orderId?: true
    fulfillmentGroupId?: true
    menuVariantId?: true
    quantity?: true
    unitPriceCents?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    fulfillmentGroupId?: true
    menuVariantId?: true
    quantity?: true
    unitPriceCents?: true
    nameSnapshot?: true
    variantLabelSnapshot?: true
    imageUrlSnapshot?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    fulfillmentGroupId?: true
    menuVariantId?: true
    quantity?: true
    unitPriceCents?: true
    nameSnapshot?: true
    variantLabelSnapshot?: true
    imageUrlSnapshot?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    fulfillmentGroupId?: true
    menuVariantId?: true
    quantity?: true
    unitPriceCents?: true
    nameSnapshot?: true
    variantLabelSnapshot?: true
    imageUrlSnapshot?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: number
    orderId: number
    fulfillmentGroupId: number
    menuVariantId: number
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    variantLabelSnapshot: string
    imageUrlSnapshot: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    fulfillmentGroupId?: boolean
    menuVariantId?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    nameSnapshot?: boolean
    variantLabelSnapshot?: boolean
    imageUrlSnapshot?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | FulfillmentGroupDefaultArgs<ExtArgs>
    variant?: boolean | MenuVariantDefaultArgs<ExtArgs>
    addOns?: boolean | OrderItem$addOnsArgs<ExtArgs>
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    fulfillmentGroupId?: boolean
    menuVariantId?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    nameSnapshot?: boolean
    variantLabelSnapshot?: boolean
    imageUrlSnapshot?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | FulfillmentGroupDefaultArgs<ExtArgs>
    variant?: boolean | MenuVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    fulfillmentGroupId?: boolean
    menuVariantId?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    nameSnapshot?: boolean
    variantLabelSnapshot?: boolean
    imageUrlSnapshot?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | FulfillmentGroupDefaultArgs<ExtArgs>
    variant?: boolean | MenuVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    fulfillmentGroupId?: boolean
    menuVariantId?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    nameSnapshot?: boolean
    variantLabelSnapshot?: boolean
    imageUrlSnapshot?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "fulfillmentGroupId" | "menuVariantId" | "quantity" | "unitPriceCents" | "nameSnapshot" | "variantLabelSnapshot" | "imageUrlSnapshot" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | FulfillmentGroupDefaultArgs<ExtArgs>
    variant?: boolean | MenuVariantDefaultArgs<ExtArgs>
    addOns?: boolean | OrderItem$addOnsArgs<ExtArgs>
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | FulfillmentGroupDefaultArgs<ExtArgs>
    variant?: boolean | MenuVariantDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | FulfillmentGroupDefaultArgs<ExtArgs>
    variant?: boolean | MenuVariantDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      group: Prisma.$FulfillmentGroupPayload<ExtArgs>
      variant: Prisma.$MenuVariantPayload<ExtArgs>
      addOns: Prisma.$OrderItemAddOnPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      fulfillmentGroupId: number
      menuVariantId: number
      quantity: number
      unitPriceCents: number
      nameSnapshot: string
      variantLabelSnapshot: string
      imageUrlSnapshot: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends FulfillmentGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FulfillmentGroupDefaultArgs<ExtArgs>>): Prisma__FulfillmentGroupClient<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    variant<T extends MenuVariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuVariantDefaultArgs<ExtArgs>>): Prisma__MenuVariantClient<$Result.GetResult<Prisma.$MenuVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addOns<T extends OrderItem$addOnsArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$addOnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemAddOnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'Int'>
    readonly orderId: FieldRef<"OrderItem", 'Int'>
    readonly fulfillmentGroupId: FieldRef<"OrderItem", 'Int'>
    readonly menuVariantId: FieldRef<"OrderItem", 'Int'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly unitPriceCents: FieldRef<"OrderItem", 'Int'>
    readonly nameSnapshot: FieldRef<"OrderItem", 'String'>
    readonly variantLabelSnapshot: FieldRef<"OrderItem", 'String'>
    readonly imageUrlSnapshot: FieldRef<"OrderItem", 'String'>
    readonly notes: FieldRef<"OrderItem", 'String'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem.addOns
   */
  export type OrderItem$addOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemAddOn
     */
    select?: OrderItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemAddOn
     */
    omit?: OrderItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemAddOnInclude<ExtArgs> | null
    where?: OrderItemAddOnWhereInput
    orderBy?: OrderItemAddOnOrderByWithRelationInput | OrderItemAddOnOrderByWithRelationInput[]
    cursor?: OrderItemAddOnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemAddOnScalarFieldEnum | OrderItemAddOnScalarFieldEnum[]
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model OrderItemAddOn
   */

  export type AggregateOrderItemAddOn = {
    _count: OrderItemAddOnCountAggregateOutputType | null
    _avg: OrderItemAddOnAvgAggregateOutputType | null
    _sum: OrderItemAddOnSumAggregateOutputType | null
    _min: OrderItemAddOnMinAggregateOutputType | null
    _max: OrderItemAddOnMaxAggregateOutputType | null
  }

  export type OrderItemAddOnAvgAggregateOutputType = {
    id: number | null
    orderItemId: number | null
    addOnId: number | null
    quantity: number | null
    unitPriceCents: number | null
  }

  export type OrderItemAddOnSumAggregateOutputType = {
    id: number | null
    orderItemId: number | null
    addOnId: number | null
    quantity: number | null
    unitPriceCents: number | null
  }

  export type OrderItemAddOnMinAggregateOutputType = {
    id: number | null
    orderItemId: number | null
    addOnId: number | null
    quantity: number | null
    unitPriceCents: number | null
    nameSnapshot: string | null
  }

  export type OrderItemAddOnMaxAggregateOutputType = {
    id: number | null
    orderItemId: number | null
    addOnId: number | null
    quantity: number | null
    unitPriceCents: number | null
    nameSnapshot: string | null
  }

  export type OrderItemAddOnCountAggregateOutputType = {
    id: number
    orderItemId: number
    addOnId: number
    quantity: number
    unitPriceCents: number
    nameSnapshot: number
    _all: number
  }


  export type OrderItemAddOnAvgAggregateInputType = {
    id?: true
    orderItemId?: true
    addOnId?: true
    quantity?: true
    unitPriceCents?: true
  }

  export type OrderItemAddOnSumAggregateInputType = {
    id?: true
    orderItemId?: true
    addOnId?: true
    quantity?: true
    unitPriceCents?: true
  }

  export type OrderItemAddOnMinAggregateInputType = {
    id?: true
    orderItemId?: true
    addOnId?: true
    quantity?: true
    unitPriceCents?: true
    nameSnapshot?: true
  }

  export type OrderItemAddOnMaxAggregateInputType = {
    id?: true
    orderItemId?: true
    addOnId?: true
    quantity?: true
    unitPriceCents?: true
    nameSnapshot?: true
  }

  export type OrderItemAddOnCountAggregateInputType = {
    id?: true
    orderItemId?: true
    addOnId?: true
    quantity?: true
    unitPriceCents?: true
    nameSnapshot?: true
    _all?: true
  }

  export type OrderItemAddOnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItemAddOn to aggregate.
     */
    where?: OrderItemAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItemAddOns to fetch.
     */
    orderBy?: OrderItemAddOnOrderByWithRelationInput | OrderItemAddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItemAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItemAddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItemAddOns
    **/
    _count?: true | OrderItemAddOnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAddOnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemAddOnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemAddOnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemAddOnMaxAggregateInputType
  }

  export type GetOrderItemAddOnAggregateType<T extends OrderItemAddOnAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItemAddOn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItemAddOn[P]>
      : GetScalarType<T[P], AggregateOrderItemAddOn[P]>
  }




  export type OrderItemAddOnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemAddOnWhereInput
    orderBy?: OrderItemAddOnOrderByWithAggregationInput | OrderItemAddOnOrderByWithAggregationInput[]
    by: OrderItemAddOnScalarFieldEnum[] | OrderItemAddOnScalarFieldEnum
    having?: OrderItemAddOnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemAddOnCountAggregateInputType | true
    _avg?: OrderItemAddOnAvgAggregateInputType
    _sum?: OrderItemAddOnSumAggregateInputType
    _min?: OrderItemAddOnMinAggregateInputType
    _max?: OrderItemAddOnMaxAggregateInputType
  }

  export type OrderItemAddOnGroupByOutputType = {
    id: number
    orderItemId: number
    addOnId: number | null
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    _count: OrderItemAddOnCountAggregateOutputType | null
    _avg: OrderItemAddOnAvgAggregateOutputType | null
    _sum: OrderItemAddOnSumAggregateOutputType | null
    _min: OrderItemAddOnMinAggregateOutputType | null
    _max: OrderItemAddOnMaxAggregateOutputType | null
  }

  type GetOrderItemAddOnGroupByPayload<T extends OrderItemAddOnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemAddOnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemAddOnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemAddOnGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemAddOnGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemAddOnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    addOnId?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    nameSnapshot?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    addOn?: boolean | OrderItemAddOn$addOnArgs<ExtArgs>
  }, ExtArgs["result"]["orderItemAddOn"]>

  export type OrderItemAddOnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    addOnId?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    nameSnapshot?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    addOn?: boolean | OrderItemAddOn$addOnArgs<ExtArgs>
  }, ExtArgs["result"]["orderItemAddOn"]>

  export type OrderItemAddOnSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    addOnId?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    nameSnapshot?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    addOn?: boolean | OrderItemAddOn$addOnArgs<ExtArgs>
  }, ExtArgs["result"]["orderItemAddOn"]>

  export type OrderItemAddOnSelectScalar = {
    id?: boolean
    orderItemId?: boolean
    addOnId?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    nameSnapshot?: boolean
  }

  export type OrderItemAddOnOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderItemId" | "addOnId" | "quantity" | "unitPriceCents" | "nameSnapshot", ExtArgs["result"]["orderItemAddOn"]>
  export type OrderItemAddOnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    addOn?: boolean | OrderItemAddOn$addOnArgs<ExtArgs>
  }
  export type OrderItemAddOnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    addOn?: boolean | OrderItemAddOn$addOnArgs<ExtArgs>
  }
  export type OrderItemAddOnIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    addOn?: boolean | OrderItemAddOn$addOnArgs<ExtArgs>
  }

  export type $OrderItemAddOnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItemAddOn"
    objects: {
      orderItem: Prisma.$OrderItemPayload<ExtArgs>
      addOn: Prisma.$AddOnPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderItemId: number
      addOnId: number | null
      quantity: number
      unitPriceCents: number
      nameSnapshot: string
    }, ExtArgs["result"]["orderItemAddOn"]>
    composites: {}
  }

  type OrderItemAddOnGetPayload<S extends boolean | null | undefined | OrderItemAddOnDefaultArgs> = $Result.GetResult<Prisma.$OrderItemAddOnPayload, S>

  type OrderItemAddOnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemAddOnFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemAddOnCountAggregateInputType | true
    }

  export interface OrderItemAddOnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItemAddOn'], meta: { name: 'OrderItemAddOn' } }
    /**
     * Find zero or one OrderItemAddOn that matches the filter.
     * @param {OrderItemAddOnFindUniqueArgs} args - Arguments to find a OrderItemAddOn
     * @example
     * // Get one OrderItemAddOn
     * const orderItemAddOn = await prisma.orderItemAddOn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemAddOnFindUniqueArgs>(args: SelectSubset<T, OrderItemAddOnFindUniqueArgs<ExtArgs>>): Prisma__OrderItemAddOnClient<$Result.GetResult<Prisma.$OrderItemAddOnPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItemAddOn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemAddOnFindUniqueOrThrowArgs} args - Arguments to find a OrderItemAddOn
     * @example
     * // Get one OrderItemAddOn
     * const orderItemAddOn = await prisma.orderItemAddOn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemAddOnFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemAddOnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemAddOnClient<$Result.GetResult<Prisma.$OrderItemAddOnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItemAddOn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAddOnFindFirstArgs} args - Arguments to find a OrderItemAddOn
     * @example
     * // Get one OrderItemAddOn
     * const orderItemAddOn = await prisma.orderItemAddOn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemAddOnFindFirstArgs>(args?: SelectSubset<T, OrderItemAddOnFindFirstArgs<ExtArgs>>): Prisma__OrderItemAddOnClient<$Result.GetResult<Prisma.$OrderItemAddOnPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItemAddOn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAddOnFindFirstOrThrowArgs} args - Arguments to find a OrderItemAddOn
     * @example
     * // Get one OrderItemAddOn
     * const orderItemAddOn = await prisma.orderItemAddOn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemAddOnFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemAddOnFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemAddOnClient<$Result.GetResult<Prisma.$OrderItemAddOnPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItemAddOns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAddOnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItemAddOns
     * const orderItemAddOns = await prisma.orderItemAddOn.findMany()
     * 
     * // Get first 10 OrderItemAddOns
     * const orderItemAddOns = await prisma.orderItemAddOn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemAddOnWithIdOnly = await prisma.orderItemAddOn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemAddOnFindManyArgs>(args?: SelectSubset<T, OrderItemAddOnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemAddOnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItemAddOn.
     * @param {OrderItemAddOnCreateArgs} args - Arguments to create a OrderItemAddOn.
     * @example
     * // Create one OrderItemAddOn
     * const OrderItemAddOn = await prisma.orderItemAddOn.create({
     *   data: {
     *     // ... data to create a OrderItemAddOn
     *   }
     * })
     * 
     */
    create<T extends OrderItemAddOnCreateArgs>(args: SelectSubset<T, OrderItemAddOnCreateArgs<ExtArgs>>): Prisma__OrderItemAddOnClient<$Result.GetResult<Prisma.$OrderItemAddOnPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItemAddOns.
     * @param {OrderItemAddOnCreateManyArgs} args - Arguments to create many OrderItemAddOns.
     * @example
     * // Create many OrderItemAddOns
     * const orderItemAddOn = await prisma.orderItemAddOn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemAddOnCreateManyArgs>(args?: SelectSubset<T, OrderItemAddOnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItemAddOns and returns the data saved in the database.
     * @param {OrderItemAddOnCreateManyAndReturnArgs} args - Arguments to create many OrderItemAddOns.
     * @example
     * // Create many OrderItemAddOns
     * const orderItemAddOn = await prisma.orderItemAddOn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItemAddOns and only return the `id`
     * const orderItemAddOnWithIdOnly = await prisma.orderItemAddOn.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemAddOnCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemAddOnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemAddOnPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItemAddOn.
     * @param {OrderItemAddOnDeleteArgs} args - Arguments to delete one OrderItemAddOn.
     * @example
     * // Delete one OrderItemAddOn
     * const OrderItemAddOn = await prisma.orderItemAddOn.delete({
     *   where: {
     *     // ... filter to delete one OrderItemAddOn
     *   }
     * })
     * 
     */
    delete<T extends OrderItemAddOnDeleteArgs>(args: SelectSubset<T, OrderItemAddOnDeleteArgs<ExtArgs>>): Prisma__OrderItemAddOnClient<$Result.GetResult<Prisma.$OrderItemAddOnPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItemAddOn.
     * @param {OrderItemAddOnUpdateArgs} args - Arguments to update one OrderItemAddOn.
     * @example
     * // Update one OrderItemAddOn
     * const orderItemAddOn = await prisma.orderItemAddOn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemAddOnUpdateArgs>(args: SelectSubset<T, OrderItemAddOnUpdateArgs<ExtArgs>>): Prisma__OrderItemAddOnClient<$Result.GetResult<Prisma.$OrderItemAddOnPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItemAddOns.
     * @param {OrderItemAddOnDeleteManyArgs} args - Arguments to filter OrderItemAddOns to delete.
     * @example
     * // Delete a few OrderItemAddOns
     * const { count } = await prisma.orderItemAddOn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemAddOnDeleteManyArgs>(args?: SelectSubset<T, OrderItemAddOnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItemAddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAddOnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItemAddOns
     * const orderItemAddOn = await prisma.orderItemAddOn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemAddOnUpdateManyArgs>(args: SelectSubset<T, OrderItemAddOnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItemAddOns and returns the data updated in the database.
     * @param {OrderItemAddOnUpdateManyAndReturnArgs} args - Arguments to update many OrderItemAddOns.
     * @example
     * // Update many OrderItemAddOns
     * const orderItemAddOn = await prisma.orderItemAddOn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItemAddOns and only return the `id`
     * const orderItemAddOnWithIdOnly = await prisma.orderItemAddOn.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemAddOnUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemAddOnUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemAddOnPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItemAddOn.
     * @param {OrderItemAddOnUpsertArgs} args - Arguments to update or create a OrderItemAddOn.
     * @example
     * // Update or create a OrderItemAddOn
     * const orderItemAddOn = await prisma.orderItemAddOn.upsert({
     *   create: {
     *     // ... data to create a OrderItemAddOn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItemAddOn we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemAddOnUpsertArgs>(args: SelectSubset<T, OrderItemAddOnUpsertArgs<ExtArgs>>): Prisma__OrderItemAddOnClient<$Result.GetResult<Prisma.$OrderItemAddOnPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItemAddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAddOnCountArgs} args - Arguments to filter OrderItemAddOns to count.
     * @example
     * // Count the number of OrderItemAddOns
     * const count = await prisma.orderItemAddOn.count({
     *   where: {
     *     // ... the filter for the OrderItemAddOns we want to count
     *   }
     * })
    **/
    count<T extends OrderItemAddOnCountArgs>(
      args?: Subset<T, OrderItemAddOnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemAddOnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItemAddOn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAddOnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAddOnAggregateArgs>(args: Subset<T, OrderItemAddOnAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAddOnAggregateType<T>>

    /**
     * Group by OrderItemAddOn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAddOnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemAddOnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemAddOnGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemAddOnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemAddOnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemAddOnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItemAddOn model
   */
  readonly fields: OrderItemAddOnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItemAddOn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemAddOnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItem<T extends OrderItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderItemDefaultArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addOn<T extends OrderItemAddOn$addOnArgs<ExtArgs> = {}>(args?: Subset<T, OrderItemAddOn$addOnArgs<ExtArgs>>): Prisma__AddOnClient<$Result.GetResult<Prisma.$AddOnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItemAddOn model
   */
  interface OrderItemAddOnFieldRefs {
    readonly id: FieldRef<"OrderItemAddOn", 'Int'>
    readonly orderItemId: FieldRef<"OrderItemAddOn", 'Int'>
    readonly addOnId: FieldRef<"OrderItemAddOn", 'Int'>
    readonly quantity: FieldRef<"OrderItemAddOn", 'Int'>
    readonly unitPriceCents: FieldRef<"OrderItemAddOn", 'Int'>
    readonly nameSnapshot: FieldRef<"OrderItemAddOn", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderItemAddOn findUnique
   */
  export type OrderItemAddOnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemAddOn
     */
    select?: OrderItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemAddOn
     */
    omit?: OrderItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemAddOnInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemAddOn to fetch.
     */
    where: OrderItemAddOnWhereUniqueInput
  }

  /**
   * OrderItemAddOn findUniqueOrThrow
   */
  export type OrderItemAddOnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemAddOn
     */
    select?: OrderItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemAddOn
     */
    omit?: OrderItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemAddOnInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemAddOn to fetch.
     */
    where: OrderItemAddOnWhereUniqueInput
  }

  /**
   * OrderItemAddOn findFirst
   */
  export type OrderItemAddOnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemAddOn
     */
    select?: OrderItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemAddOn
     */
    omit?: OrderItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemAddOnInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemAddOn to fetch.
     */
    where?: OrderItemAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItemAddOns to fetch.
     */
    orderBy?: OrderItemAddOnOrderByWithRelationInput | OrderItemAddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItemAddOns.
     */
    cursor?: OrderItemAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItemAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItemAddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItemAddOns.
     */
    distinct?: OrderItemAddOnScalarFieldEnum | OrderItemAddOnScalarFieldEnum[]
  }

  /**
   * OrderItemAddOn findFirstOrThrow
   */
  export type OrderItemAddOnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemAddOn
     */
    select?: OrderItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemAddOn
     */
    omit?: OrderItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemAddOnInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemAddOn to fetch.
     */
    where?: OrderItemAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItemAddOns to fetch.
     */
    orderBy?: OrderItemAddOnOrderByWithRelationInput | OrderItemAddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItemAddOns.
     */
    cursor?: OrderItemAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItemAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItemAddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItemAddOns.
     */
    distinct?: OrderItemAddOnScalarFieldEnum | OrderItemAddOnScalarFieldEnum[]
  }

  /**
   * OrderItemAddOn findMany
   */
  export type OrderItemAddOnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemAddOn
     */
    select?: OrderItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemAddOn
     */
    omit?: OrderItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemAddOnInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemAddOns to fetch.
     */
    where?: OrderItemAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItemAddOns to fetch.
     */
    orderBy?: OrderItemAddOnOrderByWithRelationInput | OrderItemAddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItemAddOns.
     */
    cursor?: OrderItemAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItemAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItemAddOns.
     */
    skip?: number
    distinct?: OrderItemAddOnScalarFieldEnum | OrderItemAddOnScalarFieldEnum[]
  }

  /**
   * OrderItemAddOn create
   */
  export type OrderItemAddOnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemAddOn
     */
    select?: OrderItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemAddOn
     */
    omit?: OrderItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemAddOnInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItemAddOn.
     */
    data: XOR<OrderItemAddOnCreateInput, OrderItemAddOnUncheckedCreateInput>
  }

  /**
   * OrderItemAddOn createMany
   */
  export type OrderItemAddOnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItemAddOns.
     */
    data: OrderItemAddOnCreateManyInput | OrderItemAddOnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItemAddOn createManyAndReturn
   */
  export type OrderItemAddOnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemAddOn
     */
    select?: OrderItemAddOnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemAddOn
     */
    omit?: OrderItemAddOnOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItemAddOns.
     */
    data: OrderItemAddOnCreateManyInput | OrderItemAddOnCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemAddOnIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItemAddOn update
   */
  export type OrderItemAddOnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemAddOn
     */
    select?: OrderItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemAddOn
     */
    omit?: OrderItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemAddOnInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItemAddOn.
     */
    data: XOR<OrderItemAddOnUpdateInput, OrderItemAddOnUncheckedUpdateInput>
    /**
     * Choose, which OrderItemAddOn to update.
     */
    where: OrderItemAddOnWhereUniqueInput
  }

  /**
   * OrderItemAddOn updateMany
   */
  export type OrderItemAddOnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItemAddOns.
     */
    data: XOR<OrderItemAddOnUpdateManyMutationInput, OrderItemAddOnUncheckedUpdateManyInput>
    /**
     * Filter which OrderItemAddOns to update
     */
    where?: OrderItemAddOnWhereInput
    /**
     * Limit how many OrderItemAddOns to update.
     */
    limit?: number
  }

  /**
   * OrderItemAddOn updateManyAndReturn
   */
  export type OrderItemAddOnUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemAddOn
     */
    select?: OrderItemAddOnSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemAddOn
     */
    omit?: OrderItemAddOnOmit<ExtArgs> | null
    /**
     * The data used to update OrderItemAddOns.
     */
    data: XOR<OrderItemAddOnUpdateManyMutationInput, OrderItemAddOnUncheckedUpdateManyInput>
    /**
     * Filter which OrderItemAddOns to update
     */
    where?: OrderItemAddOnWhereInput
    /**
     * Limit how many OrderItemAddOns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemAddOnIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItemAddOn upsert
   */
  export type OrderItemAddOnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemAddOn
     */
    select?: OrderItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemAddOn
     */
    omit?: OrderItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemAddOnInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItemAddOn to update in case it exists.
     */
    where: OrderItemAddOnWhereUniqueInput
    /**
     * In case the OrderItemAddOn found by the `where` argument doesn't exist, create a new OrderItemAddOn with this data.
     */
    create: XOR<OrderItemAddOnCreateInput, OrderItemAddOnUncheckedCreateInput>
    /**
     * In case the OrderItemAddOn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemAddOnUpdateInput, OrderItemAddOnUncheckedUpdateInput>
  }

  /**
   * OrderItemAddOn delete
   */
  export type OrderItemAddOnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemAddOn
     */
    select?: OrderItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemAddOn
     */
    omit?: OrderItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemAddOnInclude<ExtArgs> | null
    /**
     * Filter which OrderItemAddOn to delete.
     */
    where: OrderItemAddOnWhereUniqueInput
  }

  /**
   * OrderItemAddOn deleteMany
   */
  export type OrderItemAddOnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItemAddOns to delete
     */
    where?: OrderItemAddOnWhereInput
    /**
     * Limit how many OrderItemAddOns to delete.
     */
    limit?: number
  }

  /**
   * OrderItemAddOn.addOn
   */
  export type OrderItemAddOn$addOnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOn
     */
    select?: AddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOn
     */
    omit?: AddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnInclude<ExtArgs> | null
    where?: AddOnWhereInput
  }

  /**
   * OrderItemAddOn without action
   */
  export type OrderItemAddOnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemAddOn
     */
    select?: OrderItemAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemAddOn
     */
    omit?: OrderItemAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemAddOnInclude<ExtArgs> | null
  }


  /**
   * Model OrderAdjustment
   */

  export type AggregateOrderAdjustment = {
    _count: OrderAdjustmentCountAggregateOutputType | null
    _avg: OrderAdjustmentAvgAggregateOutputType | null
    _sum: OrderAdjustmentSumAggregateOutputType | null
    _min: OrderAdjustmentMinAggregateOutputType | null
    _max: OrderAdjustmentMaxAggregateOutputType | null
  }

  export type OrderAdjustmentAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    fulfillmentGroupId: number | null
    amountCents: number | null
  }

  export type OrderAdjustmentSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    fulfillmentGroupId: number | null
    amountCents: number | null
  }

  export type OrderAdjustmentMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    fulfillmentGroupId: number | null
    type: $Enums.AdjustmentType | null
    label: string | null
    amountCents: number | null
    createdAt: Date | null
  }

  export type OrderAdjustmentMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    fulfillmentGroupId: number | null
    type: $Enums.AdjustmentType | null
    label: string | null
    amountCents: number | null
    createdAt: Date | null
  }

  export type OrderAdjustmentCountAggregateOutputType = {
    id: number
    orderId: number
    fulfillmentGroupId: number
    type: number
    label: number
    amountCents: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type OrderAdjustmentAvgAggregateInputType = {
    id?: true
    orderId?: true
    fulfillmentGroupId?: true
    amountCents?: true
  }

  export type OrderAdjustmentSumAggregateInputType = {
    id?: true
    orderId?: true
    fulfillmentGroupId?: true
    amountCents?: true
  }

  export type OrderAdjustmentMinAggregateInputType = {
    id?: true
    orderId?: true
    fulfillmentGroupId?: true
    type?: true
    label?: true
    amountCents?: true
    createdAt?: true
  }

  export type OrderAdjustmentMaxAggregateInputType = {
    id?: true
    orderId?: true
    fulfillmentGroupId?: true
    type?: true
    label?: true
    amountCents?: true
    createdAt?: true
  }

  export type OrderAdjustmentCountAggregateInputType = {
    id?: true
    orderId?: true
    fulfillmentGroupId?: true
    type?: true
    label?: true
    amountCents?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type OrderAdjustmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderAdjustment to aggregate.
     */
    where?: OrderAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderAdjustments to fetch.
     */
    orderBy?: OrderAdjustmentOrderByWithRelationInput | OrderAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderAdjustments
    **/
    _count?: true | OrderAdjustmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAdjustmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderAdjustmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderAdjustmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderAdjustmentMaxAggregateInputType
  }

  export type GetOrderAdjustmentAggregateType<T extends OrderAdjustmentAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderAdjustment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderAdjustment[P]>
      : GetScalarType<T[P], AggregateOrderAdjustment[P]>
  }




  export type OrderAdjustmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderAdjustmentWhereInput
    orderBy?: OrderAdjustmentOrderByWithAggregationInput | OrderAdjustmentOrderByWithAggregationInput[]
    by: OrderAdjustmentScalarFieldEnum[] | OrderAdjustmentScalarFieldEnum
    having?: OrderAdjustmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderAdjustmentCountAggregateInputType | true
    _avg?: OrderAdjustmentAvgAggregateInputType
    _sum?: OrderAdjustmentSumAggregateInputType
    _min?: OrderAdjustmentMinAggregateInputType
    _max?: OrderAdjustmentMaxAggregateInputType
  }

  export type OrderAdjustmentGroupByOutputType = {
    id: number
    orderId: number
    fulfillmentGroupId: number | null
    type: $Enums.AdjustmentType
    label: string | null
    amountCents: number
    metadata: JsonValue | null
    createdAt: Date
    _count: OrderAdjustmentCountAggregateOutputType | null
    _avg: OrderAdjustmentAvgAggregateOutputType | null
    _sum: OrderAdjustmentSumAggregateOutputType | null
    _min: OrderAdjustmentMinAggregateOutputType | null
    _max: OrderAdjustmentMaxAggregateOutputType | null
  }

  type GetOrderAdjustmentGroupByPayload<T extends OrderAdjustmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderAdjustmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderAdjustmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderAdjustmentGroupByOutputType[P]>
            : GetScalarType<T[P], OrderAdjustmentGroupByOutputType[P]>
        }
      >
    >


  export type OrderAdjustmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    fulfillmentGroupId?: boolean
    type?: boolean
    label?: boolean
    amountCents?: boolean
    metadata?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | OrderAdjustment$groupArgs<ExtArgs>
  }, ExtArgs["result"]["orderAdjustment"]>

  export type OrderAdjustmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    fulfillmentGroupId?: boolean
    type?: boolean
    label?: boolean
    amountCents?: boolean
    metadata?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | OrderAdjustment$groupArgs<ExtArgs>
  }, ExtArgs["result"]["orderAdjustment"]>

  export type OrderAdjustmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    fulfillmentGroupId?: boolean
    type?: boolean
    label?: boolean
    amountCents?: boolean
    metadata?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | OrderAdjustment$groupArgs<ExtArgs>
  }, ExtArgs["result"]["orderAdjustment"]>

  export type OrderAdjustmentSelectScalar = {
    id?: boolean
    orderId?: boolean
    fulfillmentGroupId?: boolean
    type?: boolean
    label?: boolean
    amountCents?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type OrderAdjustmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "fulfillmentGroupId" | "type" | "label" | "amountCents" | "metadata" | "createdAt", ExtArgs["result"]["orderAdjustment"]>
  export type OrderAdjustmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | OrderAdjustment$groupArgs<ExtArgs>
  }
  export type OrderAdjustmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | OrderAdjustment$groupArgs<ExtArgs>
  }
  export type OrderAdjustmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | OrderAdjustment$groupArgs<ExtArgs>
  }

  export type $OrderAdjustmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderAdjustment"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      group: Prisma.$FulfillmentGroupPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      fulfillmentGroupId: number | null
      type: $Enums.AdjustmentType
      label: string | null
      amountCents: number
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["orderAdjustment"]>
    composites: {}
  }

  type OrderAdjustmentGetPayload<S extends boolean | null | undefined | OrderAdjustmentDefaultArgs> = $Result.GetResult<Prisma.$OrderAdjustmentPayload, S>

  type OrderAdjustmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderAdjustmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderAdjustmentCountAggregateInputType | true
    }

  export interface OrderAdjustmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderAdjustment'], meta: { name: 'OrderAdjustment' } }
    /**
     * Find zero or one OrderAdjustment that matches the filter.
     * @param {OrderAdjustmentFindUniqueArgs} args - Arguments to find a OrderAdjustment
     * @example
     * // Get one OrderAdjustment
     * const orderAdjustment = await prisma.orderAdjustment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderAdjustmentFindUniqueArgs>(args: SelectSubset<T, OrderAdjustmentFindUniqueArgs<ExtArgs>>): Prisma__OrderAdjustmentClient<$Result.GetResult<Prisma.$OrderAdjustmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderAdjustment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderAdjustmentFindUniqueOrThrowArgs} args - Arguments to find a OrderAdjustment
     * @example
     * // Get one OrderAdjustment
     * const orderAdjustment = await prisma.orderAdjustment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderAdjustmentFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderAdjustmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderAdjustmentClient<$Result.GetResult<Prisma.$OrderAdjustmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderAdjustment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAdjustmentFindFirstArgs} args - Arguments to find a OrderAdjustment
     * @example
     * // Get one OrderAdjustment
     * const orderAdjustment = await prisma.orderAdjustment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderAdjustmentFindFirstArgs>(args?: SelectSubset<T, OrderAdjustmentFindFirstArgs<ExtArgs>>): Prisma__OrderAdjustmentClient<$Result.GetResult<Prisma.$OrderAdjustmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderAdjustment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAdjustmentFindFirstOrThrowArgs} args - Arguments to find a OrderAdjustment
     * @example
     * // Get one OrderAdjustment
     * const orderAdjustment = await prisma.orderAdjustment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderAdjustmentFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderAdjustmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderAdjustmentClient<$Result.GetResult<Prisma.$OrderAdjustmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderAdjustments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAdjustmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderAdjustments
     * const orderAdjustments = await prisma.orderAdjustment.findMany()
     * 
     * // Get first 10 OrderAdjustments
     * const orderAdjustments = await prisma.orderAdjustment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderAdjustmentWithIdOnly = await prisma.orderAdjustment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderAdjustmentFindManyArgs>(args?: SelectSubset<T, OrderAdjustmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderAdjustment.
     * @param {OrderAdjustmentCreateArgs} args - Arguments to create a OrderAdjustment.
     * @example
     * // Create one OrderAdjustment
     * const OrderAdjustment = await prisma.orderAdjustment.create({
     *   data: {
     *     // ... data to create a OrderAdjustment
     *   }
     * })
     * 
     */
    create<T extends OrderAdjustmentCreateArgs>(args: SelectSubset<T, OrderAdjustmentCreateArgs<ExtArgs>>): Prisma__OrderAdjustmentClient<$Result.GetResult<Prisma.$OrderAdjustmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderAdjustments.
     * @param {OrderAdjustmentCreateManyArgs} args - Arguments to create many OrderAdjustments.
     * @example
     * // Create many OrderAdjustments
     * const orderAdjustment = await prisma.orderAdjustment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderAdjustmentCreateManyArgs>(args?: SelectSubset<T, OrderAdjustmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderAdjustments and returns the data saved in the database.
     * @param {OrderAdjustmentCreateManyAndReturnArgs} args - Arguments to create many OrderAdjustments.
     * @example
     * // Create many OrderAdjustments
     * const orderAdjustment = await prisma.orderAdjustment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderAdjustments and only return the `id`
     * const orderAdjustmentWithIdOnly = await prisma.orderAdjustment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderAdjustmentCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderAdjustmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAdjustmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderAdjustment.
     * @param {OrderAdjustmentDeleteArgs} args - Arguments to delete one OrderAdjustment.
     * @example
     * // Delete one OrderAdjustment
     * const OrderAdjustment = await prisma.orderAdjustment.delete({
     *   where: {
     *     // ... filter to delete one OrderAdjustment
     *   }
     * })
     * 
     */
    delete<T extends OrderAdjustmentDeleteArgs>(args: SelectSubset<T, OrderAdjustmentDeleteArgs<ExtArgs>>): Prisma__OrderAdjustmentClient<$Result.GetResult<Prisma.$OrderAdjustmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderAdjustment.
     * @param {OrderAdjustmentUpdateArgs} args - Arguments to update one OrderAdjustment.
     * @example
     * // Update one OrderAdjustment
     * const orderAdjustment = await prisma.orderAdjustment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderAdjustmentUpdateArgs>(args: SelectSubset<T, OrderAdjustmentUpdateArgs<ExtArgs>>): Prisma__OrderAdjustmentClient<$Result.GetResult<Prisma.$OrderAdjustmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderAdjustments.
     * @param {OrderAdjustmentDeleteManyArgs} args - Arguments to filter OrderAdjustments to delete.
     * @example
     * // Delete a few OrderAdjustments
     * const { count } = await prisma.orderAdjustment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderAdjustmentDeleteManyArgs>(args?: SelectSubset<T, OrderAdjustmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAdjustmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderAdjustments
     * const orderAdjustment = await prisma.orderAdjustment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderAdjustmentUpdateManyArgs>(args: SelectSubset<T, OrderAdjustmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderAdjustments and returns the data updated in the database.
     * @param {OrderAdjustmentUpdateManyAndReturnArgs} args - Arguments to update many OrderAdjustments.
     * @example
     * // Update many OrderAdjustments
     * const orderAdjustment = await prisma.orderAdjustment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderAdjustments and only return the `id`
     * const orderAdjustmentWithIdOnly = await prisma.orderAdjustment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderAdjustmentUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderAdjustmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAdjustmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderAdjustment.
     * @param {OrderAdjustmentUpsertArgs} args - Arguments to update or create a OrderAdjustment.
     * @example
     * // Update or create a OrderAdjustment
     * const orderAdjustment = await prisma.orderAdjustment.upsert({
     *   create: {
     *     // ... data to create a OrderAdjustment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderAdjustment we want to update
     *   }
     * })
     */
    upsert<T extends OrderAdjustmentUpsertArgs>(args: SelectSubset<T, OrderAdjustmentUpsertArgs<ExtArgs>>): Prisma__OrderAdjustmentClient<$Result.GetResult<Prisma.$OrderAdjustmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAdjustmentCountArgs} args - Arguments to filter OrderAdjustments to count.
     * @example
     * // Count the number of OrderAdjustments
     * const count = await prisma.orderAdjustment.count({
     *   where: {
     *     // ... the filter for the OrderAdjustments we want to count
     *   }
     * })
    **/
    count<T extends OrderAdjustmentCountArgs>(
      args?: Subset<T, OrderAdjustmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderAdjustmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAdjustmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAdjustmentAggregateArgs>(args: Subset<T, OrderAdjustmentAggregateArgs>): Prisma.PrismaPromise<GetOrderAdjustmentAggregateType<T>>

    /**
     * Group by OrderAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAdjustmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderAdjustmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderAdjustmentGroupByArgs['orderBy'] }
        : { orderBy?: OrderAdjustmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderAdjustmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderAdjustmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderAdjustment model
   */
  readonly fields: OrderAdjustmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderAdjustment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderAdjustmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends OrderAdjustment$groupArgs<ExtArgs> = {}>(args?: Subset<T, OrderAdjustment$groupArgs<ExtArgs>>): Prisma__FulfillmentGroupClient<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderAdjustment model
   */
  interface OrderAdjustmentFieldRefs {
    readonly id: FieldRef<"OrderAdjustment", 'Int'>
    readonly orderId: FieldRef<"OrderAdjustment", 'Int'>
    readonly fulfillmentGroupId: FieldRef<"OrderAdjustment", 'Int'>
    readonly type: FieldRef<"OrderAdjustment", 'AdjustmentType'>
    readonly label: FieldRef<"OrderAdjustment", 'String'>
    readonly amountCents: FieldRef<"OrderAdjustment", 'Int'>
    readonly metadata: FieldRef<"OrderAdjustment", 'Json'>
    readonly createdAt: FieldRef<"OrderAdjustment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderAdjustment findUnique
   */
  export type OrderAdjustmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAdjustment
     */
    select?: OrderAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAdjustment
     */
    omit?: OrderAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAdjustment to fetch.
     */
    where: OrderAdjustmentWhereUniqueInput
  }

  /**
   * OrderAdjustment findUniqueOrThrow
   */
  export type OrderAdjustmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAdjustment
     */
    select?: OrderAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAdjustment
     */
    omit?: OrderAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAdjustment to fetch.
     */
    where: OrderAdjustmentWhereUniqueInput
  }

  /**
   * OrderAdjustment findFirst
   */
  export type OrderAdjustmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAdjustment
     */
    select?: OrderAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAdjustment
     */
    omit?: OrderAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAdjustment to fetch.
     */
    where?: OrderAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderAdjustments to fetch.
     */
    orderBy?: OrderAdjustmentOrderByWithRelationInput | OrderAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderAdjustments.
     */
    cursor?: OrderAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderAdjustments.
     */
    distinct?: OrderAdjustmentScalarFieldEnum | OrderAdjustmentScalarFieldEnum[]
  }

  /**
   * OrderAdjustment findFirstOrThrow
   */
  export type OrderAdjustmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAdjustment
     */
    select?: OrderAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAdjustment
     */
    omit?: OrderAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAdjustment to fetch.
     */
    where?: OrderAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderAdjustments to fetch.
     */
    orderBy?: OrderAdjustmentOrderByWithRelationInput | OrderAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderAdjustments.
     */
    cursor?: OrderAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderAdjustments.
     */
    distinct?: OrderAdjustmentScalarFieldEnum | OrderAdjustmentScalarFieldEnum[]
  }

  /**
   * OrderAdjustment findMany
   */
  export type OrderAdjustmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAdjustment
     */
    select?: OrderAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAdjustment
     */
    omit?: OrderAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAdjustments to fetch.
     */
    where?: OrderAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderAdjustments to fetch.
     */
    orderBy?: OrderAdjustmentOrderByWithRelationInput | OrderAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderAdjustments.
     */
    cursor?: OrderAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderAdjustments.
     */
    skip?: number
    distinct?: OrderAdjustmentScalarFieldEnum | OrderAdjustmentScalarFieldEnum[]
  }

  /**
   * OrderAdjustment create
   */
  export type OrderAdjustmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAdjustment
     */
    select?: OrderAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAdjustment
     */
    omit?: OrderAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderAdjustment.
     */
    data: XOR<OrderAdjustmentCreateInput, OrderAdjustmentUncheckedCreateInput>
  }

  /**
   * OrderAdjustment createMany
   */
  export type OrderAdjustmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderAdjustments.
     */
    data: OrderAdjustmentCreateManyInput | OrderAdjustmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderAdjustment createManyAndReturn
   */
  export type OrderAdjustmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAdjustment
     */
    select?: OrderAdjustmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAdjustment
     */
    omit?: OrderAdjustmentOmit<ExtArgs> | null
    /**
     * The data used to create many OrderAdjustments.
     */
    data: OrderAdjustmentCreateManyInput | OrderAdjustmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAdjustmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderAdjustment update
   */
  export type OrderAdjustmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAdjustment
     */
    select?: OrderAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAdjustment
     */
    omit?: OrderAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderAdjustment.
     */
    data: XOR<OrderAdjustmentUpdateInput, OrderAdjustmentUncheckedUpdateInput>
    /**
     * Choose, which OrderAdjustment to update.
     */
    where: OrderAdjustmentWhereUniqueInput
  }

  /**
   * OrderAdjustment updateMany
   */
  export type OrderAdjustmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderAdjustments.
     */
    data: XOR<OrderAdjustmentUpdateManyMutationInput, OrderAdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which OrderAdjustments to update
     */
    where?: OrderAdjustmentWhereInput
    /**
     * Limit how many OrderAdjustments to update.
     */
    limit?: number
  }

  /**
   * OrderAdjustment updateManyAndReturn
   */
  export type OrderAdjustmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAdjustment
     */
    select?: OrderAdjustmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAdjustment
     */
    omit?: OrderAdjustmentOmit<ExtArgs> | null
    /**
     * The data used to update OrderAdjustments.
     */
    data: XOR<OrderAdjustmentUpdateManyMutationInput, OrderAdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which OrderAdjustments to update
     */
    where?: OrderAdjustmentWhereInput
    /**
     * Limit how many OrderAdjustments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAdjustmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderAdjustment upsert
   */
  export type OrderAdjustmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAdjustment
     */
    select?: OrderAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAdjustment
     */
    omit?: OrderAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAdjustmentInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderAdjustment to update in case it exists.
     */
    where: OrderAdjustmentWhereUniqueInput
    /**
     * In case the OrderAdjustment found by the `where` argument doesn't exist, create a new OrderAdjustment with this data.
     */
    create: XOR<OrderAdjustmentCreateInput, OrderAdjustmentUncheckedCreateInput>
    /**
     * In case the OrderAdjustment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderAdjustmentUpdateInput, OrderAdjustmentUncheckedUpdateInput>
  }

  /**
   * OrderAdjustment delete
   */
  export type OrderAdjustmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAdjustment
     */
    select?: OrderAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAdjustment
     */
    omit?: OrderAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAdjustmentInclude<ExtArgs> | null
    /**
     * Filter which OrderAdjustment to delete.
     */
    where: OrderAdjustmentWhereUniqueInput
  }

  /**
   * OrderAdjustment deleteMany
   */
  export type OrderAdjustmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderAdjustments to delete
     */
    where?: OrderAdjustmentWhereInput
    /**
     * Limit how many OrderAdjustments to delete.
     */
    limit?: number
  }

  /**
   * OrderAdjustment.group
   */
  export type OrderAdjustment$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupInclude<ExtArgs> | null
    where?: FulfillmentGroupWhereInput
  }

  /**
   * OrderAdjustment without action
   */
  export type OrderAdjustmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAdjustment
     */
    select?: OrderAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAdjustment
     */
    omit?: OrderAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAdjustmentInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    amountCents: number | null
    receivedByUserId: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    amountCents: number | null
    receivedByUserId: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    provider: $Enums.PaymentProvider | null
    method: $Enums.PaymentMethod | null
    status: $Enums.PaymentStatus | null
    amountCents: number | null
    providerRef: string | null
    receivedByUserId: number | null
    receivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    provider: $Enums.PaymentProvider | null
    method: $Enums.PaymentMethod | null
    status: $Enums.PaymentStatus | null
    amountCents: number | null
    providerRef: string | null
    receivedByUserId: number | null
    receivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    orderId: number
    provider: number
    method: number
    status: number
    amountCents: number
    providerRef: number
    receivedByUserId: number
    receivedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    orderId?: true
    amountCents?: true
    receivedByUserId?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    orderId?: true
    amountCents?: true
    receivedByUserId?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    orderId?: true
    provider?: true
    method?: true
    status?: true
    amountCents?: true
    providerRef?: true
    receivedByUserId?: true
    receivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    orderId?: true
    provider?: true
    method?: true
    status?: true
    amountCents?: true
    providerRef?: true
    receivedByUserId?: true
    receivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    orderId?: true
    provider?: true
    method?: true
    status?: true
    amountCents?: true
    providerRef?: true
    receivedByUserId?: true
    receivedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    orderId: number
    provider: $Enums.PaymentProvider
    method: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    amountCents: number
    providerRef: string | null
    receivedByUserId: number | null
    receivedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    provider?: boolean
    method?: boolean
    status?: boolean
    amountCents?: boolean
    providerRef?: boolean
    receivedByUserId?: boolean
    receivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    receivedBy?: boolean | Payment$receivedByArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    provider?: boolean
    method?: boolean
    status?: boolean
    amountCents?: boolean
    providerRef?: boolean
    receivedByUserId?: boolean
    receivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    receivedBy?: boolean | Payment$receivedByArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    provider?: boolean
    method?: boolean
    status?: boolean
    amountCents?: boolean
    providerRef?: boolean
    receivedByUserId?: boolean
    receivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    receivedBy?: boolean | Payment$receivedByArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    orderId?: boolean
    provider?: boolean
    method?: boolean
    status?: boolean
    amountCents?: boolean
    providerRef?: boolean
    receivedByUserId?: boolean
    receivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "provider" | "method" | "status" | "amountCents" | "providerRef" | "receivedByUserId" | "receivedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    receivedBy?: boolean | Payment$receivedByArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    receivedBy?: boolean | Payment$receivedByArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    receivedBy?: boolean | Payment$receivedByArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      receivedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      provider: $Enums.PaymentProvider
      method: $Enums.PaymentMethod
      status: $Enums.PaymentStatus
      amountCents: number
      providerRef: string | null
      receivedByUserId: number | null
      receivedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receivedBy<T extends Payment$receivedByArgs<ExtArgs> = {}>(args?: Subset<T, Payment$receivedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly orderId: FieldRef<"Payment", 'Int'>
    readonly provider: FieldRef<"Payment", 'PaymentProvider'>
    readonly method: FieldRef<"Payment", 'PaymentMethod'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly amountCents: FieldRef<"Payment", 'Int'>
    readonly providerRef: FieldRef<"Payment", 'String'>
    readonly receivedByUserId: FieldRef<"Payment", 'Int'>
    readonly receivedAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.receivedBy
   */
  export type Payment$receivedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model OrderEvent
   */

  export type AggregateOrderEvent = {
    _count: OrderEventCountAggregateOutputType | null
    _avg: OrderEventAvgAggregateOutputType | null
    _sum: OrderEventSumAggregateOutputType | null
    _min: OrderEventMinAggregateOutputType | null
    _max: OrderEventMaxAggregateOutputType | null
  }

  export type OrderEventAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    fulfillmentGroupId: number | null
  }

  export type OrderEventSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    fulfillmentGroupId: number | null
  }

  export type OrderEventMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    fulfillmentGroupId: number | null
    type: string | null
    createdAt: Date | null
  }

  export type OrderEventMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    fulfillmentGroupId: number | null
    type: string | null
    createdAt: Date | null
  }

  export type OrderEventCountAggregateOutputType = {
    id: number
    orderId: number
    fulfillmentGroupId: number
    type: number
    payload: number
    createdAt: number
    _all: number
  }


  export type OrderEventAvgAggregateInputType = {
    id?: true
    orderId?: true
    fulfillmentGroupId?: true
  }

  export type OrderEventSumAggregateInputType = {
    id?: true
    orderId?: true
    fulfillmentGroupId?: true
  }

  export type OrderEventMinAggregateInputType = {
    id?: true
    orderId?: true
    fulfillmentGroupId?: true
    type?: true
    createdAt?: true
  }

  export type OrderEventMaxAggregateInputType = {
    id?: true
    orderId?: true
    fulfillmentGroupId?: true
    type?: true
    createdAt?: true
  }

  export type OrderEventCountAggregateInputType = {
    id?: true
    orderId?: true
    fulfillmentGroupId?: true
    type?: true
    payload?: true
    createdAt?: true
    _all?: true
  }

  export type OrderEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderEvent to aggregate.
     */
    where?: OrderEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderEvents to fetch.
     */
    orderBy?: OrderEventOrderByWithRelationInput | OrderEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderEvents
    **/
    _count?: true | OrderEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderEventMaxAggregateInputType
  }

  export type GetOrderEventAggregateType<T extends OrderEventAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderEvent[P]>
      : GetScalarType<T[P], AggregateOrderEvent[P]>
  }




  export type OrderEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderEventWhereInput
    orderBy?: OrderEventOrderByWithAggregationInput | OrderEventOrderByWithAggregationInput[]
    by: OrderEventScalarFieldEnum[] | OrderEventScalarFieldEnum
    having?: OrderEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderEventCountAggregateInputType | true
    _avg?: OrderEventAvgAggregateInputType
    _sum?: OrderEventSumAggregateInputType
    _min?: OrderEventMinAggregateInputType
    _max?: OrderEventMaxAggregateInputType
  }

  export type OrderEventGroupByOutputType = {
    id: number
    orderId: number
    fulfillmentGroupId: number | null
    type: string
    payload: JsonValue | null
    createdAt: Date
    _count: OrderEventCountAggregateOutputType | null
    _avg: OrderEventAvgAggregateOutputType | null
    _sum: OrderEventSumAggregateOutputType | null
    _min: OrderEventMinAggregateOutputType | null
    _max: OrderEventMaxAggregateOutputType | null
  }

  type GetOrderEventGroupByPayload<T extends OrderEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderEventGroupByOutputType[P]>
            : GetScalarType<T[P], OrderEventGroupByOutputType[P]>
        }
      >
    >


  export type OrderEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    fulfillmentGroupId?: boolean
    type?: boolean
    payload?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | OrderEvent$groupArgs<ExtArgs>
  }, ExtArgs["result"]["orderEvent"]>

  export type OrderEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    fulfillmentGroupId?: boolean
    type?: boolean
    payload?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | OrderEvent$groupArgs<ExtArgs>
  }, ExtArgs["result"]["orderEvent"]>

  export type OrderEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    fulfillmentGroupId?: boolean
    type?: boolean
    payload?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | OrderEvent$groupArgs<ExtArgs>
  }, ExtArgs["result"]["orderEvent"]>

  export type OrderEventSelectScalar = {
    id?: boolean
    orderId?: boolean
    fulfillmentGroupId?: boolean
    type?: boolean
    payload?: boolean
    createdAt?: boolean
  }

  export type OrderEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "fulfillmentGroupId" | "type" | "payload" | "createdAt", ExtArgs["result"]["orderEvent"]>
  export type OrderEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | OrderEvent$groupArgs<ExtArgs>
  }
  export type OrderEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | OrderEvent$groupArgs<ExtArgs>
  }
  export type OrderEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    group?: boolean | OrderEvent$groupArgs<ExtArgs>
  }

  export type $OrderEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderEvent"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      group: Prisma.$FulfillmentGroupPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      fulfillmentGroupId: number | null
      type: string
      payload: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["orderEvent"]>
    composites: {}
  }

  type OrderEventGetPayload<S extends boolean | null | undefined | OrderEventDefaultArgs> = $Result.GetResult<Prisma.$OrderEventPayload, S>

  type OrderEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderEventCountAggregateInputType | true
    }

  export interface OrderEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderEvent'], meta: { name: 'OrderEvent' } }
    /**
     * Find zero or one OrderEvent that matches the filter.
     * @param {OrderEventFindUniqueArgs} args - Arguments to find a OrderEvent
     * @example
     * // Get one OrderEvent
     * const orderEvent = await prisma.orderEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderEventFindUniqueArgs>(args: SelectSubset<T, OrderEventFindUniqueArgs<ExtArgs>>): Prisma__OrderEventClient<$Result.GetResult<Prisma.$OrderEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderEventFindUniqueOrThrowArgs} args - Arguments to find a OrderEvent
     * @example
     * // Get one OrderEvent
     * const orderEvent = await prisma.orderEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderEventFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderEventClient<$Result.GetResult<Prisma.$OrderEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderEventFindFirstArgs} args - Arguments to find a OrderEvent
     * @example
     * // Get one OrderEvent
     * const orderEvent = await prisma.orderEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderEventFindFirstArgs>(args?: SelectSubset<T, OrderEventFindFirstArgs<ExtArgs>>): Prisma__OrderEventClient<$Result.GetResult<Prisma.$OrderEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderEventFindFirstOrThrowArgs} args - Arguments to find a OrderEvent
     * @example
     * // Get one OrderEvent
     * const orderEvent = await prisma.orderEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderEventFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderEventClient<$Result.GetResult<Prisma.$OrderEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderEvents
     * const orderEvents = await prisma.orderEvent.findMany()
     * 
     * // Get first 10 OrderEvents
     * const orderEvents = await prisma.orderEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderEventWithIdOnly = await prisma.orderEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderEventFindManyArgs>(args?: SelectSubset<T, OrderEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderEvent.
     * @param {OrderEventCreateArgs} args - Arguments to create a OrderEvent.
     * @example
     * // Create one OrderEvent
     * const OrderEvent = await prisma.orderEvent.create({
     *   data: {
     *     // ... data to create a OrderEvent
     *   }
     * })
     * 
     */
    create<T extends OrderEventCreateArgs>(args: SelectSubset<T, OrderEventCreateArgs<ExtArgs>>): Prisma__OrderEventClient<$Result.GetResult<Prisma.$OrderEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderEvents.
     * @param {OrderEventCreateManyArgs} args - Arguments to create many OrderEvents.
     * @example
     * // Create many OrderEvents
     * const orderEvent = await prisma.orderEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderEventCreateManyArgs>(args?: SelectSubset<T, OrderEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderEvents and returns the data saved in the database.
     * @param {OrderEventCreateManyAndReturnArgs} args - Arguments to create many OrderEvents.
     * @example
     * // Create many OrderEvents
     * const orderEvent = await prisma.orderEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderEvents and only return the `id`
     * const orderEventWithIdOnly = await prisma.orderEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderEventCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderEvent.
     * @param {OrderEventDeleteArgs} args - Arguments to delete one OrderEvent.
     * @example
     * // Delete one OrderEvent
     * const OrderEvent = await prisma.orderEvent.delete({
     *   where: {
     *     // ... filter to delete one OrderEvent
     *   }
     * })
     * 
     */
    delete<T extends OrderEventDeleteArgs>(args: SelectSubset<T, OrderEventDeleteArgs<ExtArgs>>): Prisma__OrderEventClient<$Result.GetResult<Prisma.$OrderEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderEvent.
     * @param {OrderEventUpdateArgs} args - Arguments to update one OrderEvent.
     * @example
     * // Update one OrderEvent
     * const orderEvent = await prisma.orderEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderEventUpdateArgs>(args: SelectSubset<T, OrderEventUpdateArgs<ExtArgs>>): Prisma__OrderEventClient<$Result.GetResult<Prisma.$OrderEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderEvents.
     * @param {OrderEventDeleteManyArgs} args - Arguments to filter OrderEvents to delete.
     * @example
     * // Delete a few OrderEvents
     * const { count } = await prisma.orderEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderEventDeleteManyArgs>(args?: SelectSubset<T, OrderEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderEvents
     * const orderEvent = await prisma.orderEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderEventUpdateManyArgs>(args: SelectSubset<T, OrderEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderEvents and returns the data updated in the database.
     * @param {OrderEventUpdateManyAndReturnArgs} args - Arguments to update many OrderEvents.
     * @example
     * // Update many OrderEvents
     * const orderEvent = await prisma.orderEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderEvents and only return the `id`
     * const orderEventWithIdOnly = await prisma.orderEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderEventUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderEvent.
     * @param {OrderEventUpsertArgs} args - Arguments to update or create a OrderEvent.
     * @example
     * // Update or create a OrderEvent
     * const orderEvent = await prisma.orderEvent.upsert({
     *   create: {
     *     // ... data to create a OrderEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderEvent we want to update
     *   }
     * })
     */
    upsert<T extends OrderEventUpsertArgs>(args: SelectSubset<T, OrderEventUpsertArgs<ExtArgs>>): Prisma__OrderEventClient<$Result.GetResult<Prisma.$OrderEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderEventCountArgs} args - Arguments to filter OrderEvents to count.
     * @example
     * // Count the number of OrderEvents
     * const count = await prisma.orderEvent.count({
     *   where: {
     *     // ... the filter for the OrderEvents we want to count
     *   }
     * })
    **/
    count<T extends OrderEventCountArgs>(
      args?: Subset<T, OrderEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderEventAggregateArgs>(args: Subset<T, OrderEventAggregateArgs>): Prisma.PrismaPromise<GetOrderEventAggregateType<T>>

    /**
     * Group by OrderEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderEventGroupByArgs['orderBy'] }
        : { orderBy?: OrderEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderEvent model
   */
  readonly fields: OrderEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends OrderEvent$groupArgs<ExtArgs> = {}>(args?: Subset<T, OrderEvent$groupArgs<ExtArgs>>): Prisma__FulfillmentGroupClient<$Result.GetResult<Prisma.$FulfillmentGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderEvent model
   */
  interface OrderEventFieldRefs {
    readonly id: FieldRef<"OrderEvent", 'Int'>
    readonly orderId: FieldRef<"OrderEvent", 'Int'>
    readonly fulfillmentGroupId: FieldRef<"OrderEvent", 'Int'>
    readonly type: FieldRef<"OrderEvent", 'String'>
    readonly payload: FieldRef<"OrderEvent", 'Json'>
    readonly createdAt: FieldRef<"OrderEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderEvent findUnique
   */
  export type OrderEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderEvent
     */
    select?: OrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderEvent
     */
    omit?: OrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderEventInclude<ExtArgs> | null
    /**
     * Filter, which OrderEvent to fetch.
     */
    where: OrderEventWhereUniqueInput
  }

  /**
   * OrderEvent findUniqueOrThrow
   */
  export type OrderEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderEvent
     */
    select?: OrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderEvent
     */
    omit?: OrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderEventInclude<ExtArgs> | null
    /**
     * Filter, which OrderEvent to fetch.
     */
    where: OrderEventWhereUniqueInput
  }

  /**
   * OrderEvent findFirst
   */
  export type OrderEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderEvent
     */
    select?: OrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderEvent
     */
    omit?: OrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderEventInclude<ExtArgs> | null
    /**
     * Filter, which OrderEvent to fetch.
     */
    where?: OrderEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderEvents to fetch.
     */
    orderBy?: OrderEventOrderByWithRelationInput | OrderEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderEvents.
     */
    cursor?: OrderEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderEvents.
     */
    distinct?: OrderEventScalarFieldEnum | OrderEventScalarFieldEnum[]
  }

  /**
   * OrderEvent findFirstOrThrow
   */
  export type OrderEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderEvent
     */
    select?: OrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderEvent
     */
    omit?: OrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderEventInclude<ExtArgs> | null
    /**
     * Filter, which OrderEvent to fetch.
     */
    where?: OrderEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderEvents to fetch.
     */
    orderBy?: OrderEventOrderByWithRelationInput | OrderEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderEvents.
     */
    cursor?: OrderEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderEvents.
     */
    distinct?: OrderEventScalarFieldEnum | OrderEventScalarFieldEnum[]
  }

  /**
   * OrderEvent findMany
   */
  export type OrderEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderEvent
     */
    select?: OrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderEvent
     */
    omit?: OrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderEventInclude<ExtArgs> | null
    /**
     * Filter, which OrderEvents to fetch.
     */
    where?: OrderEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderEvents to fetch.
     */
    orderBy?: OrderEventOrderByWithRelationInput | OrderEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderEvents.
     */
    cursor?: OrderEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderEvents.
     */
    skip?: number
    distinct?: OrderEventScalarFieldEnum | OrderEventScalarFieldEnum[]
  }

  /**
   * OrderEvent create
   */
  export type OrderEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderEvent
     */
    select?: OrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderEvent
     */
    omit?: OrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderEventInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderEvent.
     */
    data: XOR<OrderEventCreateInput, OrderEventUncheckedCreateInput>
  }

  /**
   * OrderEvent createMany
   */
  export type OrderEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderEvents.
     */
    data: OrderEventCreateManyInput | OrderEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderEvent createManyAndReturn
   */
  export type OrderEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderEvent
     */
    select?: OrderEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderEvent
     */
    omit?: OrderEventOmit<ExtArgs> | null
    /**
     * The data used to create many OrderEvents.
     */
    data: OrderEventCreateManyInput | OrderEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderEvent update
   */
  export type OrderEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderEvent
     */
    select?: OrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderEvent
     */
    omit?: OrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderEventInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderEvent.
     */
    data: XOR<OrderEventUpdateInput, OrderEventUncheckedUpdateInput>
    /**
     * Choose, which OrderEvent to update.
     */
    where: OrderEventWhereUniqueInput
  }

  /**
   * OrderEvent updateMany
   */
  export type OrderEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderEvents.
     */
    data: XOR<OrderEventUpdateManyMutationInput, OrderEventUncheckedUpdateManyInput>
    /**
     * Filter which OrderEvents to update
     */
    where?: OrderEventWhereInput
    /**
     * Limit how many OrderEvents to update.
     */
    limit?: number
  }

  /**
   * OrderEvent updateManyAndReturn
   */
  export type OrderEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderEvent
     */
    select?: OrderEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderEvent
     */
    omit?: OrderEventOmit<ExtArgs> | null
    /**
     * The data used to update OrderEvents.
     */
    data: XOR<OrderEventUpdateManyMutationInput, OrderEventUncheckedUpdateManyInput>
    /**
     * Filter which OrderEvents to update
     */
    where?: OrderEventWhereInput
    /**
     * Limit how many OrderEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderEvent upsert
   */
  export type OrderEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderEvent
     */
    select?: OrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderEvent
     */
    omit?: OrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderEventInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderEvent to update in case it exists.
     */
    where: OrderEventWhereUniqueInput
    /**
     * In case the OrderEvent found by the `where` argument doesn't exist, create a new OrderEvent with this data.
     */
    create: XOR<OrderEventCreateInput, OrderEventUncheckedCreateInput>
    /**
     * In case the OrderEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderEventUpdateInput, OrderEventUncheckedUpdateInput>
  }

  /**
   * OrderEvent delete
   */
  export type OrderEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderEvent
     */
    select?: OrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderEvent
     */
    omit?: OrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderEventInclude<ExtArgs> | null
    /**
     * Filter which OrderEvent to delete.
     */
    where: OrderEventWhereUniqueInput
  }

  /**
   * OrderEvent deleteMany
   */
  export type OrderEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderEvents to delete
     */
    where?: OrderEventWhereInput
    /**
     * Limit how many OrderEvents to delete.
     */
    limit?: number
  }

  /**
   * OrderEvent.group
   */
  export type OrderEvent$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FulfillmentGroup
     */
    select?: FulfillmentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FulfillmentGroup
     */
    omit?: FulfillmentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FulfillmentGroupInclude<ExtArgs> | null
    where?: FulfillmentGroupWhereInput
  }

  /**
   * OrderEvent without action
   */
  export type OrderEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderEvent
     */
    select?: OrderEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderEvent
     */
    omit?: OrderEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderEventInclude<ExtArgs> | null
  }


  /**
   * Model CapacityHold
   */

  export type AggregateCapacityHold = {
    _count: CapacityHoldCountAggregateOutputType | null
    _avg: CapacityHoldAvgAggregateOutputType | null
    _sum: CapacityHoldSumAggregateOutputType | null
    _min: CapacityHoldMinAggregateOutputType | null
    _max: CapacityHoldMaxAggregateOutputType | null
  }

  export type CapacityHoldAvgAggregateOutputType = {
    id: number | null
    menuOfferingId: number | null
    orderId: number | null
    quantity: number | null
  }

  export type CapacityHoldSumAggregateOutputType = {
    id: number | null
    menuOfferingId: number | null
    orderId: number | null
    quantity: number | null
  }

  export type CapacityHoldMinAggregateOutputType = {
    id: number | null
    menuOfferingId: number | null
    orderId: number | null
    quantity: number | null
    status: $Enums.HoldStatus | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type CapacityHoldMaxAggregateOutputType = {
    id: number | null
    menuOfferingId: number | null
    orderId: number | null
    quantity: number | null
    status: $Enums.HoldStatus | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type CapacityHoldCountAggregateOutputType = {
    id: number
    menuOfferingId: number
    orderId: number
    quantity: number
    status: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type CapacityHoldAvgAggregateInputType = {
    id?: true
    menuOfferingId?: true
    orderId?: true
    quantity?: true
  }

  export type CapacityHoldSumAggregateInputType = {
    id?: true
    menuOfferingId?: true
    orderId?: true
    quantity?: true
  }

  export type CapacityHoldMinAggregateInputType = {
    id?: true
    menuOfferingId?: true
    orderId?: true
    quantity?: true
    status?: true
    expiresAt?: true
    createdAt?: true
  }

  export type CapacityHoldMaxAggregateInputType = {
    id?: true
    menuOfferingId?: true
    orderId?: true
    quantity?: true
    status?: true
    expiresAt?: true
    createdAt?: true
  }

  export type CapacityHoldCountAggregateInputType = {
    id?: true
    menuOfferingId?: true
    orderId?: true
    quantity?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type CapacityHoldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CapacityHold to aggregate.
     */
    where?: CapacityHoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapacityHolds to fetch.
     */
    orderBy?: CapacityHoldOrderByWithRelationInput | CapacityHoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CapacityHoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapacityHolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapacityHolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CapacityHolds
    **/
    _count?: true | CapacityHoldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CapacityHoldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CapacityHoldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CapacityHoldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CapacityHoldMaxAggregateInputType
  }

  export type GetCapacityHoldAggregateType<T extends CapacityHoldAggregateArgs> = {
        [P in keyof T & keyof AggregateCapacityHold]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapacityHold[P]>
      : GetScalarType<T[P], AggregateCapacityHold[P]>
  }




  export type CapacityHoldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CapacityHoldWhereInput
    orderBy?: CapacityHoldOrderByWithAggregationInput | CapacityHoldOrderByWithAggregationInput[]
    by: CapacityHoldScalarFieldEnum[] | CapacityHoldScalarFieldEnum
    having?: CapacityHoldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CapacityHoldCountAggregateInputType | true
    _avg?: CapacityHoldAvgAggregateInputType
    _sum?: CapacityHoldSumAggregateInputType
    _min?: CapacityHoldMinAggregateInputType
    _max?: CapacityHoldMaxAggregateInputType
  }

  export type CapacityHoldGroupByOutputType = {
    id: number
    menuOfferingId: number
    orderId: number | null
    quantity: number
    status: $Enums.HoldStatus
    expiresAt: Date
    createdAt: Date
    _count: CapacityHoldCountAggregateOutputType | null
    _avg: CapacityHoldAvgAggregateOutputType | null
    _sum: CapacityHoldSumAggregateOutputType | null
    _min: CapacityHoldMinAggregateOutputType | null
    _max: CapacityHoldMaxAggregateOutputType | null
  }

  type GetCapacityHoldGroupByPayload<T extends CapacityHoldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CapacityHoldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CapacityHoldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CapacityHoldGroupByOutputType[P]>
            : GetScalarType<T[P], CapacityHoldGroupByOutputType[P]>
        }
      >
    >


  export type CapacityHoldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuOfferingId?: boolean
    orderId?: boolean
    quantity?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    offering?: boolean | MenuOfferingDefaultArgs<ExtArgs>
    order?: boolean | CapacityHold$orderArgs<ExtArgs>
  }, ExtArgs["result"]["capacityHold"]>

  export type CapacityHoldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuOfferingId?: boolean
    orderId?: boolean
    quantity?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    offering?: boolean | MenuOfferingDefaultArgs<ExtArgs>
    order?: boolean | CapacityHold$orderArgs<ExtArgs>
  }, ExtArgs["result"]["capacityHold"]>

  export type CapacityHoldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuOfferingId?: boolean
    orderId?: boolean
    quantity?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    offering?: boolean | MenuOfferingDefaultArgs<ExtArgs>
    order?: boolean | CapacityHold$orderArgs<ExtArgs>
  }, ExtArgs["result"]["capacityHold"]>

  export type CapacityHoldSelectScalar = {
    id?: boolean
    menuOfferingId?: boolean
    orderId?: boolean
    quantity?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type CapacityHoldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "menuOfferingId" | "orderId" | "quantity" | "status" | "expiresAt" | "createdAt", ExtArgs["result"]["capacityHold"]>
  export type CapacityHoldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offering?: boolean | MenuOfferingDefaultArgs<ExtArgs>
    order?: boolean | CapacityHold$orderArgs<ExtArgs>
  }
  export type CapacityHoldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offering?: boolean | MenuOfferingDefaultArgs<ExtArgs>
    order?: boolean | CapacityHold$orderArgs<ExtArgs>
  }
  export type CapacityHoldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offering?: boolean | MenuOfferingDefaultArgs<ExtArgs>
    order?: boolean | CapacityHold$orderArgs<ExtArgs>
  }

  export type $CapacityHoldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CapacityHold"
    objects: {
      offering: Prisma.$MenuOfferingPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      menuOfferingId: number
      orderId: number | null
      quantity: number
      status: $Enums.HoldStatus
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["capacityHold"]>
    composites: {}
  }

  type CapacityHoldGetPayload<S extends boolean | null | undefined | CapacityHoldDefaultArgs> = $Result.GetResult<Prisma.$CapacityHoldPayload, S>

  type CapacityHoldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CapacityHoldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CapacityHoldCountAggregateInputType | true
    }

  export interface CapacityHoldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CapacityHold'], meta: { name: 'CapacityHold' } }
    /**
     * Find zero or one CapacityHold that matches the filter.
     * @param {CapacityHoldFindUniqueArgs} args - Arguments to find a CapacityHold
     * @example
     * // Get one CapacityHold
     * const capacityHold = await prisma.capacityHold.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CapacityHoldFindUniqueArgs>(args: SelectSubset<T, CapacityHoldFindUniqueArgs<ExtArgs>>): Prisma__CapacityHoldClient<$Result.GetResult<Prisma.$CapacityHoldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CapacityHold that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CapacityHoldFindUniqueOrThrowArgs} args - Arguments to find a CapacityHold
     * @example
     * // Get one CapacityHold
     * const capacityHold = await prisma.capacityHold.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CapacityHoldFindUniqueOrThrowArgs>(args: SelectSubset<T, CapacityHoldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CapacityHoldClient<$Result.GetResult<Prisma.$CapacityHoldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CapacityHold that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapacityHoldFindFirstArgs} args - Arguments to find a CapacityHold
     * @example
     * // Get one CapacityHold
     * const capacityHold = await prisma.capacityHold.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CapacityHoldFindFirstArgs>(args?: SelectSubset<T, CapacityHoldFindFirstArgs<ExtArgs>>): Prisma__CapacityHoldClient<$Result.GetResult<Prisma.$CapacityHoldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CapacityHold that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapacityHoldFindFirstOrThrowArgs} args - Arguments to find a CapacityHold
     * @example
     * // Get one CapacityHold
     * const capacityHold = await prisma.capacityHold.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CapacityHoldFindFirstOrThrowArgs>(args?: SelectSubset<T, CapacityHoldFindFirstOrThrowArgs<ExtArgs>>): Prisma__CapacityHoldClient<$Result.GetResult<Prisma.$CapacityHoldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CapacityHolds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapacityHoldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CapacityHolds
     * const capacityHolds = await prisma.capacityHold.findMany()
     * 
     * // Get first 10 CapacityHolds
     * const capacityHolds = await prisma.capacityHold.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const capacityHoldWithIdOnly = await prisma.capacityHold.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CapacityHoldFindManyArgs>(args?: SelectSubset<T, CapacityHoldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapacityHoldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CapacityHold.
     * @param {CapacityHoldCreateArgs} args - Arguments to create a CapacityHold.
     * @example
     * // Create one CapacityHold
     * const CapacityHold = await prisma.capacityHold.create({
     *   data: {
     *     // ... data to create a CapacityHold
     *   }
     * })
     * 
     */
    create<T extends CapacityHoldCreateArgs>(args: SelectSubset<T, CapacityHoldCreateArgs<ExtArgs>>): Prisma__CapacityHoldClient<$Result.GetResult<Prisma.$CapacityHoldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CapacityHolds.
     * @param {CapacityHoldCreateManyArgs} args - Arguments to create many CapacityHolds.
     * @example
     * // Create many CapacityHolds
     * const capacityHold = await prisma.capacityHold.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CapacityHoldCreateManyArgs>(args?: SelectSubset<T, CapacityHoldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CapacityHolds and returns the data saved in the database.
     * @param {CapacityHoldCreateManyAndReturnArgs} args - Arguments to create many CapacityHolds.
     * @example
     * // Create many CapacityHolds
     * const capacityHold = await prisma.capacityHold.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CapacityHolds and only return the `id`
     * const capacityHoldWithIdOnly = await prisma.capacityHold.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CapacityHoldCreateManyAndReturnArgs>(args?: SelectSubset<T, CapacityHoldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapacityHoldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CapacityHold.
     * @param {CapacityHoldDeleteArgs} args - Arguments to delete one CapacityHold.
     * @example
     * // Delete one CapacityHold
     * const CapacityHold = await prisma.capacityHold.delete({
     *   where: {
     *     // ... filter to delete one CapacityHold
     *   }
     * })
     * 
     */
    delete<T extends CapacityHoldDeleteArgs>(args: SelectSubset<T, CapacityHoldDeleteArgs<ExtArgs>>): Prisma__CapacityHoldClient<$Result.GetResult<Prisma.$CapacityHoldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CapacityHold.
     * @param {CapacityHoldUpdateArgs} args - Arguments to update one CapacityHold.
     * @example
     * // Update one CapacityHold
     * const capacityHold = await prisma.capacityHold.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CapacityHoldUpdateArgs>(args: SelectSubset<T, CapacityHoldUpdateArgs<ExtArgs>>): Prisma__CapacityHoldClient<$Result.GetResult<Prisma.$CapacityHoldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CapacityHolds.
     * @param {CapacityHoldDeleteManyArgs} args - Arguments to filter CapacityHolds to delete.
     * @example
     * // Delete a few CapacityHolds
     * const { count } = await prisma.capacityHold.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CapacityHoldDeleteManyArgs>(args?: SelectSubset<T, CapacityHoldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CapacityHolds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapacityHoldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CapacityHolds
     * const capacityHold = await prisma.capacityHold.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CapacityHoldUpdateManyArgs>(args: SelectSubset<T, CapacityHoldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CapacityHolds and returns the data updated in the database.
     * @param {CapacityHoldUpdateManyAndReturnArgs} args - Arguments to update many CapacityHolds.
     * @example
     * // Update many CapacityHolds
     * const capacityHold = await prisma.capacityHold.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CapacityHolds and only return the `id`
     * const capacityHoldWithIdOnly = await prisma.capacityHold.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CapacityHoldUpdateManyAndReturnArgs>(args: SelectSubset<T, CapacityHoldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapacityHoldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CapacityHold.
     * @param {CapacityHoldUpsertArgs} args - Arguments to update or create a CapacityHold.
     * @example
     * // Update or create a CapacityHold
     * const capacityHold = await prisma.capacityHold.upsert({
     *   create: {
     *     // ... data to create a CapacityHold
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CapacityHold we want to update
     *   }
     * })
     */
    upsert<T extends CapacityHoldUpsertArgs>(args: SelectSubset<T, CapacityHoldUpsertArgs<ExtArgs>>): Prisma__CapacityHoldClient<$Result.GetResult<Prisma.$CapacityHoldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CapacityHolds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapacityHoldCountArgs} args - Arguments to filter CapacityHolds to count.
     * @example
     * // Count the number of CapacityHolds
     * const count = await prisma.capacityHold.count({
     *   where: {
     *     // ... the filter for the CapacityHolds we want to count
     *   }
     * })
    **/
    count<T extends CapacityHoldCountArgs>(
      args?: Subset<T, CapacityHoldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CapacityHoldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CapacityHold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapacityHoldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CapacityHoldAggregateArgs>(args: Subset<T, CapacityHoldAggregateArgs>): Prisma.PrismaPromise<GetCapacityHoldAggregateType<T>>

    /**
     * Group by CapacityHold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapacityHoldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CapacityHoldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CapacityHoldGroupByArgs['orderBy'] }
        : { orderBy?: CapacityHoldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CapacityHoldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapacityHoldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CapacityHold model
   */
  readonly fields: CapacityHoldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CapacityHold.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CapacityHoldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offering<T extends MenuOfferingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuOfferingDefaultArgs<ExtArgs>>): Prisma__MenuOfferingClient<$Result.GetResult<Prisma.$MenuOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends CapacityHold$orderArgs<ExtArgs> = {}>(args?: Subset<T, CapacityHold$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CapacityHold model
   */
  interface CapacityHoldFieldRefs {
    readonly id: FieldRef<"CapacityHold", 'Int'>
    readonly menuOfferingId: FieldRef<"CapacityHold", 'Int'>
    readonly orderId: FieldRef<"CapacityHold", 'Int'>
    readonly quantity: FieldRef<"CapacityHold", 'Int'>
    readonly status: FieldRef<"CapacityHold", 'HoldStatus'>
    readonly expiresAt: FieldRef<"CapacityHold", 'DateTime'>
    readonly createdAt: FieldRef<"CapacityHold", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CapacityHold findUnique
   */
  export type CapacityHoldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapacityHold
     */
    select?: CapacityHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapacityHold
     */
    omit?: CapacityHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapacityHoldInclude<ExtArgs> | null
    /**
     * Filter, which CapacityHold to fetch.
     */
    where: CapacityHoldWhereUniqueInput
  }

  /**
   * CapacityHold findUniqueOrThrow
   */
  export type CapacityHoldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapacityHold
     */
    select?: CapacityHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapacityHold
     */
    omit?: CapacityHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapacityHoldInclude<ExtArgs> | null
    /**
     * Filter, which CapacityHold to fetch.
     */
    where: CapacityHoldWhereUniqueInput
  }

  /**
   * CapacityHold findFirst
   */
  export type CapacityHoldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapacityHold
     */
    select?: CapacityHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapacityHold
     */
    omit?: CapacityHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapacityHoldInclude<ExtArgs> | null
    /**
     * Filter, which CapacityHold to fetch.
     */
    where?: CapacityHoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapacityHolds to fetch.
     */
    orderBy?: CapacityHoldOrderByWithRelationInput | CapacityHoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CapacityHolds.
     */
    cursor?: CapacityHoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapacityHolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapacityHolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CapacityHolds.
     */
    distinct?: CapacityHoldScalarFieldEnum | CapacityHoldScalarFieldEnum[]
  }

  /**
   * CapacityHold findFirstOrThrow
   */
  export type CapacityHoldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapacityHold
     */
    select?: CapacityHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapacityHold
     */
    omit?: CapacityHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapacityHoldInclude<ExtArgs> | null
    /**
     * Filter, which CapacityHold to fetch.
     */
    where?: CapacityHoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapacityHolds to fetch.
     */
    orderBy?: CapacityHoldOrderByWithRelationInput | CapacityHoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CapacityHolds.
     */
    cursor?: CapacityHoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapacityHolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapacityHolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CapacityHolds.
     */
    distinct?: CapacityHoldScalarFieldEnum | CapacityHoldScalarFieldEnum[]
  }

  /**
   * CapacityHold findMany
   */
  export type CapacityHoldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapacityHold
     */
    select?: CapacityHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapacityHold
     */
    omit?: CapacityHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapacityHoldInclude<ExtArgs> | null
    /**
     * Filter, which CapacityHolds to fetch.
     */
    where?: CapacityHoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapacityHolds to fetch.
     */
    orderBy?: CapacityHoldOrderByWithRelationInput | CapacityHoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CapacityHolds.
     */
    cursor?: CapacityHoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapacityHolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapacityHolds.
     */
    skip?: number
    distinct?: CapacityHoldScalarFieldEnum | CapacityHoldScalarFieldEnum[]
  }

  /**
   * CapacityHold create
   */
  export type CapacityHoldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapacityHold
     */
    select?: CapacityHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapacityHold
     */
    omit?: CapacityHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapacityHoldInclude<ExtArgs> | null
    /**
     * The data needed to create a CapacityHold.
     */
    data: XOR<CapacityHoldCreateInput, CapacityHoldUncheckedCreateInput>
  }

  /**
   * CapacityHold createMany
   */
  export type CapacityHoldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CapacityHolds.
     */
    data: CapacityHoldCreateManyInput | CapacityHoldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CapacityHold createManyAndReturn
   */
  export type CapacityHoldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapacityHold
     */
    select?: CapacityHoldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CapacityHold
     */
    omit?: CapacityHoldOmit<ExtArgs> | null
    /**
     * The data used to create many CapacityHolds.
     */
    data: CapacityHoldCreateManyInput | CapacityHoldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapacityHoldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CapacityHold update
   */
  export type CapacityHoldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapacityHold
     */
    select?: CapacityHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapacityHold
     */
    omit?: CapacityHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapacityHoldInclude<ExtArgs> | null
    /**
     * The data needed to update a CapacityHold.
     */
    data: XOR<CapacityHoldUpdateInput, CapacityHoldUncheckedUpdateInput>
    /**
     * Choose, which CapacityHold to update.
     */
    where: CapacityHoldWhereUniqueInput
  }

  /**
   * CapacityHold updateMany
   */
  export type CapacityHoldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CapacityHolds.
     */
    data: XOR<CapacityHoldUpdateManyMutationInput, CapacityHoldUncheckedUpdateManyInput>
    /**
     * Filter which CapacityHolds to update
     */
    where?: CapacityHoldWhereInput
    /**
     * Limit how many CapacityHolds to update.
     */
    limit?: number
  }

  /**
   * CapacityHold updateManyAndReturn
   */
  export type CapacityHoldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapacityHold
     */
    select?: CapacityHoldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CapacityHold
     */
    omit?: CapacityHoldOmit<ExtArgs> | null
    /**
     * The data used to update CapacityHolds.
     */
    data: XOR<CapacityHoldUpdateManyMutationInput, CapacityHoldUncheckedUpdateManyInput>
    /**
     * Filter which CapacityHolds to update
     */
    where?: CapacityHoldWhereInput
    /**
     * Limit how many CapacityHolds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapacityHoldIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CapacityHold upsert
   */
  export type CapacityHoldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapacityHold
     */
    select?: CapacityHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapacityHold
     */
    omit?: CapacityHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapacityHoldInclude<ExtArgs> | null
    /**
     * The filter to search for the CapacityHold to update in case it exists.
     */
    where: CapacityHoldWhereUniqueInput
    /**
     * In case the CapacityHold found by the `where` argument doesn't exist, create a new CapacityHold with this data.
     */
    create: XOR<CapacityHoldCreateInput, CapacityHoldUncheckedCreateInput>
    /**
     * In case the CapacityHold was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CapacityHoldUpdateInput, CapacityHoldUncheckedUpdateInput>
  }

  /**
   * CapacityHold delete
   */
  export type CapacityHoldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapacityHold
     */
    select?: CapacityHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapacityHold
     */
    omit?: CapacityHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapacityHoldInclude<ExtArgs> | null
    /**
     * Filter which CapacityHold to delete.
     */
    where: CapacityHoldWhereUniqueInput
  }

  /**
   * CapacityHold deleteMany
   */
  export type CapacityHoldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CapacityHolds to delete
     */
    where?: CapacityHoldWhereInput
    /**
     * Limit how many CapacityHolds to delete.
     */
    limit?: number
  }

  /**
   * CapacityHold.order
   */
  export type CapacityHold$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * CapacityHold without action
   */
  export type CapacityHoldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapacityHold
     */
    select?: CapacityHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapacityHold
     */
    omit?: CapacityHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapacityHoldInclude<ExtArgs> | null
  }


  /**
   * Model Promotion
   */

  export type AggregatePromotion = {
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  export type PromotionAvgAggregateOutputType = {
    id: number | null
    amountCents: number | null
    percentBps: number | null
    minSubtotalCents: number | null
    maxRedemptions: number | null
    perUserLimit: number | null
  }

  export type PromotionSumAggregateOutputType = {
    id: number | null
    amountCents: number | null
    percentBps: number | null
    minSubtotalCents: number | null
    maxRedemptions: number | null
    perUserLimit: number | null
  }

  export type PromotionMinAggregateOutputType = {
    id: number | null
    code: string | null
    description: string | null
    type: $Enums.PromotionType | null
    amountCents: number | null
    percentBps: number | null
    minSubtotalCents: number | null
    maxRedemptions: number | null
    perUserLimit: number | null
    startsAt: Date | null
    endsAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionMaxAggregateOutputType = {
    id: number | null
    code: string | null
    description: string | null
    type: $Enums.PromotionType | null
    amountCents: number | null
    percentBps: number | null
    minSubtotalCents: number | null
    maxRedemptions: number | null
    perUserLimit: number | null
    startsAt: Date | null
    endsAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionCountAggregateOutputType = {
    id: number
    code: number
    description: number
    type: number
    amountCents: number
    percentBps: number
    minSubtotalCents: number
    maxRedemptions: number
    perUserLimit: number
    startsAt: number
    endsAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromotionAvgAggregateInputType = {
    id?: true
    amountCents?: true
    percentBps?: true
    minSubtotalCents?: true
    maxRedemptions?: true
    perUserLimit?: true
  }

  export type PromotionSumAggregateInputType = {
    id?: true
    amountCents?: true
    percentBps?: true
    minSubtotalCents?: true
    maxRedemptions?: true
    perUserLimit?: true
  }

  export type PromotionMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    type?: true
    amountCents?: true
    percentBps?: true
    minSubtotalCents?: true
    maxRedemptions?: true
    perUserLimit?: true
    startsAt?: true
    endsAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    type?: true
    amountCents?: true
    percentBps?: true
    minSubtotalCents?: true
    maxRedemptions?: true
    perUserLimit?: true
    startsAt?: true
    endsAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    type?: true
    amountCents?: true
    percentBps?: true
    minSubtotalCents?: true
    maxRedemptions?: true
    perUserLimit?: true
    startsAt?: true
    endsAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotion to aggregate.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promotions
    **/
    _count?: true | PromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionMaxAggregateInputType
  }

  export type GetPromotionAggregateType<T extends PromotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion[P]>
      : GetScalarType<T[P], AggregatePromotion[P]>
  }




  export type PromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithAggregationInput | PromotionOrderByWithAggregationInput[]
    by: PromotionScalarFieldEnum[] | PromotionScalarFieldEnum
    having?: PromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionCountAggregateInputType | true
    _avg?: PromotionAvgAggregateInputType
    _sum?: PromotionSumAggregateInputType
    _min?: PromotionMinAggregateInputType
    _max?: PromotionMaxAggregateInputType
  }

  export type PromotionGroupByOutputType = {
    id: number
    code: string
    description: string | null
    type: $Enums.PromotionType
    amountCents: number | null
    percentBps: number | null
    minSubtotalCents: number | null
    maxRedemptions: number | null
    perUserLimit: number | null
    startsAt: Date
    endsAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  type GetPromotionGroupByPayload<T extends PromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    type?: boolean
    amountCents?: boolean
    percentBps?: boolean
    minSubtotalCents?: boolean
    maxRedemptions?: boolean
    perUserLimit?: boolean
    startsAt?: boolean
    endsAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    redemptions?: boolean | Promotion$redemptionsArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    type?: boolean
    amountCents?: boolean
    percentBps?: boolean
    minSubtotalCents?: boolean
    maxRedemptions?: boolean
    perUserLimit?: boolean
    startsAt?: boolean
    endsAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    type?: boolean
    amountCents?: boolean
    percentBps?: boolean
    minSubtotalCents?: boolean
    maxRedemptions?: boolean
    perUserLimit?: boolean
    startsAt?: boolean
    endsAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    type?: boolean
    amountCents?: boolean
    percentBps?: boolean
    minSubtotalCents?: boolean
    maxRedemptions?: boolean
    perUserLimit?: boolean
    startsAt?: boolean
    endsAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromotionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "type" | "amountCents" | "percentBps" | "minSubtotalCents" | "maxRedemptions" | "perUserLimit" | "startsAt" | "endsAt" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["promotion"]>
  export type PromotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redemptions?: boolean | Promotion$redemptionsArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromotionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PromotionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promotion"
    objects: {
      redemptions: Prisma.$PromotionRedemptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      description: string | null
      type: $Enums.PromotionType
      amountCents: number | null
      percentBps: number | null
      minSubtotalCents: number | null
      maxRedemptions: number | null
      perUserLimit: number | null
      startsAt: Date
      endsAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["promotion"]>
    composites: {}
  }

  type PromotionGetPayload<S extends boolean | null | undefined | PromotionDefaultArgs> = $Result.GetResult<Prisma.$PromotionPayload, S>

  type PromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromotionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromotionCountAggregateInputType | true
    }

  export interface PromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promotion'], meta: { name: 'Promotion' } }
    /**
     * Find zero or one Promotion that matches the filter.
     * @param {PromotionFindUniqueArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionFindUniqueArgs>(args: SelectSubset<T, PromotionFindUniqueArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Promotion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromotionFindUniqueOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionFindFirstArgs>(args?: SelectSubset<T, PromotionFindFirstArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotions
     * const promotions = await prisma.promotion.findMany()
     * 
     * // Get first 10 Promotions
     * const promotions = await prisma.promotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionWithIdOnly = await prisma.promotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionFindManyArgs>(args?: SelectSubset<T, PromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Promotion.
     * @param {PromotionCreateArgs} args - Arguments to create a Promotion.
     * @example
     * // Create one Promotion
     * const Promotion = await prisma.promotion.create({
     *   data: {
     *     // ... data to create a Promotion
     *   }
     * })
     * 
     */
    create<T extends PromotionCreateArgs>(args: SelectSubset<T, PromotionCreateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Promotions.
     * @param {PromotionCreateManyArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionCreateManyArgs>(args?: SelectSubset<T, PromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Promotions and returns the data saved in the database.
     * @param {PromotionCreateManyAndReturnArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Promotion.
     * @param {PromotionDeleteArgs} args - Arguments to delete one Promotion.
     * @example
     * // Delete one Promotion
     * const Promotion = await prisma.promotion.delete({
     *   where: {
     *     // ... filter to delete one Promotion
     *   }
     * })
     * 
     */
    delete<T extends PromotionDeleteArgs>(args: SelectSubset<T, PromotionDeleteArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Promotion.
     * @param {PromotionUpdateArgs} args - Arguments to update one Promotion.
     * @example
     * // Update one Promotion
     * const promotion = await prisma.promotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionUpdateArgs>(args: SelectSubset<T, PromotionUpdateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Promotions.
     * @param {PromotionDeleteManyArgs} args - Arguments to filter Promotions to delete.
     * @example
     * // Delete a few Promotions
     * const { count } = await prisma.promotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionDeleteManyArgs>(args?: SelectSubset<T, PromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionUpdateManyArgs>(args: SelectSubset<T, PromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions and returns the data updated in the database.
     * @param {PromotionUpdateManyAndReturnArgs} args - Arguments to update many Promotions.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromotionUpdateManyAndReturnArgs>(args: SelectSubset<T, PromotionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Promotion.
     * @param {PromotionUpsertArgs} args - Arguments to update or create a Promotion.
     * @example
     * // Update or create a Promotion
     * const promotion = await prisma.promotion.upsert({
     *   create: {
     *     // ... data to create a Promotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion we want to update
     *   }
     * })
     */
    upsert<T extends PromotionUpsertArgs>(args: SelectSubset<T, PromotionUpsertArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCountArgs} args - Arguments to filter Promotions to count.
     * @example
     * // Count the number of Promotions
     * const count = await prisma.promotion.count({
     *   where: {
     *     // ... the filter for the Promotions we want to count
     *   }
     * })
    **/
    count<T extends PromotionCountArgs>(
      args?: Subset<T, PromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionAggregateArgs>(args: Subset<T, PromotionAggregateArgs>): Prisma.PrismaPromise<GetPromotionAggregateType<T>>

    /**
     * Group by Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promotion model
   */
  readonly fields: PromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    redemptions<T extends Promotion$redemptionsArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$redemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promotion model
   */
  interface PromotionFieldRefs {
    readonly id: FieldRef<"Promotion", 'Int'>
    readonly code: FieldRef<"Promotion", 'String'>
    readonly description: FieldRef<"Promotion", 'String'>
    readonly type: FieldRef<"Promotion", 'PromotionType'>
    readonly amountCents: FieldRef<"Promotion", 'Int'>
    readonly percentBps: FieldRef<"Promotion", 'Int'>
    readonly minSubtotalCents: FieldRef<"Promotion", 'Int'>
    readonly maxRedemptions: FieldRef<"Promotion", 'Int'>
    readonly perUserLimit: FieldRef<"Promotion", 'Int'>
    readonly startsAt: FieldRef<"Promotion", 'DateTime'>
    readonly endsAt: FieldRef<"Promotion", 'DateTime'>
    readonly isActive: FieldRef<"Promotion", 'Boolean'>
    readonly createdAt: FieldRef<"Promotion", 'DateTime'>
    readonly updatedAt: FieldRef<"Promotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Promotion findUnique
   */
  export type PromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findUniqueOrThrow
   */
  export type PromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findFirst
   */
  export type PromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findFirstOrThrow
   */
  export type PromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findMany
   */
  export type PromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotions to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion create
   */
  export type PromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a Promotion.
     */
    data: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
  }

  /**
   * Promotion createMany
   */
  export type PromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion createManyAndReturn
   */
  export type PromotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion update
   */
  export type PromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a Promotion.
     */
    data: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
    /**
     * Choose, which Promotion to update.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion updateMany
   */
  export type PromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
  }

  /**
   * Promotion updateManyAndReturn
   */
  export type PromotionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
  }

  /**
   * Promotion upsert
   */
  export type PromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the Promotion to update in case it exists.
     */
    where: PromotionWhereUniqueInput
    /**
     * In case the Promotion found by the `where` argument doesn't exist, create a new Promotion with this data.
     */
    create: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
    /**
     * In case the Promotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
  }

  /**
   * Promotion delete
   */
  export type PromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter which Promotion to delete.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion deleteMany
   */
  export type PromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotions to delete
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to delete.
     */
    limit?: number
  }

  /**
   * Promotion.redemptions
   */
  export type Promotion$redemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    where?: PromotionRedemptionWhereInput
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    cursor?: PromotionRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * Promotion without action
   */
  export type PromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
  }


  /**
   * Model PromotionRedemption
   */

  export type AggregatePromotionRedemption = {
    _count: PromotionRedemptionCountAggregateOutputType | null
    _avg: PromotionRedemptionAvgAggregateOutputType | null
    _sum: PromotionRedemptionSumAggregateOutputType | null
    _min: PromotionRedemptionMinAggregateOutputType | null
    _max: PromotionRedemptionMaxAggregateOutputType | null
  }

  export type PromotionRedemptionAvgAggregateOutputType = {
    id: number | null
    promotionId: number | null
    orderId: number | null
    userId: number | null
    discountCentsApplied: number | null
  }

  export type PromotionRedemptionSumAggregateOutputType = {
    id: number | null
    promotionId: number | null
    orderId: number | null
    userId: number | null
    discountCentsApplied: number | null
  }

  export type PromotionRedemptionMinAggregateOutputType = {
    id: number | null
    promotionId: number | null
    orderId: number | null
    userId: number | null
    discountCentsApplied: number | null
    createdAt: Date | null
  }

  export type PromotionRedemptionMaxAggregateOutputType = {
    id: number | null
    promotionId: number | null
    orderId: number | null
    userId: number | null
    discountCentsApplied: number | null
    createdAt: Date | null
  }

  export type PromotionRedemptionCountAggregateOutputType = {
    id: number
    promotionId: number
    orderId: number
    userId: number
    discountCentsApplied: number
    createdAt: number
    _all: number
  }


  export type PromotionRedemptionAvgAggregateInputType = {
    id?: true
    promotionId?: true
    orderId?: true
    userId?: true
    discountCentsApplied?: true
  }

  export type PromotionRedemptionSumAggregateInputType = {
    id?: true
    promotionId?: true
    orderId?: true
    userId?: true
    discountCentsApplied?: true
  }

  export type PromotionRedemptionMinAggregateInputType = {
    id?: true
    promotionId?: true
    orderId?: true
    userId?: true
    discountCentsApplied?: true
    createdAt?: true
  }

  export type PromotionRedemptionMaxAggregateInputType = {
    id?: true
    promotionId?: true
    orderId?: true
    userId?: true
    discountCentsApplied?: true
    createdAt?: true
  }

  export type PromotionRedemptionCountAggregateInputType = {
    id?: true
    promotionId?: true
    orderId?: true
    userId?: true
    discountCentsApplied?: true
    createdAt?: true
    _all?: true
  }

  export type PromotionRedemptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionRedemption to aggregate.
     */
    where?: PromotionRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionRedemptions to fetch.
     */
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromotionRedemptions
    **/
    _count?: true | PromotionRedemptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionRedemptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionRedemptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionRedemptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionRedemptionMaxAggregateInputType
  }

  export type GetPromotionRedemptionAggregateType<T extends PromotionRedemptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotionRedemption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotionRedemption[P]>
      : GetScalarType<T[P], AggregatePromotionRedemption[P]>
  }




  export type PromotionRedemptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionRedemptionWhereInput
    orderBy?: PromotionRedemptionOrderByWithAggregationInput | PromotionRedemptionOrderByWithAggregationInput[]
    by: PromotionRedemptionScalarFieldEnum[] | PromotionRedemptionScalarFieldEnum
    having?: PromotionRedemptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionRedemptionCountAggregateInputType | true
    _avg?: PromotionRedemptionAvgAggregateInputType
    _sum?: PromotionRedemptionSumAggregateInputType
    _min?: PromotionRedemptionMinAggregateInputType
    _max?: PromotionRedemptionMaxAggregateInputType
  }

  export type PromotionRedemptionGroupByOutputType = {
    id: number
    promotionId: number
    orderId: number
    userId: number | null
    discountCentsApplied: number
    createdAt: Date
    _count: PromotionRedemptionCountAggregateOutputType | null
    _avg: PromotionRedemptionAvgAggregateOutputType | null
    _sum: PromotionRedemptionSumAggregateOutputType | null
    _min: PromotionRedemptionMinAggregateOutputType | null
    _max: PromotionRedemptionMaxAggregateOutputType | null
  }

  type GetPromotionRedemptionGroupByPayload<T extends PromotionRedemptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionRedemptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionRedemptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionRedemptionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionRedemptionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionRedemptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    orderId?: boolean
    userId?: boolean
    discountCentsApplied?: boolean
    createdAt?: boolean
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | PromotionRedemption$userArgs<ExtArgs>
  }, ExtArgs["result"]["promotionRedemption"]>

  export type PromotionRedemptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    orderId?: boolean
    userId?: boolean
    discountCentsApplied?: boolean
    createdAt?: boolean
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | PromotionRedemption$userArgs<ExtArgs>
  }, ExtArgs["result"]["promotionRedemption"]>

  export type PromotionRedemptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    orderId?: boolean
    userId?: boolean
    discountCentsApplied?: boolean
    createdAt?: boolean
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | PromotionRedemption$userArgs<ExtArgs>
  }, ExtArgs["result"]["promotionRedemption"]>

  export type PromotionRedemptionSelectScalar = {
    id?: boolean
    promotionId?: boolean
    orderId?: boolean
    userId?: boolean
    discountCentsApplied?: boolean
    createdAt?: boolean
  }

  export type PromotionRedemptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "promotionId" | "orderId" | "userId" | "discountCentsApplied" | "createdAt", ExtArgs["result"]["promotionRedemption"]>
  export type PromotionRedemptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | PromotionRedemption$userArgs<ExtArgs>
  }
  export type PromotionRedemptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | PromotionRedemption$userArgs<ExtArgs>
  }
  export type PromotionRedemptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | PromotionRedemption$userArgs<ExtArgs>
  }

  export type $PromotionRedemptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromotionRedemption"
    objects: {
      promotion: Prisma.$PromotionPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      promotionId: number
      orderId: number
      userId: number | null
      discountCentsApplied: number
      createdAt: Date
    }, ExtArgs["result"]["promotionRedemption"]>
    composites: {}
  }

  type PromotionRedemptionGetPayload<S extends boolean | null | undefined | PromotionRedemptionDefaultArgs> = $Result.GetResult<Prisma.$PromotionRedemptionPayload, S>

  type PromotionRedemptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromotionRedemptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromotionRedemptionCountAggregateInputType | true
    }

  export interface PromotionRedemptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromotionRedemption'], meta: { name: 'PromotionRedemption' } }
    /**
     * Find zero or one PromotionRedemption that matches the filter.
     * @param {PromotionRedemptionFindUniqueArgs} args - Arguments to find a PromotionRedemption
     * @example
     * // Get one PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionRedemptionFindUniqueArgs>(args: SelectSubset<T, PromotionRedemptionFindUniqueArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromotionRedemption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromotionRedemptionFindUniqueOrThrowArgs} args - Arguments to find a PromotionRedemption
     * @example
     * // Get one PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionRedemptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionRedemptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromotionRedemption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionFindFirstArgs} args - Arguments to find a PromotionRedemption
     * @example
     * // Get one PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionRedemptionFindFirstArgs>(args?: SelectSubset<T, PromotionRedemptionFindFirstArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromotionRedemption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionFindFirstOrThrowArgs} args - Arguments to find a PromotionRedemption
     * @example
     * // Get one PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionRedemptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionRedemptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromotionRedemptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromotionRedemptions
     * const promotionRedemptions = await prisma.promotionRedemption.findMany()
     * 
     * // Get first 10 PromotionRedemptions
     * const promotionRedemptions = await prisma.promotionRedemption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionRedemptionWithIdOnly = await prisma.promotionRedemption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionRedemptionFindManyArgs>(args?: SelectSubset<T, PromotionRedemptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromotionRedemption.
     * @param {PromotionRedemptionCreateArgs} args - Arguments to create a PromotionRedemption.
     * @example
     * // Create one PromotionRedemption
     * const PromotionRedemption = await prisma.promotionRedemption.create({
     *   data: {
     *     // ... data to create a PromotionRedemption
     *   }
     * })
     * 
     */
    create<T extends PromotionRedemptionCreateArgs>(args: SelectSubset<T, PromotionRedemptionCreateArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromotionRedemptions.
     * @param {PromotionRedemptionCreateManyArgs} args - Arguments to create many PromotionRedemptions.
     * @example
     * // Create many PromotionRedemptions
     * const promotionRedemption = await prisma.promotionRedemption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionRedemptionCreateManyArgs>(args?: SelectSubset<T, PromotionRedemptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromotionRedemptions and returns the data saved in the database.
     * @param {PromotionRedemptionCreateManyAndReturnArgs} args - Arguments to create many PromotionRedemptions.
     * @example
     * // Create many PromotionRedemptions
     * const promotionRedemption = await prisma.promotionRedemption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromotionRedemptions and only return the `id`
     * const promotionRedemptionWithIdOnly = await prisma.promotionRedemption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionRedemptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionRedemptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromotionRedemption.
     * @param {PromotionRedemptionDeleteArgs} args - Arguments to delete one PromotionRedemption.
     * @example
     * // Delete one PromotionRedemption
     * const PromotionRedemption = await prisma.promotionRedemption.delete({
     *   where: {
     *     // ... filter to delete one PromotionRedemption
     *   }
     * })
     * 
     */
    delete<T extends PromotionRedemptionDeleteArgs>(args: SelectSubset<T, PromotionRedemptionDeleteArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromotionRedemption.
     * @param {PromotionRedemptionUpdateArgs} args - Arguments to update one PromotionRedemption.
     * @example
     * // Update one PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionRedemptionUpdateArgs>(args: SelectSubset<T, PromotionRedemptionUpdateArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromotionRedemptions.
     * @param {PromotionRedemptionDeleteManyArgs} args - Arguments to filter PromotionRedemptions to delete.
     * @example
     * // Delete a few PromotionRedemptions
     * const { count } = await prisma.promotionRedemption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionRedemptionDeleteManyArgs>(args?: SelectSubset<T, PromotionRedemptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionRedemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromotionRedemptions
     * const promotionRedemption = await prisma.promotionRedemption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionRedemptionUpdateManyArgs>(args: SelectSubset<T, PromotionRedemptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionRedemptions and returns the data updated in the database.
     * @param {PromotionRedemptionUpdateManyAndReturnArgs} args - Arguments to update many PromotionRedemptions.
     * @example
     * // Update many PromotionRedemptions
     * const promotionRedemption = await prisma.promotionRedemption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromotionRedemptions and only return the `id`
     * const promotionRedemptionWithIdOnly = await prisma.promotionRedemption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromotionRedemptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PromotionRedemptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromotionRedemption.
     * @param {PromotionRedemptionUpsertArgs} args - Arguments to update or create a PromotionRedemption.
     * @example
     * // Update or create a PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.upsert({
     *   create: {
     *     // ... data to create a PromotionRedemption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromotionRedemption we want to update
     *   }
     * })
     */
    upsert<T extends PromotionRedemptionUpsertArgs>(args: SelectSubset<T, PromotionRedemptionUpsertArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromotionRedemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionCountArgs} args - Arguments to filter PromotionRedemptions to count.
     * @example
     * // Count the number of PromotionRedemptions
     * const count = await prisma.promotionRedemption.count({
     *   where: {
     *     // ... the filter for the PromotionRedemptions we want to count
     *   }
     * })
    **/
    count<T extends PromotionRedemptionCountArgs>(
      args?: Subset<T, PromotionRedemptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionRedemptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromotionRedemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionRedemptionAggregateArgs>(args: Subset<T, PromotionRedemptionAggregateArgs>): Prisma.PrismaPromise<GetPromotionRedemptionAggregateType<T>>

    /**
     * Group by PromotionRedemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionRedemptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionRedemptionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionRedemptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionRedemptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionRedemptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromotionRedemption model
   */
  readonly fields: PromotionRedemptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromotionRedemption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionRedemptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    promotion<T extends PromotionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromotionDefaultArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends PromotionRedemption$userArgs<ExtArgs> = {}>(args?: Subset<T, PromotionRedemption$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromotionRedemption model
   */
  interface PromotionRedemptionFieldRefs {
    readonly id: FieldRef<"PromotionRedemption", 'Int'>
    readonly promotionId: FieldRef<"PromotionRedemption", 'Int'>
    readonly orderId: FieldRef<"PromotionRedemption", 'Int'>
    readonly userId: FieldRef<"PromotionRedemption", 'Int'>
    readonly discountCentsApplied: FieldRef<"PromotionRedemption", 'Int'>
    readonly createdAt: FieldRef<"PromotionRedemption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromotionRedemption findUnique
   */
  export type PromotionRedemptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRedemption to fetch.
     */
    where: PromotionRedemptionWhereUniqueInput
  }

  /**
   * PromotionRedemption findUniqueOrThrow
   */
  export type PromotionRedemptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRedemption to fetch.
     */
    where: PromotionRedemptionWhereUniqueInput
  }

  /**
   * PromotionRedemption findFirst
   */
  export type PromotionRedemptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRedemption to fetch.
     */
    where?: PromotionRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionRedemptions to fetch.
     */
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionRedemptions.
     */
    cursor?: PromotionRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionRedemptions.
     */
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * PromotionRedemption findFirstOrThrow
   */
  export type PromotionRedemptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRedemption to fetch.
     */
    where?: PromotionRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionRedemptions to fetch.
     */
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionRedemptions.
     */
    cursor?: PromotionRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionRedemptions.
     */
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * PromotionRedemption findMany
   */
  export type PromotionRedemptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRedemptions to fetch.
     */
    where?: PromotionRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionRedemptions to fetch.
     */
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromotionRedemptions.
     */
    cursor?: PromotionRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionRedemptions.
     */
    skip?: number
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * PromotionRedemption create
   */
  export type PromotionRedemptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PromotionRedemption.
     */
    data: XOR<PromotionRedemptionCreateInput, PromotionRedemptionUncheckedCreateInput>
  }

  /**
   * PromotionRedemption createMany
   */
  export type PromotionRedemptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromotionRedemptions.
     */
    data: PromotionRedemptionCreateManyInput | PromotionRedemptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromotionRedemption createManyAndReturn
   */
  export type PromotionRedemptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * The data used to create many PromotionRedemptions.
     */
    data: PromotionRedemptionCreateManyInput | PromotionRedemptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromotionRedemption update
   */
  export type PromotionRedemptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PromotionRedemption.
     */
    data: XOR<PromotionRedemptionUpdateInput, PromotionRedemptionUncheckedUpdateInput>
    /**
     * Choose, which PromotionRedemption to update.
     */
    where: PromotionRedemptionWhereUniqueInput
  }

  /**
   * PromotionRedemption updateMany
   */
  export type PromotionRedemptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromotionRedemptions.
     */
    data: XOR<PromotionRedemptionUpdateManyMutationInput, PromotionRedemptionUncheckedUpdateManyInput>
    /**
     * Filter which PromotionRedemptions to update
     */
    where?: PromotionRedemptionWhereInput
    /**
     * Limit how many PromotionRedemptions to update.
     */
    limit?: number
  }

  /**
   * PromotionRedemption updateManyAndReturn
   */
  export type PromotionRedemptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * The data used to update PromotionRedemptions.
     */
    data: XOR<PromotionRedemptionUpdateManyMutationInput, PromotionRedemptionUncheckedUpdateManyInput>
    /**
     * Filter which PromotionRedemptions to update
     */
    where?: PromotionRedemptionWhereInput
    /**
     * Limit how many PromotionRedemptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromotionRedemption upsert
   */
  export type PromotionRedemptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PromotionRedemption to update in case it exists.
     */
    where: PromotionRedemptionWhereUniqueInput
    /**
     * In case the PromotionRedemption found by the `where` argument doesn't exist, create a new PromotionRedemption with this data.
     */
    create: XOR<PromotionRedemptionCreateInput, PromotionRedemptionUncheckedCreateInput>
    /**
     * In case the PromotionRedemption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionRedemptionUpdateInput, PromotionRedemptionUncheckedUpdateInput>
  }

  /**
   * PromotionRedemption delete
   */
  export type PromotionRedemptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter which PromotionRedemption to delete.
     */
    where: PromotionRedemptionWhereUniqueInput
  }

  /**
   * PromotionRedemption deleteMany
   */
  export type PromotionRedemptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionRedemptions to delete
     */
    where?: PromotionRedemptionWhereInput
    /**
     * Limit how many PromotionRedemptions to delete.
     */
    limit?: number
  }

  /**
   * PromotionRedemption.user
   */
  export type PromotionRedemption$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PromotionRedemption without action
   */
  export type PromotionRedemptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
  }


  /**
   * Model RewardAccount
   */

  export type AggregateRewardAccount = {
    _count: RewardAccountCountAggregateOutputType | null
    _avg: RewardAccountAvgAggregateOutputType | null
    _sum: RewardAccountSumAggregateOutputType | null
    _min: RewardAccountMinAggregateOutputType | null
    _max: RewardAccountMaxAggregateOutputType | null
  }

  export type RewardAccountAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    balancePoints: number | null
  }

  export type RewardAccountSumAggregateOutputType = {
    id: number | null
    userId: number | null
    balancePoints: number | null
  }

  export type RewardAccountMinAggregateOutputType = {
    id: number | null
    userId: number | null
    balancePoints: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RewardAccountMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    balancePoints: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RewardAccountCountAggregateOutputType = {
    id: number
    userId: number
    balancePoints: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RewardAccountAvgAggregateInputType = {
    id?: true
    userId?: true
    balancePoints?: true
  }

  export type RewardAccountSumAggregateInputType = {
    id?: true
    userId?: true
    balancePoints?: true
  }

  export type RewardAccountMinAggregateInputType = {
    id?: true
    userId?: true
    balancePoints?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RewardAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    balancePoints?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RewardAccountCountAggregateInputType = {
    id?: true
    userId?: true
    balancePoints?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RewardAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardAccount to aggregate.
     */
    where?: RewardAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardAccounts to fetch.
     */
    orderBy?: RewardAccountOrderByWithRelationInput | RewardAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RewardAccounts
    **/
    _count?: true | RewardAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardAccountMaxAggregateInputType
  }

  export type GetRewardAccountAggregateType<T extends RewardAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateRewardAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewardAccount[P]>
      : GetScalarType<T[P], AggregateRewardAccount[P]>
  }




  export type RewardAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardAccountWhereInput
    orderBy?: RewardAccountOrderByWithAggregationInput | RewardAccountOrderByWithAggregationInput[]
    by: RewardAccountScalarFieldEnum[] | RewardAccountScalarFieldEnum
    having?: RewardAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardAccountCountAggregateInputType | true
    _avg?: RewardAccountAvgAggregateInputType
    _sum?: RewardAccountSumAggregateInputType
    _min?: RewardAccountMinAggregateInputType
    _max?: RewardAccountMaxAggregateInputType
  }

  export type RewardAccountGroupByOutputType = {
    id: number
    userId: number
    balancePoints: number
    createdAt: Date
    updatedAt: Date
    _count: RewardAccountCountAggregateOutputType | null
    _avg: RewardAccountAvgAggregateOutputType | null
    _sum: RewardAccountSumAggregateOutputType | null
    _min: RewardAccountMinAggregateOutputType | null
    _max: RewardAccountMaxAggregateOutputType | null
  }

  type GetRewardAccountGroupByPayload<T extends RewardAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardAccountGroupByOutputType[P]>
            : GetScalarType<T[P], RewardAccountGroupByOutputType[P]>
        }
      >
    >


  export type RewardAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balancePoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    txns?: boolean | RewardAccount$txnsArgs<ExtArgs>
    _count?: boolean | RewardAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewardAccount"]>

  export type RewardAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balancePoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewardAccount"]>

  export type RewardAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balancePoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewardAccount"]>

  export type RewardAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    balancePoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RewardAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "balancePoints" | "createdAt" | "updatedAt", ExtArgs["result"]["rewardAccount"]>
  export type RewardAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    txns?: boolean | RewardAccount$txnsArgs<ExtArgs>
    _count?: boolean | RewardAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RewardAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RewardAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RewardAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RewardAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      txns: Prisma.$RewardTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      balancePoints: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rewardAccount"]>
    composites: {}
  }

  type RewardAccountGetPayload<S extends boolean | null | undefined | RewardAccountDefaultArgs> = $Result.GetResult<Prisma.$RewardAccountPayload, S>

  type RewardAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RewardAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RewardAccountCountAggregateInputType | true
    }

  export interface RewardAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RewardAccount'], meta: { name: 'RewardAccount' } }
    /**
     * Find zero or one RewardAccount that matches the filter.
     * @param {RewardAccountFindUniqueArgs} args - Arguments to find a RewardAccount
     * @example
     * // Get one RewardAccount
     * const rewardAccount = await prisma.rewardAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardAccountFindUniqueArgs>(args: SelectSubset<T, RewardAccountFindUniqueArgs<ExtArgs>>): Prisma__RewardAccountClient<$Result.GetResult<Prisma.$RewardAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RewardAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RewardAccountFindUniqueOrThrowArgs} args - Arguments to find a RewardAccount
     * @example
     * // Get one RewardAccount
     * const rewardAccount = await prisma.rewardAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardAccountClient<$Result.GetResult<Prisma.$RewardAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RewardAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccountFindFirstArgs} args - Arguments to find a RewardAccount
     * @example
     * // Get one RewardAccount
     * const rewardAccount = await prisma.rewardAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardAccountFindFirstArgs>(args?: SelectSubset<T, RewardAccountFindFirstArgs<ExtArgs>>): Prisma__RewardAccountClient<$Result.GetResult<Prisma.$RewardAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RewardAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccountFindFirstOrThrowArgs} args - Arguments to find a RewardAccount
     * @example
     * // Get one RewardAccount
     * const rewardAccount = await prisma.rewardAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardAccountClient<$Result.GetResult<Prisma.$RewardAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RewardAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RewardAccounts
     * const rewardAccounts = await prisma.rewardAccount.findMany()
     * 
     * // Get first 10 RewardAccounts
     * const rewardAccounts = await prisma.rewardAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardAccountWithIdOnly = await prisma.rewardAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RewardAccountFindManyArgs>(args?: SelectSubset<T, RewardAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RewardAccount.
     * @param {RewardAccountCreateArgs} args - Arguments to create a RewardAccount.
     * @example
     * // Create one RewardAccount
     * const RewardAccount = await prisma.rewardAccount.create({
     *   data: {
     *     // ... data to create a RewardAccount
     *   }
     * })
     * 
     */
    create<T extends RewardAccountCreateArgs>(args: SelectSubset<T, RewardAccountCreateArgs<ExtArgs>>): Prisma__RewardAccountClient<$Result.GetResult<Prisma.$RewardAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RewardAccounts.
     * @param {RewardAccountCreateManyArgs} args - Arguments to create many RewardAccounts.
     * @example
     * // Create many RewardAccounts
     * const rewardAccount = await prisma.rewardAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardAccountCreateManyArgs>(args?: SelectSubset<T, RewardAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RewardAccounts and returns the data saved in the database.
     * @param {RewardAccountCreateManyAndReturnArgs} args - Arguments to create many RewardAccounts.
     * @example
     * // Create many RewardAccounts
     * const rewardAccount = await prisma.rewardAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RewardAccounts and only return the `id`
     * const rewardAccountWithIdOnly = await prisma.rewardAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RewardAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, RewardAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RewardAccount.
     * @param {RewardAccountDeleteArgs} args - Arguments to delete one RewardAccount.
     * @example
     * // Delete one RewardAccount
     * const RewardAccount = await prisma.rewardAccount.delete({
     *   where: {
     *     // ... filter to delete one RewardAccount
     *   }
     * })
     * 
     */
    delete<T extends RewardAccountDeleteArgs>(args: SelectSubset<T, RewardAccountDeleteArgs<ExtArgs>>): Prisma__RewardAccountClient<$Result.GetResult<Prisma.$RewardAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RewardAccount.
     * @param {RewardAccountUpdateArgs} args - Arguments to update one RewardAccount.
     * @example
     * // Update one RewardAccount
     * const rewardAccount = await prisma.rewardAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardAccountUpdateArgs>(args: SelectSubset<T, RewardAccountUpdateArgs<ExtArgs>>): Prisma__RewardAccountClient<$Result.GetResult<Prisma.$RewardAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RewardAccounts.
     * @param {RewardAccountDeleteManyArgs} args - Arguments to filter RewardAccounts to delete.
     * @example
     * // Delete a few RewardAccounts
     * const { count } = await prisma.rewardAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardAccountDeleteManyArgs>(args?: SelectSubset<T, RewardAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RewardAccounts
     * const rewardAccount = await prisma.rewardAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardAccountUpdateManyArgs>(args: SelectSubset<T, RewardAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardAccounts and returns the data updated in the database.
     * @param {RewardAccountUpdateManyAndReturnArgs} args - Arguments to update many RewardAccounts.
     * @example
     * // Update many RewardAccounts
     * const rewardAccount = await prisma.rewardAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RewardAccounts and only return the `id`
     * const rewardAccountWithIdOnly = await prisma.rewardAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RewardAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, RewardAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RewardAccount.
     * @param {RewardAccountUpsertArgs} args - Arguments to update or create a RewardAccount.
     * @example
     * // Update or create a RewardAccount
     * const rewardAccount = await prisma.rewardAccount.upsert({
     *   create: {
     *     // ... data to create a RewardAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RewardAccount we want to update
     *   }
     * })
     */
    upsert<T extends RewardAccountUpsertArgs>(args: SelectSubset<T, RewardAccountUpsertArgs<ExtArgs>>): Prisma__RewardAccountClient<$Result.GetResult<Prisma.$RewardAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RewardAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccountCountArgs} args - Arguments to filter RewardAccounts to count.
     * @example
     * // Count the number of RewardAccounts
     * const count = await prisma.rewardAccount.count({
     *   where: {
     *     // ... the filter for the RewardAccounts we want to count
     *   }
     * })
    **/
    count<T extends RewardAccountCountArgs>(
      args?: Subset<T, RewardAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RewardAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardAccountAggregateArgs>(args: Subset<T, RewardAccountAggregateArgs>): Prisma.PrismaPromise<GetRewardAccountAggregateType<T>>

    /**
     * Group by RewardAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardAccountGroupByArgs['orderBy'] }
        : { orderBy?: RewardAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RewardAccount model
   */
  readonly fields: RewardAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RewardAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    txns<T extends RewardAccount$txnsArgs<ExtArgs> = {}>(args?: Subset<T, RewardAccount$txnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RewardAccount model
   */
  interface RewardAccountFieldRefs {
    readonly id: FieldRef<"RewardAccount", 'Int'>
    readonly userId: FieldRef<"RewardAccount", 'Int'>
    readonly balancePoints: FieldRef<"RewardAccount", 'Int'>
    readonly createdAt: FieldRef<"RewardAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"RewardAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RewardAccount findUnique
   */
  export type RewardAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccount
     */
    select?: RewardAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccount
     */
    omit?: RewardAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccountInclude<ExtArgs> | null
    /**
     * Filter, which RewardAccount to fetch.
     */
    where: RewardAccountWhereUniqueInput
  }

  /**
   * RewardAccount findUniqueOrThrow
   */
  export type RewardAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccount
     */
    select?: RewardAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccount
     */
    omit?: RewardAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccountInclude<ExtArgs> | null
    /**
     * Filter, which RewardAccount to fetch.
     */
    where: RewardAccountWhereUniqueInput
  }

  /**
   * RewardAccount findFirst
   */
  export type RewardAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccount
     */
    select?: RewardAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccount
     */
    omit?: RewardAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccountInclude<ExtArgs> | null
    /**
     * Filter, which RewardAccount to fetch.
     */
    where?: RewardAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardAccounts to fetch.
     */
    orderBy?: RewardAccountOrderByWithRelationInput | RewardAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardAccounts.
     */
    cursor?: RewardAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardAccounts.
     */
    distinct?: RewardAccountScalarFieldEnum | RewardAccountScalarFieldEnum[]
  }

  /**
   * RewardAccount findFirstOrThrow
   */
  export type RewardAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccount
     */
    select?: RewardAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccount
     */
    omit?: RewardAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccountInclude<ExtArgs> | null
    /**
     * Filter, which RewardAccount to fetch.
     */
    where?: RewardAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardAccounts to fetch.
     */
    orderBy?: RewardAccountOrderByWithRelationInput | RewardAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardAccounts.
     */
    cursor?: RewardAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardAccounts.
     */
    distinct?: RewardAccountScalarFieldEnum | RewardAccountScalarFieldEnum[]
  }

  /**
   * RewardAccount findMany
   */
  export type RewardAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccount
     */
    select?: RewardAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccount
     */
    omit?: RewardAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccountInclude<ExtArgs> | null
    /**
     * Filter, which RewardAccounts to fetch.
     */
    where?: RewardAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardAccounts to fetch.
     */
    orderBy?: RewardAccountOrderByWithRelationInput | RewardAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RewardAccounts.
     */
    cursor?: RewardAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardAccounts.
     */
    skip?: number
    distinct?: RewardAccountScalarFieldEnum | RewardAccountScalarFieldEnum[]
  }

  /**
   * RewardAccount create
   */
  export type RewardAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccount
     */
    select?: RewardAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccount
     */
    omit?: RewardAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a RewardAccount.
     */
    data: XOR<RewardAccountCreateInput, RewardAccountUncheckedCreateInput>
  }

  /**
   * RewardAccount createMany
   */
  export type RewardAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RewardAccounts.
     */
    data: RewardAccountCreateManyInput | RewardAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RewardAccount createManyAndReturn
   */
  export type RewardAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccount
     */
    select?: RewardAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccount
     */
    omit?: RewardAccountOmit<ExtArgs> | null
    /**
     * The data used to create many RewardAccounts.
     */
    data: RewardAccountCreateManyInput | RewardAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RewardAccount update
   */
  export type RewardAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccount
     */
    select?: RewardAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccount
     */
    omit?: RewardAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a RewardAccount.
     */
    data: XOR<RewardAccountUpdateInput, RewardAccountUncheckedUpdateInput>
    /**
     * Choose, which RewardAccount to update.
     */
    where: RewardAccountWhereUniqueInput
  }

  /**
   * RewardAccount updateMany
   */
  export type RewardAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RewardAccounts.
     */
    data: XOR<RewardAccountUpdateManyMutationInput, RewardAccountUncheckedUpdateManyInput>
    /**
     * Filter which RewardAccounts to update
     */
    where?: RewardAccountWhereInput
    /**
     * Limit how many RewardAccounts to update.
     */
    limit?: number
  }

  /**
   * RewardAccount updateManyAndReturn
   */
  export type RewardAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccount
     */
    select?: RewardAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccount
     */
    omit?: RewardAccountOmit<ExtArgs> | null
    /**
     * The data used to update RewardAccounts.
     */
    data: XOR<RewardAccountUpdateManyMutationInput, RewardAccountUncheckedUpdateManyInput>
    /**
     * Filter which RewardAccounts to update
     */
    where?: RewardAccountWhereInput
    /**
     * Limit how many RewardAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RewardAccount upsert
   */
  export type RewardAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccount
     */
    select?: RewardAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccount
     */
    omit?: RewardAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the RewardAccount to update in case it exists.
     */
    where: RewardAccountWhereUniqueInput
    /**
     * In case the RewardAccount found by the `where` argument doesn't exist, create a new RewardAccount with this data.
     */
    create: XOR<RewardAccountCreateInput, RewardAccountUncheckedCreateInput>
    /**
     * In case the RewardAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardAccountUpdateInput, RewardAccountUncheckedUpdateInput>
  }

  /**
   * RewardAccount delete
   */
  export type RewardAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccount
     */
    select?: RewardAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccount
     */
    omit?: RewardAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccountInclude<ExtArgs> | null
    /**
     * Filter which RewardAccount to delete.
     */
    where: RewardAccountWhereUniqueInput
  }

  /**
   * RewardAccount deleteMany
   */
  export type RewardAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardAccounts to delete
     */
    where?: RewardAccountWhereInput
    /**
     * Limit how many RewardAccounts to delete.
     */
    limit?: number
  }

  /**
   * RewardAccount.txns
   */
  export type RewardAccount$txnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardTransaction
     */
    omit?: RewardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    where?: RewardTransactionWhereInput
    orderBy?: RewardTransactionOrderByWithRelationInput | RewardTransactionOrderByWithRelationInput[]
    cursor?: RewardTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardTransactionScalarFieldEnum | RewardTransactionScalarFieldEnum[]
  }

  /**
   * RewardAccount without action
   */
  export type RewardAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccount
     */
    select?: RewardAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccount
     */
    omit?: RewardAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccountInclude<ExtArgs> | null
  }


  /**
   * Model RewardTransaction
   */

  export type AggregateRewardTransaction = {
    _count: RewardTransactionCountAggregateOutputType | null
    _avg: RewardTransactionAvgAggregateOutputType | null
    _sum: RewardTransactionSumAggregateOutputType | null
    _min: RewardTransactionMinAggregateOutputType | null
    _max: RewardTransactionMaxAggregateOutputType | null
  }

  export type RewardTransactionAvgAggregateOutputType = {
    id: number | null
    rewardAccountId: number | null
    amountPoints: number | null
    orderId: number | null
  }

  export type RewardTransactionSumAggregateOutputType = {
    id: number | null
    rewardAccountId: number | null
    amountPoints: number | null
    orderId: number | null
  }

  export type RewardTransactionMinAggregateOutputType = {
    id: number | null
    rewardAccountId: number | null
    type: $Enums.RewardTxnType | null
    amountPoints: number | null
    orderId: number | null
    note: string | null
    createdAt: Date | null
  }

  export type RewardTransactionMaxAggregateOutputType = {
    id: number | null
    rewardAccountId: number | null
    type: $Enums.RewardTxnType | null
    amountPoints: number | null
    orderId: number | null
    note: string | null
    createdAt: Date | null
  }

  export type RewardTransactionCountAggregateOutputType = {
    id: number
    rewardAccountId: number
    type: number
    amountPoints: number
    orderId: number
    note: number
    createdAt: number
    _all: number
  }


  export type RewardTransactionAvgAggregateInputType = {
    id?: true
    rewardAccountId?: true
    amountPoints?: true
    orderId?: true
  }

  export type RewardTransactionSumAggregateInputType = {
    id?: true
    rewardAccountId?: true
    amountPoints?: true
    orderId?: true
  }

  export type RewardTransactionMinAggregateInputType = {
    id?: true
    rewardAccountId?: true
    type?: true
    amountPoints?: true
    orderId?: true
    note?: true
    createdAt?: true
  }

  export type RewardTransactionMaxAggregateInputType = {
    id?: true
    rewardAccountId?: true
    type?: true
    amountPoints?: true
    orderId?: true
    note?: true
    createdAt?: true
  }

  export type RewardTransactionCountAggregateInputType = {
    id?: true
    rewardAccountId?: true
    type?: true
    amountPoints?: true
    orderId?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type RewardTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardTransaction to aggregate.
     */
    where?: RewardTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardTransactions to fetch.
     */
    orderBy?: RewardTransactionOrderByWithRelationInput | RewardTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RewardTransactions
    **/
    _count?: true | RewardTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardTransactionMaxAggregateInputType
  }

  export type GetRewardTransactionAggregateType<T extends RewardTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateRewardTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewardTransaction[P]>
      : GetScalarType<T[P], AggregateRewardTransaction[P]>
  }




  export type RewardTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardTransactionWhereInput
    orderBy?: RewardTransactionOrderByWithAggregationInput | RewardTransactionOrderByWithAggregationInput[]
    by: RewardTransactionScalarFieldEnum[] | RewardTransactionScalarFieldEnum
    having?: RewardTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardTransactionCountAggregateInputType | true
    _avg?: RewardTransactionAvgAggregateInputType
    _sum?: RewardTransactionSumAggregateInputType
    _min?: RewardTransactionMinAggregateInputType
    _max?: RewardTransactionMaxAggregateInputType
  }

  export type RewardTransactionGroupByOutputType = {
    id: number
    rewardAccountId: number
    type: $Enums.RewardTxnType
    amountPoints: number
    orderId: number | null
    note: string | null
    createdAt: Date
    _count: RewardTransactionCountAggregateOutputType | null
    _avg: RewardTransactionAvgAggregateOutputType | null
    _sum: RewardTransactionSumAggregateOutputType | null
    _min: RewardTransactionMinAggregateOutputType | null
    _max: RewardTransactionMaxAggregateOutputType | null
  }

  type GetRewardTransactionGroupByPayload<T extends RewardTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], RewardTransactionGroupByOutputType[P]>
        }
      >
    >


  export type RewardTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rewardAccountId?: boolean
    type?: boolean
    amountPoints?: boolean
    orderId?: boolean
    note?: boolean
    createdAt?: boolean
    account?: boolean | RewardAccountDefaultArgs<ExtArgs>
    order?: boolean | RewardTransaction$orderArgs<ExtArgs>
  }, ExtArgs["result"]["rewardTransaction"]>

  export type RewardTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rewardAccountId?: boolean
    type?: boolean
    amountPoints?: boolean
    orderId?: boolean
    note?: boolean
    createdAt?: boolean
    account?: boolean | RewardAccountDefaultArgs<ExtArgs>
    order?: boolean | RewardTransaction$orderArgs<ExtArgs>
  }, ExtArgs["result"]["rewardTransaction"]>

  export type RewardTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rewardAccountId?: boolean
    type?: boolean
    amountPoints?: boolean
    orderId?: boolean
    note?: boolean
    createdAt?: boolean
    account?: boolean | RewardAccountDefaultArgs<ExtArgs>
    order?: boolean | RewardTransaction$orderArgs<ExtArgs>
  }, ExtArgs["result"]["rewardTransaction"]>

  export type RewardTransactionSelectScalar = {
    id?: boolean
    rewardAccountId?: boolean
    type?: boolean
    amountPoints?: boolean
    orderId?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type RewardTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rewardAccountId" | "type" | "amountPoints" | "orderId" | "note" | "createdAt", ExtArgs["result"]["rewardTransaction"]>
  export type RewardTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | RewardAccountDefaultArgs<ExtArgs>
    order?: boolean | RewardTransaction$orderArgs<ExtArgs>
  }
  export type RewardTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | RewardAccountDefaultArgs<ExtArgs>
    order?: boolean | RewardTransaction$orderArgs<ExtArgs>
  }
  export type RewardTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | RewardAccountDefaultArgs<ExtArgs>
    order?: boolean | RewardTransaction$orderArgs<ExtArgs>
  }

  export type $RewardTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RewardTransaction"
    objects: {
      account: Prisma.$RewardAccountPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rewardAccountId: number
      type: $Enums.RewardTxnType
      amountPoints: number
      orderId: number | null
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["rewardTransaction"]>
    composites: {}
  }

  type RewardTransactionGetPayload<S extends boolean | null | undefined | RewardTransactionDefaultArgs> = $Result.GetResult<Prisma.$RewardTransactionPayload, S>

  type RewardTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RewardTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RewardTransactionCountAggregateInputType | true
    }

  export interface RewardTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RewardTransaction'], meta: { name: 'RewardTransaction' } }
    /**
     * Find zero or one RewardTransaction that matches the filter.
     * @param {RewardTransactionFindUniqueArgs} args - Arguments to find a RewardTransaction
     * @example
     * // Get one RewardTransaction
     * const rewardTransaction = await prisma.rewardTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardTransactionFindUniqueArgs>(args: SelectSubset<T, RewardTransactionFindUniqueArgs<ExtArgs>>): Prisma__RewardTransactionClient<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RewardTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RewardTransactionFindUniqueOrThrowArgs} args - Arguments to find a RewardTransaction
     * @example
     * // Get one RewardTransaction
     * const rewardTransaction = await prisma.rewardTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardTransactionClient<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RewardTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardTransactionFindFirstArgs} args - Arguments to find a RewardTransaction
     * @example
     * // Get one RewardTransaction
     * const rewardTransaction = await prisma.rewardTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardTransactionFindFirstArgs>(args?: SelectSubset<T, RewardTransactionFindFirstArgs<ExtArgs>>): Prisma__RewardTransactionClient<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RewardTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardTransactionFindFirstOrThrowArgs} args - Arguments to find a RewardTransaction
     * @example
     * // Get one RewardTransaction
     * const rewardTransaction = await prisma.rewardTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardTransactionClient<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RewardTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RewardTransactions
     * const rewardTransactions = await prisma.rewardTransaction.findMany()
     * 
     * // Get first 10 RewardTransactions
     * const rewardTransactions = await prisma.rewardTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardTransactionWithIdOnly = await prisma.rewardTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RewardTransactionFindManyArgs>(args?: SelectSubset<T, RewardTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RewardTransaction.
     * @param {RewardTransactionCreateArgs} args - Arguments to create a RewardTransaction.
     * @example
     * // Create one RewardTransaction
     * const RewardTransaction = await prisma.rewardTransaction.create({
     *   data: {
     *     // ... data to create a RewardTransaction
     *   }
     * })
     * 
     */
    create<T extends RewardTransactionCreateArgs>(args: SelectSubset<T, RewardTransactionCreateArgs<ExtArgs>>): Prisma__RewardTransactionClient<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RewardTransactions.
     * @param {RewardTransactionCreateManyArgs} args - Arguments to create many RewardTransactions.
     * @example
     * // Create many RewardTransactions
     * const rewardTransaction = await prisma.rewardTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardTransactionCreateManyArgs>(args?: SelectSubset<T, RewardTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RewardTransactions and returns the data saved in the database.
     * @param {RewardTransactionCreateManyAndReturnArgs} args - Arguments to create many RewardTransactions.
     * @example
     * // Create many RewardTransactions
     * const rewardTransaction = await prisma.rewardTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RewardTransactions and only return the `id`
     * const rewardTransactionWithIdOnly = await prisma.rewardTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RewardTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, RewardTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RewardTransaction.
     * @param {RewardTransactionDeleteArgs} args - Arguments to delete one RewardTransaction.
     * @example
     * // Delete one RewardTransaction
     * const RewardTransaction = await prisma.rewardTransaction.delete({
     *   where: {
     *     // ... filter to delete one RewardTransaction
     *   }
     * })
     * 
     */
    delete<T extends RewardTransactionDeleteArgs>(args: SelectSubset<T, RewardTransactionDeleteArgs<ExtArgs>>): Prisma__RewardTransactionClient<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RewardTransaction.
     * @param {RewardTransactionUpdateArgs} args - Arguments to update one RewardTransaction.
     * @example
     * // Update one RewardTransaction
     * const rewardTransaction = await prisma.rewardTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardTransactionUpdateArgs>(args: SelectSubset<T, RewardTransactionUpdateArgs<ExtArgs>>): Prisma__RewardTransactionClient<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RewardTransactions.
     * @param {RewardTransactionDeleteManyArgs} args - Arguments to filter RewardTransactions to delete.
     * @example
     * // Delete a few RewardTransactions
     * const { count } = await prisma.rewardTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardTransactionDeleteManyArgs>(args?: SelectSubset<T, RewardTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RewardTransactions
     * const rewardTransaction = await prisma.rewardTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardTransactionUpdateManyArgs>(args: SelectSubset<T, RewardTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardTransactions and returns the data updated in the database.
     * @param {RewardTransactionUpdateManyAndReturnArgs} args - Arguments to update many RewardTransactions.
     * @example
     * // Update many RewardTransactions
     * const rewardTransaction = await prisma.rewardTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RewardTransactions and only return the `id`
     * const rewardTransactionWithIdOnly = await prisma.rewardTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RewardTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, RewardTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RewardTransaction.
     * @param {RewardTransactionUpsertArgs} args - Arguments to update or create a RewardTransaction.
     * @example
     * // Update or create a RewardTransaction
     * const rewardTransaction = await prisma.rewardTransaction.upsert({
     *   create: {
     *     // ... data to create a RewardTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RewardTransaction we want to update
     *   }
     * })
     */
    upsert<T extends RewardTransactionUpsertArgs>(args: SelectSubset<T, RewardTransactionUpsertArgs<ExtArgs>>): Prisma__RewardTransactionClient<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RewardTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardTransactionCountArgs} args - Arguments to filter RewardTransactions to count.
     * @example
     * // Count the number of RewardTransactions
     * const count = await prisma.rewardTransaction.count({
     *   where: {
     *     // ... the filter for the RewardTransactions we want to count
     *   }
     * })
    **/
    count<T extends RewardTransactionCountArgs>(
      args?: Subset<T, RewardTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RewardTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardTransactionAggregateArgs>(args: Subset<T, RewardTransactionAggregateArgs>): Prisma.PrismaPromise<GetRewardTransactionAggregateType<T>>

    /**
     * Group by RewardTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardTransactionGroupByArgs['orderBy'] }
        : { orderBy?: RewardTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RewardTransaction model
   */
  readonly fields: RewardTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RewardTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends RewardAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RewardAccountDefaultArgs<ExtArgs>>): Prisma__RewardAccountClient<$Result.GetResult<Prisma.$RewardAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends RewardTransaction$orderArgs<ExtArgs> = {}>(args?: Subset<T, RewardTransaction$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RewardTransaction model
   */
  interface RewardTransactionFieldRefs {
    readonly id: FieldRef<"RewardTransaction", 'Int'>
    readonly rewardAccountId: FieldRef<"RewardTransaction", 'Int'>
    readonly type: FieldRef<"RewardTransaction", 'RewardTxnType'>
    readonly amountPoints: FieldRef<"RewardTransaction", 'Int'>
    readonly orderId: FieldRef<"RewardTransaction", 'Int'>
    readonly note: FieldRef<"RewardTransaction", 'String'>
    readonly createdAt: FieldRef<"RewardTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RewardTransaction findUnique
   */
  export type RewardTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardTransaction
     */
    omit?: RewardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RewardTransaction to fetch.
     */
    where: RewardTransactionWhereUniqueInput
  }

  /**
   * RewardTransaction findUniqueOrThrow
   */
  export type RewardTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardTransaction
     */
    omit?: RewardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RewardTransaction to fetch.
     */
    where: RewardTransactionWhereUniqueInput
  }

  /**
   * RewardTransaction findFirst
   */
  export type RewardTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardTransaction
     */
    omit?: RewardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RewardTransaction to fetch.
     */
    where?: RewardTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardTransactions to fetch.
     */
    orderBy?: RewardTransactionOrderByWithRelationInput | RewardTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardTransactions.
     */
    cursor?: RewardTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardTransactions.
     */
    distinct?: RewardTransactionScalarFieldEnum | RewardTransactionScalarFieldEnum[]
  }

  /**
   * RewardTransaction findFirstOrThrow
   */
  export type RewardTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardTransaction
     */
    omit?: RewardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RewardTransaction to fetch.
     */
    where?: RewardTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardTransactions to fetch.
     */
    orderBy?: RewardTransactionOrderByWithRelationInput | RewardTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardTransactions.
     */
    cursor?: RewardTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardTransactions.
     */
    distinct?: RewardTransactionScalarFieldEnum | RewardTransactionScalarFieldEnum[]
  }

  /**
   * RewardTransaction findMany
   */
  export type RewardTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardTransaction
     */
    omit?: RewardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RewardTransactions to fetch.
     */
    where?: RewardTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardTransactions to fetch.
     */
    orderBy?: RewardTransactionOrderByWithRelationInput | RewardTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RewardTransactions.
     */
    cursor?: RewardTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardTransactions.
     */
    skip?: number
    distinct?: RewardTransactionScalarFieldEnum | RewardTransactionScalarFieldEnum[]
  }

  /**
   * RewardTransaction create
   */
  export type RewardTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardTransaction
     */
    omit?: RewardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a RewardTransaction.
     */
    data: XOR<RewardTransactionCreateInput, RewardTransactionUncheckedCreateInput>
  }

  /**
   * RewardTransaction createMany
   */
  export type RewardTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RewardTransactions.
     */
    data: RewardTransactionCreateManyInput | RewardTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RewardTransaction createManyAndReturn
   */
  export type RewardTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardTransaction
     */
    omit?: RewardTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many RewardTransactions.
     */
    data: RewardTransactionCreateManyInput | RewardTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RewardTransaction update
   */
  export type RewardTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardTransaction
     */
    omit?: RewardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a RewardTransaction.
     */
    data: XOR<RewardTransactionUpdateInput, RewardTransactionUncheckedUpdateInput>
    /**
     * Choose, which RewardTransaction to update.
     */
    where: RewardTransactionWhereUniqueInput
  }

  /**
   * RewardTransaction updateMany
   */
  export type RewardTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RewardTransactions.
     */
    data: XOR<RewardTransactionUpdateManyMutationInput, RewardTransactionUncheckedUpdateManyInput>
    /**
     * Filter which RewardTransactions to update
     */
    where?: RewardTransactionWhereInput
    /**
     * Limit how many RewardTransactions to update.
     */
    limit?: number
  }

  /**
   * RewardTransaction updateManyAndReturn
   */
  export type RewardTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardTransaction
     */
    omit?: RewardTransactionOmit<ExtArgs> | null
    /**
     * The data used to update RewardTransactions.
     */
    data: XOR<RewardTransactionUpdateManyMutationInput, RewardTransactionUncheckedUpdateManyInput>
    /**
     * Filter which RewardTransactions to update
     */
    where?: RewardTransactionWhereInput
    /**
     * Limit how many RewardTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RewardTransaction upsert
   */
  export type RewardTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardTransaction
     */
    omit?: RewardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the RewardTransaction to update in case it exists.
     */
    where: RewardTransactionWhereUniqueInput
    /**
     * In case the RewardTransaction found by the `where` argument doesn't exist, create a new RewardTransaction with this data.
     */
    create: XOR<RewardTransactionCreateInput, RewardTransactionUncheckedCreateInput>
    /**
     * In case the RewardTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardTransactionUpdateInput, RewardTransactionUncheckedUpdateInput>
  }

  /**
   * RewardTransaction delete
   */
  export type RewardTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardTransaction
     */
    omit?: RewardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * Filter which RewardTransaction to delete.
     */
    where: RewardTransactionWhereUniqueInput
  }

  /**
   * RewardTransaction deleteMany
   */
  export type RewardTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardTransactions to delete
     */
    where?: RewardTransactionWhereInput
    /**
     * Limit how many RewardTransactions to delete.
     */
    limit?: number
  }

  /**
   * RewardTransaction.order
   */
  export type RewardTransaction$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * RewardTransaction without action
   */
  export type RewardTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardTransaction
     */
    omit?: RewardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
  }


  /**
   * Model CateringOrder
   */

  export type AggregateCateringOrder = {
    _count: CateringOrderCountAggregateOutputType | null
    _avg: CateringOrderAvgAggregateOutputType | null
    _sum: CateringOrderSumAggregateOutputType | null
    _min: CateringOrderMinAggregateOutputType | null
    _max: CateringOrderMaxAggregateOutputType | null
  }

  export type CateringOrderAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    createdByUserId: number | null
    guestCount: number | null
    totalCents: number | null
  }

  export type CateringOrderSumAggregateOutputType = {
    id: number | null
    userId: number | null
    createdByUserId: number | null
    guestCount: number | null
    totalCents: number | null
  }

  export type CateringOrderMinAggregateOutputType = {
    id: number | null
    userId: number | null
    createdByUserId: number | null
    source: $Enums.OrderSource | null
    sourceRef: string | null
    status: $Enums.CateringStatus | null
    eventDate: Date | null
    guestCount: number | null
    customerName: string | null
    customerEmail: string | null
    customerPhone: string | null
    notes: string | null
    totalCents: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CateringOrderMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    createdByUserId: number | null
    source: $Enums.OrderSource | null
    sourceRef: string | null
    status: $Enums.CateringStatus | null
    eventDate: Date | null
    guestCount: number | null
    customerName: string | null
    customerEmail: string | null
    customerPhone: string | null
    notes: string | null
    totalCents: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CateringOrderCountAggregateOutputType = {
    id: number
    userId: number
    createdByUserId: number
    source: number
    sourceRef: number
    status: number
    eventDate: number
    guestCount: number
    customerName: number
    customerEmail: number
    customerPhone: number
    notes: number
    totalCents: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CateringOrderAvgAggregateInputType = {
    id?: true
    userId?: true
    createdByUserId?: true
    guestCount?: true
    totalCents?: true
  }

  export type CateringOrderSumAggregateInputType = {
    id?: true
    userId?: true
    createdByUserId?: true
    guestCount?: true
    totalCents?: true
  }

  export type CateringOrderMinAggregateInputType = {
    id?: true
    userId?: true
    createdByUserId?: true
    source?: true
    sourceRef?: true
    status?: true
    eventDate?: true
    guestCount?: true
    customerName?: true
    customerEmail?: true
    customerPhone?: true
    notes?: true
    totalCents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CateringOrderMaxAggregateInputType = {
    id?: true
    userId?: true
    createdByUserId?: true
    source?: true
    sourceRef?: true
    status?: true
    eventDate?: true
    guestCount?: true
    customerName?: true
    customerEmail?: true
    customerPhone?: true
    notes?: true
    totalCents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CateringOrderCountAggregateInputType = {
    id?: true
    userId?: true
    createdByUserId?: true
    source?: true
    sourceRef?: true
    status?: true
    eventDate?: true
    guestCount?: true
    customerName?: true
    customerEmail?: true
    customerPhone?: true
    notes?: true
    totalCents?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CateringOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CateringOrder to aggregate.
     */
    where?: CateringOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CateringOrders to fetch.
     */
    orderBy?: CateringOrderOrderByWithRelationInput | CateringOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CateringOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CateringOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CateringOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CateringOrders
    **/
    _count?: true | CateringOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CateringOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CateringOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CateringOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CateringOrderMaxAggregateInputType
  }

  export type GetCateringOrderAggregateType<T extends CateringOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateCateringOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCateringOrder[P]>
      : GetScalarType<T[P], AggregateCateringOrder[P]>
  }




  export type CateringOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CateringOrderWhereInput
    orderBy?: CateringOrderOrderByWithAggregationInput | CateringOrderOrderByWithAggregationInput[]
    by: CateringOrderScalarFieldEnum[] | CateringOrderScalarFieldEnum
    having?: CateringOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CateringOrderCountAggregateInputType | true
    _avg?: CateringOrderAvgAggregateInputType
    _sum?: CateringOrderSumAggregateInputType
    _min?: CateringOrderMinAggregateInputType
    _max?: CateringOrderMaxAggregateInputType
  }

  export type CateringOrderGroupByOutputType = {
    id: number
    userId: number | null
    createdByUserId: number | null
    source: $Enums.OrderSource
    sourceRef: string | null
    status: $Enums.CateringStatus
    eventDate: Date
    guestCount: number
    customerName: string | null
    customerEmail: string | null
    customerPhone: string | null
    notes: string | null
    totalCents: number
    createdAt: Date
    updatedAt: Date
    _count: CateringOrderCountAggregateOutputType | null
    _avg: CateringOrderAvgAggregateOutputType | null
    _sum: CateringOrderSumAggregateOutputType | null
    _min: CateringOrderMinAggregateOutputType | null
    _max: CateringOrderMaxAggregateOutputType | null
  }

  type GetCateringOrderGroupByPayload<T extends CateringOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CateringOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CateringOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CateringOrderGroupByOutputType[P]>
            : GetScalarType<T[P], CateringOrderGroupByOutputType[P]>
        }
      >
    >


  export type CateringOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdByUserId?: boolean
    source?: boolean
    sourceRef?: boolean
    status?: boolean
    eventDate?: boolean
    guestCount?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhone?: boolean
    notes?: boolean
    totalCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | CateringOrder$userArgs<ExtArgs>
    createdBy?: boolean | CateringOrder$createdByArgs<ExtArgs>
    items?: boolean | CateringOrder$itemsArgs<ExtArgs>
    _count?: boolean | CateringOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cateringOrder"]>

  export type CateringOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdByUserId?: boolean
    source?: boolean
    sourceRef?: boolean
    status?: boolean
    eventDate?: boolean
    guestCount?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhone?: boolean
    notes?: boolean
    totalCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | CateringOrder$userArgs<ExtArgs>
    createdBy?: boolean | CateringOrder$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["cateringOrder"]>

  export type CateringOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdByUserId?: boolean
    source?: boolean
    sourceRef?: boolean
    status?: boolean
    eventDate?: boolean
    guestCount?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhone?: boolean
    notes?: boolean
    totalCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | CateringOrder$userArgs<ExtArgs>
    createdBy?: boolean | CateringOrder$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["cateringOrder"]>

  export type CateringOrderSelectScalar = {
    id?: boolean
    userId?: boolean
    createdByUserId?: boolean
    source?: boolean
    sourceRef?: boolean
    status?: boolean
    eventDate?: boolean
    guestCount?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhone?: boolean
    notes?: boolean
    totalCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CateringOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdByUserId" | "source" | "sourceRef" | "status" | "eventDate" | "guestCount" | "customerName" | "customerEmail" | "customerPhone" | "notes" | "totalCents" | "createdAt" | "updatedAt", ExtArgs["result"]["cateringOrder"]>
  export type CateringOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | CateringOrder$userArgs<ExtArgs>
    createdBy?: boolean | CateringOrder$createdByArgs<ExtArgs>
    items?: boolean | CateringOrder$itemsArgs<ExtArgs>
    _count?: boolean | CateringOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CateringOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | CateringOrder$userArgs<ExtArgs>
    createdBy?: boolean | CateringOrder$createdByArgs<ExtArgs>
  }
  export type CateringOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | CateringOrder$userArgs<ExtArgs>
    createdBy?: boolean | CateringOrder$createdByArgs<ExtArgs>
  }

  export type $CateringOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CateringOrder"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$CateringItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      createdByUserId: number | null
      source: $Enums.OrderSource
      sourceRef: string | null
      status: $Enums.CateringStatus
      eventDate: Date
      guestCount: number
      customerName: string | null
      customerEmail: string | null
      customerPhone: string | null
      notes: string | null
      totalCents: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cateringOrder"]>
    composites: {}
  }

  type CateringOrderGetPayload<S extends boolean | null | undefined | CateringOrderDefaultArgs> = $Result.GetResult<Prisma.$CateringOrderPayload, S>

  type CateringOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CateringOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CateringOrderCountAggregateInputType | true
    }

  export interface CateringOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CateringOrder'], meta: { name: 'CateringOrder' } }
    /**
     * Find zero or one CateringOrder that matches the filter.
     * @param {CateringOrderFindUniqueArgs} args - Arguments to find a CateringOrder
     * @example
     * // Get one CateringOrder
     * const cateringOrder = await prisma.cateringOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CateringOrderFindUniqueArgs>(args: SelectSubset<T, CateringOrderFindUniqueArgs<ExtArgs>>): Prisma__CateringOrderClient<$Result.GetResult<Prisma.$CateringOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CateringOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CateringOrderFindUniqueOrThrowArgs} args - Arguments to find a CateringOrder
     * @example
     * // Get one CateringOrder
     * const cateringOrder = await prisma.cateringOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CateringOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, CateringOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CateringOrderClient<$Result.GetResult<Prisma.$CateringOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CateringOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringOrderFindFirstArgs} args - Arguments to find a CateringOrder
     * @example
     * // Get one CateringOrder
     * const cateringOrder = await prisma.cateringOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CateringOrderFindFirstArgs>(args?: SelectSubset<T, CateringOrderFindFirstArgs<ExtArgs>>): Prisma__CateringOrderClient<$Result.GetResult<Prisma.$CateringOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CateringOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringOrderFindFirstOrThrowArgs} args - Arguments to find a CateringOrder
     * @example
     * // Get one CateringOrder
     * const cateringOrder = await prisma.cateringOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CateringOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, CateringOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__CateringOrderClient<$Result.GetResult<Prisma.$CateringOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CateringOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CateringOrders
     * const cateringOrders = await prisma.cateringOrder.findMany()
     * 
     * // Get first 10 CateringOrders
     * const cateringOrders = await prisma.cateringOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cateringOrderWithIdOnly = await prisma.cateringOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CateringOrderFindManyArgs>(args?: SelectSubset<T, CateringOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CateringOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CateringOrder.
     * @param {CateringOrderCreateArgs} args - Arguments to create a CateringOrder.
     * @example
     * // Create one CateringOrder
     * const CateringOrder = await prisma.cateringOrder.create({
     *   data: {
     *     // ... data to create a CateringOrder
     *   }
     * })
     * 
     */
    create<T extends CateringOrderCreateArgs>(args: SelectSubset<T, CateringOrderCreateArgs<ExtArgs>>): Prisma__CateringOrderClient<$Result.GetResult<Prisma.$CateringOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CateringOrders.
     * @param {CateringOrderCreateManyArgs} args - Arguments to create many CateringOrders.
     * @example
     * // Create many CateringOrders
     * const cateringOrder = await prisma.cateringOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CateringOrderCreateManyArgs>(args?: SelectSubset<T, CateringOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CateringOrders and returns the data saved in the database.
     * @param {CateringOrderCreateManyAndReturnArgs} args - Arguments to create many CateringOrders.
     * @example
     * // Create many CateringOrders
     * const cateringOrder = await prisma.cateringOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CateringOrders and only return the `id`
     * const cateringOrderWithIdOnly = await prisma.cateringOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CateringOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, CateringOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CateringOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CateringOrder.
     * @param {CateringOrderDeleteArgs} args - Arguments to delete one CateringOrder.
     * @example
     * // Delete one CateringOrder
     * const CateringOrder = await prisma.cateringOrder.delete({
     *   where: {
     *     // ... filter to delete one CateringOrder
     *   }
     * })
     * 
     */
    delete<T extends CateringOrderDeleteArgs>(args: SelectSubset<T, CateringOrderDeleteArgs<ExtArgs>>): Prisma__CateringOrderClient<$Result.GetResult<Prisma.$CateringOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CateringOrder.
     * @param {CateringOrderUpdateArgs} args - Arguments to update one CateringOrder.
     * @example
     * // Update one CateringOrder
     * const cateringOrder = await prisma.cateringOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CateringOrderUpdateArgs>(args: SelectSubset<T, CateringOrderUpdateArgs<ExtArgs>>): Prisma__CateringOrderClient<$Result.GetResult<Prisma.$CateringOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CateringOrders.
     * @param {CateringOrderDeleteManyArgs} args - Arguments to filter CateringOrders to delete.
     * @example
     * // Delete a few CateringOrders
     * const { count } = await prisma.cateringOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CateringOrderDeleteManyArgs>(args?: SelectSubset<T, CateringOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CateringOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CateringOrders
     * const cateringOrder = await prisma.cateringOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CateringOrderUpdateManyArgs>(args: SelectSubset<T, CateringOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CateringOrders and returns the data updated in the database.
     * @param {CateringOrderUpdateManyAndReturnArgs} args - Arguments to update many CateringOrders.
     * @example
     * // Update many CateringOrders
     * const cateringOrder = await prisma.cateringOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CateringOrders and only return the `id`
     * const cateringOrderWithIdOnly = await prisma.cateringOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CateringOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, CateringOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CateringOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CateringOrder.
     * @param {CateringOrderUpsertArgs} args - Arguments to update or create a CateringOrder.
     * @example
     * // Update or create a CateringOrder
     * const cateringOrder = await prisma.cateringOrder.upsert({
     *   create: {
     *     // ... data to create a CateringOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CateringOrder we want to update
     *   }
     * })
     */
    upsert<T extends CateringOrderUpsertArgs>(args: SelectSubset<T, CateringOrderUpsertArgs<ExtArgs>>): Prisma__CateringOrderClient<$Result.GetResult<Prisma.$CateringOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CateringOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringOrderCountArgs} args - Arguments to filter CateringOrders to count.
     * @example
     * // Count the number of CateringOrders
     * const count = await prisma.cateringOrder.count({
     *   where: {
     *     // ... the filter for the CateringOrders we want to count
     *   }
     * })
    **/
    count<T extends CateringOrderCountArgs>(
      args?: Subset<T, CateringOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CateringOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CateringOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CateringOrderAggregateArgs>(args: Subset<T, CateringOrderAggregateArgs>): Prisma.PrismaPromise<GetCateringOrderAggregateType<T>>

    /**
     * Group by CateringOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CateringOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CateringOrderGroupByArgs['orderBy'] }
        : { orderBy?: CateringOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CateringOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCateringOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CateringOrder model
   */
  readonly fields: CateringOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CateringOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CateringOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends CateringOrder$userArgs<ExtArgs> = {}>(args?: Subset<T, CateringOrder$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends CateringOrder$createdByArgs<ExtArgs> = {}>(args?: Subset<T, CateringOrder$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends CateringOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, CateringOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CateringItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CateringOrder model
   */
  interface CateringOrderFieldRefs {
    readonly id: FieldRef<"CateringOrder", 'Int'>
    readonly userId: FieldRef<"CateringOrder", 'Int'>
    readonly createdByUserId: FieldRef<"CateringOrder", 'Int'>
    readonly source: FieldRef<"CateringOrder", 'OrderSource'>
    readonly sourceRef: FieldRef<"CateringOrder", 'String'>
    readonly status: FieldRef<"CateringOrder", 'CateringStatus'>
    readonly eventDate: FieldRef<"CateringOrder", 'DateTime'>
    readonly guestCount: FieldRef<"CateringOrder", 'Int'>
    readonly customerName: FieldRef<"CateringOrder", 'String'>
    readonly customerEmail: FieldRef<"CateringOrder", 'String'>
    readonly customerPhone: FieldRef<"CateringOrder", 'String'>
    readonly notes: FieldRef<"CateringOrder", 'String'>
    readonly totalCents: FieldRef<"CateringOrder", 'Int'>
    readonly createdAt: FieldRef<"CateringOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"CateringOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CateringOrder findUnique
   */
  export type CateringOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringOrder
     */
    select?: CateringOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringOrder
     */
    omit?: CateringOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringOrderInclude<ExtArgs> | null
    /**
     * Filter, which CateringOrder to fetch.
     */
    where: CateringOrderWhereUniqueInput
  }

  /**
   * CateringOrder findUniqueOrThrow
   */
  export type CateringOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringOrder
     */
    select?: CateringOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringOrder
     */
    omit?: CateringOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringOrderInclude<ExtArgs> | null
    /**
     * Filter, which CateringOrder to fetch.
     */
    where: CateringOrderWhereUniqueInput
  }

  /**
   * CateringOrder findFirst
   */
  export type CateringOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringOrder
     */
    select?: CateringOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringOrder
     */
    omit?: CateringOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringOrderInclude<ExtArgs> | null
    /**
     * Filter, which CateringOrder to fetch.
     */
    where?: CateringOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CateringOrders to fetch.
     */
    orderBy?: CateringOrderOrderByWithRelationInput | CateringOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CateringOrders.
     */
    cursor?: CateringOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CateringOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CateringOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CateringOrders.
     */
    distinct?: CateringOrderScalarFieldEnum | CateringOrderScalarFieldEnum[]
  }

  /**
   * CateringOrder findFirstOrThrow
   */
  export type CateringOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringOrder
     */
    select?: CateringOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringOrder
     */
    omit?: CateringOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringOrderInclude<ExtArgs> | null
    /**
     * Filter, which CateringOrder to fetch.
     */
    where?: CateringOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CateringOrders to fetch.
     */
    orderBy?: CateringOrderOrderByWithRelationInput | CateringOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CateringOrders.
     */
    cursor?: CateringOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CateringOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CateringOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CateringOrders.
     */
    distinct?: CateringOrderScalarFieldEnum | CateringOrderScalarFieldEnum[]
  }

  /**
   * CateringOrder findMany
   */
  export type CateringOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringOrder
     */
    select?: CateringOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringOrder
     */
    omit?: CateringOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringOrderInclude<ExtArgs> | null
    /**
     * Filter, which CateringOrders to fetch.
     */
    where?: CateringOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CateringOrders to fetch.
     */
    orderBy?: CateringOrderOrderByWithRelationInput | CateringOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CateringOrders.
     */
    cursor?: CateringOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CateringOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CateringOrders.
     */
    skip?: number
    distinct?: CateringOrderScalarFieldEnum | CateringOrderScalarFieldEnum[]
  }

  /**
   * CateringOrder create
   */
  export type CateringOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringOrder
     */
    select?: CateringOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringOrder
     */
    omit?: CateringOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a CateringOrder.
     */
    data: XOR<CateringOrderCreateInput, CateringOrderUncheckedCreateInput>
  }

  /**
   * CateringOrder createMany
   */
  export type CateringOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CateringOrders.
     */
    data: CateringOrderCreateManyInput | CateringOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CateringOrder createManyAndReturn
   */
  export type CateringOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringOrder
     */
    select?: CateringOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CateringOrder
     */
    omit?: CateringOrderOmit<ExtArgs> | null
    /**
     * The data used to create many CateringOrders.
     */
    data: CateringOrderCreateManyInput | CateringOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CateringOrder update
   */
  export type CateringOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringOrder
     */
    select?: CateringOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringOrder
     */
    omit?: CateringOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a CateringOrder.
     */
    data: XOR<CateringOrderUpdateInput, CateringOrderUncheckedUpdateInput>
    /**
     * Choose, which CateringOrder to update.
     */
    where: CateringOrderWhereUniqueInput
  }

  /**
   * CateringOrder updateMany
   */
  export type CateringOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CateringOrders.
     */
    data: XOR<CateringOrderUpdateManyMutationInput, CateringOrderUncheckedUpdateManyInput>
    /**
     * Filter which CateringOrders to update
     */
    where?: CateringOrderWhereInput
    /**
     * Limit how many CateringOrders to update.
     */
    limit?: number
  }

  /**
   * CateringOrder updateManyAndReturn
   */
  export type CateringOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringOrder
     */
    select?: CateringOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CateringOrder
     */
    omit?: CateringOrderOmit<ExtArgs> | null
    /**
     * The data used to update CateringOrders.
     */
    data: XOR<CateringOrderUpdateManyMutationInput, CateringOrderUncheckedUpdateManyInput>
    /**
     * Filter which CateringOrders to update
     */
    where?: CateringOrderWhereInput
    /**
     * Limit how many CateringOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CateringOrder upsert
   */
  export type CateringOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringOrder
     */
    select?: CateringOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringOrder
     */
    omit?: CateringOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the CateringOrder to update in case it exists.
     */
    where: CateringOrderWhereUniqueInput
    /**
     * In case the CateringOrder found by the `where` argument doesn't exist, create a new CateringOrder with this data.
     */
    create: XOR<CateringOrderCreateInput, CateringOrderUncheckedCreateInput>
    /**
     * In case the CateringOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CateringOrderUpdateInput, CateringOrderUncheckedUpdateInput>
  }

  /**
   * CateringOrder delete
   */
  export type CateringOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringOrder
     */
    select?: CateringOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringOrder
     */
    omit?: CateringOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringOrderInclude<ExtArgs> | null
    /**
     * Filter which CateringOrder to delete.
     */
    where: CateringOrderWhereUniqueInput
  }

  /**
   * CateringOrder deleteMany
   */
  export type CateringOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CateringOrders to delete
     */
    where?: CateringOrderWhereInput
    /**
     * Limit how many CateringOrders to delete.
     */
    limit?: number
  }

  /**
   * CateringOrder.user
   */
  export type CateringOrder$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CateringOrder.createdBy
   */
  export type CateringOrder$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CateringOrder.items
   */
  export type CateringOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringItem
     */
    select?: CateringItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringItem
     */
    omit?: CateringItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringItemInclude<ExtArgs> | null
    where?: CateringItemWhereInput
    orderBy?: CateringItemOrderByWithRelationInput | CateringItemOrderByWithRelationInput[]
    cursor?: CateringItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CateringItemScalarFieldEnum | CateringItemScalarFieldEnum[]
  }

  /**
   * CateringOrder without action
   */
  export type CateringOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringOrder
     */
    select?: CateringOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringOrder
     */
    omit?: CateringOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringOrderInclude<ExtArgs> | null
  }


  /**
   * Model CateringItem
   */

  export type AggregateCateringItem = {
    _count: CateringItemCountAggregateOutputType | null
    _avg: CateringItemAvgAggregateOutputType | null
    _sum: CateringItemSumAggregateOutputType | null
    _min: CateringItemMinAggregateOutputType | null
    _max: CateringItemMaxAggregateOutputType | null
  }

  export type CateringItemAvgAggregateOutputType = {
    id: number | null
    cateringOrderId: number | null
    menuItemId: number | null
    quantity: number | null
    unitPriceCents: number | null
  }

  export type CateringItemSumAggregateOutputType = {
    id: number | null
    cateringOrderId: number | null
    menuItemId: number | null
    quantity: number | null
    unitPriceCents: number | null
  }

  export type CateringItemMinAggregateOutputType = {
    id: number | null
    cateringOrderId: number | null
    menuItemId: number | null
    nameSnapshot: string | null
    quantity: number | null
    unitPriceCents: number | null
  }

  export type CateringItemMaxAggregateOutputType = {
    id: number | null
    cateringOrderId: number | null
    menuItemId: number | null
    nameSnapshot: string | null
    quantity: number | null
    unitPriceCents: number | null
  }

  export type CateringItemCountAggregateOutputType = {
    id: number
    cateringOrderId: number
    menuItemId: number
    nameSnapshot: number
    quantity: number
    unitPriceCents: number
    _all: number
  }


  export type CateringItemAvgAggregateInputType = {
    id?: true
    cateringOrderId?: true
    menuItemId?: true
    quantity?: true
    unitPriceCents?: true
  }

  export type CateringItemSumAggregateInputType = {
    id?: true
    cateringOrderId?: true
    menuItemId?: true
    quantity?: true
    unitPriceCents?: true
  }

  export type CateringItemMinAggregateInputType = {
    id?: true
    cateringOrderId?: true
    menuItemId?: true
    nameSnapshot?: true
    quantity?: true
    unitPriceCents?: true
  }

  export type CateringItemMaxAggregateInputType = {
    id?: true
    cateringOrderId?: true
    menuItemId?: true
    nameSnapshot?: true
    quantity?: true
    unitPriceCents?: true
  }

  export type CateringItemCountAggregateInputType = {
    id?: true
    cateringOrderId?: true
    menuItemId?: true
    nameSnapshot?: true
    quantity?: true
    unitPriceCents?: true
    _all?: true
  }

  export type CateringItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CateringItem to aggregate.
     */
    where?: CateringItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CateringItems to fetch.
     */
    orderBy?: CateringItemOrderByWithRelationInput | CateringItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CateringItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CateringItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CateringItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CateringItems
    **/
    _count?: true | CateringItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CateringItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CateringItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CateringItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CateringItemMaxAggregateInputType
  }

  export type GetCateringItemAggregateType<T extends CateringItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCateringItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCateringItem[P]>
      : GetScalarType<T[P], AggregateCateringItem[P]>
  }




  export type CateringItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CateringItemWhereInput
    orderBy?: CateringItemOrderByWithAggregationInput | CateringItemOrderByWithAggregationInput[]
    by: CateringItemScalarFieldEnum[] | CateringItemScalarFieldEnum
    having?: CateringItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CateringItemCountAggregateInputType | true
    _avg?: CateringItemAvgAggregateInputType
    _sum?: CateringItemSumAggregateInputType
    _min?: CateringItemMinAggregateInputType
    _max?: CateringItemMaxAggregateInputType
  }

  export type CateringItemGroupByOutputType = {
    id: number
    cateringOrderId: number
    menuItemId: number | null
    nameSnapshot: string
    quantity: number
    unitPriceCents: number
    _count: CateringItemCountAggregateOutputType | null
    _avg: CateringItemAvgAggregateOutputType | null
    _sum: CateringItemSumAggregateOutputType | null
    _min: CateringItemMinAggregateOutputType | null
    _max: CateringItemMaxAggregateOutputType | null
  }

  type GetCateringItemGroupByPayload<T extends CateringItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CateringItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CateringItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CateringItemGroupByOutputType[P]>
            : GetScalarType<T[P], CateringItemGroupByOutputType[P]>
        }
      >
    >


  export type CateringItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cateringOrderId?: boolean
    menuItemId?: boolean
    nameSnapshot?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    cateringOrder?: boolean | CateringOrderDefaultArgs<ExtArgs>
    menuItem?: boolean | CateringItem$menuItemArgs<ExtArgs>
  }, ExtArgs["result"]["cateringItem"]>

  export type CateringItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cateringOrderId?: boolean
    menuItemId?: boolean
    nameSnapshot?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    cateringOrder?: boolean | CateringOrderDefaultArgs<ExtArgs>
    menuItem?: boolean | CateringItem$menuItemArgs<ExtArgs>
  }, ExtArgs["result"]["cateringItem"]>

  export type CateringItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cateringOrderId?: boolean
    menuItemId?: boolean
    nameSnapshot?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    cateringOrder?: boolean | CateringOrderDefaultArgs<ExtArgs>
    menuItem?: boolean | CateringItem$menuItemArgs<ExtArgs>
  }, ExtArgs["result"]["cateringItem"]>

  export type CateringItemSelectScalar = {
    id?: boolean
    cateringOrderId?: boolean
    menuItemId?: boolean
    nameSnapshot?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
  }

  export type CateringItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cateringOrderId" | "menuItemId" | "nameSnapshot" | "quantity" | "unitPriceCents", ExtArgs["result"]["cateringItem"]>
  export type CateringItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cateringOrder?: boolean | CateringOrderDefaultArgs<ExtArgs>
    menuItem?: boolean | CateringItem$menuItemArgs<ExtArgs>
  }
  export type CateringItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cateringOrder?: boolean | CateringOrderDefaultArgs<ExtArgs>
    menuItem?: boolean | CateringItem$menuItemArgs<ExtArgs>
  }
  export type CateringItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cateringOrder?: boolean | CateringOrderDefaultArgs<ExtArgs>
    menuItem?: boolean | CateringItem$menuItemArgs<ExtArgs>
  }

  export type $CateringItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CateringItem"
    objects: {
      cateringOrder: Prisma.$CateringOrderPayload<ExtArgs>
      menuItem: Prisma.$MenuItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cateringOrderId: number
      menuItemId: number | null
      nameSnapshot: string
      quantity: number
      unitPriceCents: number
    }, ExtArgs["result"]["cateringItem"]>
    composites: {}
  }

  type CateringItemGetPayload<S extends boolean | null | undefined | CateringItemDefaultArgs> = $Result.GetResult<Prisma.$CateringItemPayload, S>

  type CateringItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CateringItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CateringItemCountAggregateInputType | true
    }

  export interface CateringItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CateringItem'], meta: { name: 'CateringItem' } }
    /**
     * Find zero or one CateringItem that matches the filter.
     * @param {CateringItemFindUniqueArgs} args - Arguments to find a CateringItem
     * @example
     * // Get one CateringItem
     * const cateringItem = await prisma.cateringItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CateringItemFindUniqueArgs>(args: SelectSubset<T, CateringItemFindUniqueArgs<ExtArgs>>): Prisma__CateringItemClient<$Result.GetResult<Prisma.$CateringItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CateringItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CateringItemFindUniqueOrThrowArgs} args - Arguments to find a CateringItem
     * @example
     * // Get one CateringItem
     * const cateringItem = await prisma.cateringItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CateringItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CateringItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CateringItemClient<$Result.GetResult<Prisma.$CateringItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CateringItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringItemFindFirstArgs} args - Arguments to find a CateringItem
     * @example
     * // Get one CateringItem
     * const cateringItem = await prisma.cateringItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CateringItemFindFirstArgs>(args?: SelectSubset<T, CateringItemFindFirstArgs<ExtArgs>>): Prisma__CateringItemClient<$Result.GetResult<Prisma.$CateringItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CateringItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringItemFindFirstOrThrowArgs} args - Arguments to find a CateringItem
     * @example
     * // Get one CateringItem
     * const cateringItem = await prisma.cateringItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CateringItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CateringItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CateringItemClient<$Result.GetResult<Prisma.$CateringItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CateringItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CateringItems
     * const cateringItems = await prisma.cateringItem.findMany()
     * 
     * // Get first 10 CateringItems
     * const cateringItems = await prisma.cateringItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cateringItemWithIdOnly = await prisma.cateringItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CateringItemFindManyArgs>(args?: SelectSubset<T, CateringItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CateringItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CateringItem.
     * @param {CateringItemCreateArgs} args - Arguments to create a CateringItem.
     * @example
     * // Create one CateringItem
     * const CateringItem = await prisma.cateringItem.create({
     *   data: {
     *     // ... data to create a CateringItem
     *   }
     * })
     * 
     */
    create<T extends CateringItemCreateArgs>(args: SelectSubset<T, CateringItemCreateArgs<ExtArgs>>): Prisma__CateringItemClient<$Result.GetResult<Prisma.$CateringItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CateringItems.
     * @param {CateringItemCreateManyArgs} args - Arguments to create many CateringItems.
     * @example
     * // Create many CateringItems
     * const cateringItem = await prisma.cateringItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CateringItemCreateManyArgs>(args?: SelectSubset<T, CateringItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CateringItems and returns the data saved in the database.
     * @param {CateringItemCreateManyAndReturnArgs} args - Arguments to create many CateringItems.
     * @example
     * // Create many CateringItems
     * const cateringItem = await prisma.cateringItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CateringItems and only return the `id`
     * const cateringItemWithIdOnly = await prisma.cateringItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CateringItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CateringItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CateringItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CateringItem.
     * @param {CateringItemDeleteArgs} args - Arguments to delete one CateringItem.
     * @example
     * // Delete one CateringItem
     * const CateringItem = await prisma.cateringItem.delete({
     *   where: {
     *     // ... filter to delete one CateringItem
     *   }
     * })
     * 
     */
    delete<T extends CateringItemDeleteArgs>(args: SelectSubset<T, CateringItemDeleteArgs<ExtArgs>>): Prisma__CateringItemClient<$Result.GetResult<Prisma.$CateringItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CateringItem.
     * @param {CateringItemUpdateArgs} args - Arguments to update one CateringItem.
     * @example
     * // Update one CateringItem
     * const cateringItem = await prisma.cateringItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CateringItemUpdateArgs>(args: SelectSubset<T, CateringItemUpdateArgs<ExtArgs>>): Prisma__CateringItemClient<$Result.GetResult<Prisma.$CateringItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CateringItems.
     * @param {CateringItemDeleteManyArgs} args - Arguments to filter CateringItems to delete.
     * @example
     * // Delete a few CateringItems
     * const { count } = await prisma.cateringItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CateringItemDeleteManyArgs>(args?: SelectSubset<T, CateringItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CateringItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CateringItems
     * const cateringItem = await prisma.cateringItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CateringItemUpdateManyArgs>(args: SelectSubset<T, CateringItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CateringItems and returns the data updated in the database.
     * @param {CateringItemUpdateManyAndReturnArgs} args - Arguments to update many CateringItems.
     * @example
     * // Update many CateringItems
     * const cateringItem = await prisma.cateringItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CateringItems and only return the `id`
     * const cateringItemWithIdOnly = await prisma.cateringItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CateringItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CateringItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CateringItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CateringItem.
     * @param {CateringItemUpsertArgs} args - Arguments to update or create a CateringItem.
     * @example
     * // Update or create a CateringItem
     * const cateringItem = await prisma.cateringItem.upsert({
     *   create: {
     *     // ... data to create a CateringItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CateringItem we want to update
     *   }
     * })
     */
    upsert<T extends CateringItemUpsertArgs>(args: SelectSubset<T, CateringItemUpsertArgs<ExtArgs>>): Prisma__CateringItemClient<$Result.GetResult<Prisma.$CateringItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CateringItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringItemCountArgs} args - Arguments to filter CateringItems to count.
     * @example
     * // Count the number of CateringItems
     * const count = await prisma.cateringItem.count({
     *   where: {
     *     // ... the filter for the CateringItems we want to count
     *   }
     * })
    **/
    count<T extends CateringItemCountArgs>(
      args?: Subset<T, CateringItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CateringItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CateringItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CateringItemAggregateArgs>(args: Subset<T, CateringItemAggregateArgs>): Prisma.PrismaPromise<GetCateringItemAggregateType<T>>

    /**
     * Group by CateringItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CateringItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CateringItemGroupByArgs['orderBy'] }
        : { orderBy?: CateringItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CateringItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCateringItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CateringItem model
   */
  readonly fields: CateringItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CateringItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CateringItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cateringOrder<T extends CateringOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CateringOrderDefaultArgs<ExtArgs>>): Prisma__CateringOrderClient<$Result.GetResult<Prisma.$CateringOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    menuItem<T extends CateringItem$menuItemArgs<ExtArgs> = {}>(args?: Subset<T, CateringItem$menuItemArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CateringItem model
   */
  interface CateringItemFieldRefs {
    readonly id: FieldRef<"CateringItem", 'Int'>
    readonly cateringOrderId: FieldRef<"CateringItem", 'Int'>
    readonly menuItemId: FieldRef<"CateringItem", 'Int'>
    readonly nameSnapshot: FieldRef<"CateringItem", 'String'>
    readonly quantity: FieldRef<"CateringItem", 'Int'>
    readonly unitPriceCents: FieldRef<"CateringItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CateringItem findUnique
   */
  export type CateringItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringItem
     */
    select?: CateringItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringItem
     */
    omit?: CateringItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringItemInclude<ExtArgs> | null
    /**
     * Filter, which CateringItem to fetch.
     */
    where: CateringItemWhereUniqueInput
  }

  /**
   * CateringItem findUniqueOrThrow
   */
  export type CateringItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringItem
     */
    select?: CateringItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringItem
     */
    omit?: CateringItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringItemInclude<ExtArgs> | null
    /**
     * Filter, which CateringItem to fetch.
     */
    where: CateringItemWhereUniqueInput
  }

  /**
   * CateringItem findFirst
   */
  export type CateringItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringItem
     */
    select?: CateringItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringItem
     */
    omit?: CateringItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringItemInclude<ExtArgs> | null
    /**
     * Filter, which CateringItem to fetch.
     */
    where?: CateringItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CateringItems to fetch.
     */
    orderBy?: CateringItemOrderByWithRelationInput | CateringItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CateringItems.
     */
    cursor?: CateringItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CateringItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CateringItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CateringItems.
     */
    distinct?: CateringItemScalarFieldEnum | CateringItemScalarFieldEnum[]
  }

  /**
   * CateringItem findFirstOrThrow
   */
  export type CateringItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringItem
     */
    select?: CateringItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringItem
     */
    omit?: CateringItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringItemInclude<ExtArgs> | null
    /**
     * Filter, which CateringItem to fetch.
     */
    where?: CateringItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CateringItems to fetch.
     */
    orderBy?: CateringItemOrderByWithRelationInput | CateringItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CateringItems.
     */
    cursor?: CateringItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CateringItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CateringItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CateringItems.
     */
    distinct?: CateringItemScalarFieldEnum | CateringItemScalarFieldEnum[]
  }

  /**
   * CateringItem findMany
   */
  export type CateringItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringItem
     */
    select?: CateringItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringItem
     */
    omit?: CateringItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringItemInclude<ExtArgs> | null
    /**
     * Filter, which CateringItems to fetch.
     */
    where?: CateringItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CateringItems to fetch.
     */
    orderBy?: CateringItemOrderByWithRelationInput | CateringItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CateringItems.
     */
    cursor?: CateringItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CateringItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CateringItems.
     */
    skip?: number
    distinct?: CateringItemScalarFieldEnum | CateringItemScalarFieldEnum[]
  }

  /**
   * CateringItem create
   */
  export type CateringItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringItem
     */
    select?: CateringItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringItem
     */
    omit?: CateringItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CateringItem.
     */
    data: XOR<CateringItemCreateInput, CateringItemUncheckedCreateInput>
  }

  /**
   * CateringItem createMany
   */
  export type CateringItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CateringItems.
     */
    data: CateringItemCreateManyInput | CateringItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CateringItem createManyAndReturn
   */
  export type CateringItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringItem
     */
    select?: CateringItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CateringItem
     */
    omit?: CateringItemOmit<ExtArgs> | null
    /**
     * The data used to create many CateringItems.
     */
    data: CateringItemCreateManyInput | CateringItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CateringItem update
   */
  export type CateringItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringItem
     */
    select?: CateringItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringItem
     */
    omit?: CateringItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CateringItem.
     */
    data: XOR<CateringItemUpdateInput, CateringItemUncheckedUpdateInput>
    /**
     * Choose, which CateringItem to update.
     */
    where: CateringItemWhereUniqueInput
  }

  /**
   * CateringItem updateMany
   */
  export type CateringItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CateringItems.
     */
    data: XOR<CateringItemUpdateManyMutationInput, CateringItemUncheckedUpdateManyInput>
    /**
     * Filter which CateringItems to update
     */
    where?: CateringItemWhereInput
    /**
     * Limit how many CateringItems to update.
     */
    limit?: number
  }

  /**
   * CateringItem updateManyAndReturn
   */
  export type CateringItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringItem
     */
    select?: CateringItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CateringItem
     */
    omit?: CateringItemOmit<ExtArgs> | null
    /**
     * The data used to update CateringItems.
     */
    data: XOR<CateringItemUpdateManyMutationInput, CateringItemUncheckedUpdateManyInput>
    /**
     * Filter which CateringItems to update
     */
    where?: CateringItemWhereInput
    /**
     * Limit how many CateringItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CateringItem upsert
   */
  export type CateringItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringItem
     */
    select?: CateringItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringItem
     */
    omit?: CateringItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CateringItem to update in case it exists.
     */
    where: CateringItemWhereUniqueInput
    /**
     * In case the CateringItem found by the `where` argument doesn't exist, create a new CateringItem with this data.
     */
    create: XOR<CateringItemCreateInput, CateringItemUncheckedCreateInput>
    /**
     * In case the CateringItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CateringItemUpdateInput, CateringItemUncheckedUpdateInput>
  }

  /**
   * CateringItem delete
   */
  export type CateringItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringItem
     */
    select?: CateringItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringItem
     */
    omit?: CateringItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringItemInclude<ExtArgs> | null
    /**
     * Filter which CateringItem to delete.
     */
    where: CateringItemWhereUniqueInput
  }

  /**
   * CateringItem deleteMany
   */
  export type CateringItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CateringItems to delete
     */
    where?: CateringItemWhereInput
    /**
     * Limit how many CateringItems to delete.
     */
    limit?: number
  }

  /**
   * CateringItem.menuItem
   */
  export type CateringItem$menuItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    where?: MenuItemWhereInput
  }

  /**
   * CateringItem without action
   */
  export type CateringItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringItem
     */
    select?: CateringItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CateringItem
     */
    omit?: CateringItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringItemInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    orderId: number | null
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    id: number | null
    userId: number | null
    orderId: number | null
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: number | null
    userId: number | null
    orderId: number | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    orderId: number | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    userId: number
    orderId: number
    rating: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: number
    userId: number
    orderId: number | null
    rating: number
    comment: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orderId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | Review$orderArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orderId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | Review$orderArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orderId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | Review$orderArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    orderId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "orderId" | "rating" | "comment" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | Review$orderArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | Review$orderArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | Review$orderArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      orderId: number | null
      rating: number
      comment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends Review$orderArgs<ExtArgs> = {}>(args?: Subset<T, Review$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'Int'>
    readonly userId: FieldRef<"Review", 'Int'>
    readonly orderId: FieldRef<"Review", 'Int'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review.order
   */
  export type Review$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    googleId: 'googleId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const MenuItemScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    nutrition: 'nutrition',
    allergens: 'allergens',
    isActive: 'isActive',
    archivedAt: 'archivedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenuItemScalarFieldEnum = (typeof MenuItemScalarFieldEnum)[keyof typeof MenuItemScalarFieldEnum]


  export const MenuVariantScalarFieldEnum: {
    id: 'id',
    menuItemId: 'menuItemId',
    label: 'label',
    basePriceCents: 'basePriceCents',
    baseCapacity: 'baseCapacity',
    isActive: 'isActive',
    prepMinutes: 'prepMinutes',
    packagingCostCents: 'packagingCostCents',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenuVariantScalarFieldEnum = (typeof MenuVariantScalarFieldEnum)[keyof typeof MenuVariantScalarFieldEnum]


  export const AddOnScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    priceCents: 'priceCents',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddOnScalarFieldEnum = (typeof AddOnScalarFieldEnum)[keyof typeof AddOnScalarFieldEnum]


  export const MenuItemAddOnScalarFieldEnum: {
    menuItemId: 'menuItemId',
    addOnId: 'addOnId',
    maxQtyPerItem: 'maxQtyPerItem'
  };

  export type MenuItemAddOnScalarFieldEnum = (typeof MenuItemAddOnScalarFieldEnum)[keyof typeof MenuItemAddOnScalarFieldEnum]


  export const ServiceDayScalarFieldEnum: {
    id: 'id',
    menuDate: 'menuDate',
    serviceDate: 'serviceDate',
    label: 'label',
    isPublished: 'isPublished',
    isClosed: 'isClosed',
    closedReason: 'closedReason',
    orderingCutoffAt: 'orderingCutoffAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceDayScalarFieldEnum = (typeof ServiceDayScalarFieldEnum)[keyof typeof ServiceDayScalarFieldEnum]


  export const MenuScalarFieldEnum: {
    id: 'id',
    serviceDayId: 'serviceDayId',
    menuType: 'menuType',
    title: 'title',
    isPublished: 'isPublished',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenuScalarFieldEnum = (typeof MenuScalarFieldEnum)[keyof typeof MenuScalarFieldEnum]


  export const MenuOfferingScalarFieldEnum: {
    id: 'id',
    menuId: 'menuId',
    menuVariantId: 'menuVariantId',
    priceOverrideCents: 'priceOverrideCents',
    capacityOverride: 'capacityOverride',
    isAvailable: 'isAvailable',
    maxPerOrder: 'maxPerOrder',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenuOfferingScalarFieldEnum = (typeof MenuOfferingScalarFieldEnum)[keyof typeof MenuOfferingScalarFieldEnum]


  export const PickupLocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    line1: 'line1',
    line2: 'line2',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    timezone: 'timezone',
    instructions: 'instructions',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PickupLocationScalarFieldEnum = (typeof PickupLocationScalarFieldEnum)[keyof typeof PickupLocationScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    label: 'label',
    line1: 'line1',
    line2: 'line2',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    lat: 'lat',
    lng: 'lng',
    isDefault: 'isDefault',
    isSnapshot: 'isSnapshot',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const SlotTemplateScalarFieldEnum: {
    id: 'id',
    label: 'label',
    startMin: 'startMin',
    endMin: 'endMin',
    defaultCapacity: 'defaultCapacity',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SlotTemplateScalarFieldEnum = (typeof SlotTemplateScalarFieldEnum)[keyof typeof SlotTemplateScalarFieldEnum]


  export const ServiceSlotScalarFieldEnum: {
    id: 'id',
    serviceDayId: 'serviceDayId',
    slotTemplateId: 'slotTemplateId',
    fulfillmentType: 'fulfillmentType',
    pickupLocationId: 'pickupLocationId',
    slotKey: 'slotKey',
    capacityOverride: 'capacityOverride',
    isClosed: 'isClosed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceSlotScalarFieldEnum = (typeof ServiceSlotScalarFieldEnum)[keyof typeof ServiceSlotScalarFieldEnum]


  export const DeliverySettingsScalarFieldEnum: {
    id: 'id',
    originAddress: 'originAddress',
    originLat: 'originLat',
    originLng: 'originLng',
    maxRadiusMiles: 'maxRadiusMiles',
    feeTiers: 'feeTiers',
    bundlePolicy: 'bundlePolicy',
    pricingMode: 'pricingMode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeliverySettingsScalarFieldEnum = (typeof DeliverySettingsScalarFieldEnum)[keyof typeof DeliverySettingsScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdByUserId: 'createdByUserId',
    source: 'source',
    sourceRef: 'sourceRef',
    currency: 'currency',
    checkoutStatus: 'checkoutStatus',
    deliveryPricingMode: 'deliveryPricingMode',
    fulfillmentType: 'fulfillmentType',
    pickupLocationId: 'pickupLocationId',
    deliveryAddressId: 'deliveryAddressId',
    deliveryDistanceMiles: 'deliveryDistanceMiles',
    customerName: 'customerName',
    customerEmail: 'customerEmail',
    customerPhone: 'customerPhone',
    customerNotes: 'customerNotes',
    internalNotes: 'internalNotes',
    subtotalCents: 'subtotalCents',
    adjustmentsCents: 'adjustmentsCents',
    totalCents: 'totalCents',
    refundedCents: 'refundedCents',
    placedAt: 'placedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const FulfillmentGroupScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    serviceDayId: 'serviceDayId',
    serviceSlotId: 'serviceSlotId',
    status: 'status',
    sequence: 'sequence',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FulfillmentGroupScalarFieldEnum = (typeof FulfillmentGroupScalarFieldEnum)[keyof typeof FulfillmentGroupScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    fulfillmentGroupId: 'fulfillmentGroupId',
    menuVariantId: 'menuVariantId',
    quantity: 'quantity',
    unitPriceCents: 'unitPriceCents',
    nameSnapshot: 'nameSnapshot',
    variantLabelSnapshot: 'variantLabelSnapshot',
    imageUrlSnapshot: 'imageUrlSnapshot',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const OrderItemAddOnScalarFieldEnum: {
    id: 'id',
    orderItemId: 'orderItemId',
    addOnId: 'addOnId',
    quantity: 'quantity',
    unitPriceCents: 'unitPriceCents',
    nameSnapshot: 'nameSnapshot'
  };

  export type OrderItemAddOnScalarFieldEnum = (typeof OrderItemAddOnScalarFieldEnum)[keyof typeof OrderItemAddOnScalarFieldEnum]


  export const OrderAdjustmentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    fulfillmentGroupId: 'fulfillmentGroupId',
    type: 'type',
    label: 'label',
    amountCents: 'amountCents',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type OrderAdjustmentScalarFieldEnum = (typeof OrderAdjustmentScalarFieldEnum)[keyof typeof OrderAdjustmentScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    provider: 'provider',
    method: 'method',
    status: 'status',
    amountCents: 'amountCents',
    providerRef: 'providerRef',
    receivedByUserId: 'receivedByUserId',
    receivedAt: 'receivedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const OrderEventScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    fulfillmentGroupId: 'fulfillmentGroupId',
    type: 'type',
    payload: 'payload',
    createdAt: 'createdAt'
  };

  export type OrderEventScalarFieldEnum = (typeof OrderEventScalarFieldEnum)[keyof typeof OrderEventScalarFieldEnum]


  export const CapacityHoldScalarFieldEnum: {
    id: 'id',
    menuOfferingId: 'menuOfferingId',
    orderId: 'orderId',
    quantity: 'quantity',
    status: 'status',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type CapacityHoldScalarFieldEnum = (typeof CapacityHoldScalarFieldEnum)[keyof typeof CapacityHoldScalarFieldEnum]


  export const PromotionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    type: 'type',
    amountCents: 'amountCents',
    percentBps: 'percentBps',
    minSubtotalCents: 'minSubtotalCents',
    maxRedemptions: 'maxRedemptions',
    perUserLimit: 'perUserLimit',
    startsAt: 'startsAt',
    endsAt: 'endsAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromotionScalarFieldEnum = (typeof PromotionScalarFieldEnum)[keyof typeof PromotionScalarFieldEnum]


  export const PromotionRedemptionScalarFieldEnum: {
    id: 'id',
    promotionId: 'promotionId',
    orderId: 'orderId',
    userId: 'userId',
    discountCentsApplied: 'discountCentsApplied',
    createdAt: 'createdAt'
  };

  export type PromotionRedemptionScalarFieldEnum = (typeof PromotionRedemptionScalarFieldEnum)[keyof typeof PromotionRedemptionScalarFieldEnum]


  export const RewardAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    balancePoints: 'balancePoints',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RewardAccountScalarFieldEnum = (typeof RewardAccountScalarFieldEnum)[keyof typeof RewardAccountScalarFieldEnum]


  export const RewardTransactionScalarFieldEnum: {
    id: 'id',
    rewardAccountId: 'rewardAccountId',
    type: 'type',
    amountPoints: 'amountPoints',
    orderId: 'orderId',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type RewardTransactionScalarFieldEnum = (typeof RewardTransactionScalarFieldEnum)[keyof typeof RewardTransactionScalarFieldEnum]


  export const CateringOrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdByUserId: 'createdByUserId',
    source: 'source',
    sourceRef: 'sourceRef',
    status: 'status',
    eventDate: 'eventDate',
    guestCount: 'guestCount',
    customerName: 'customerName',
    customerEmail: 'customerEmail',
    customerPhone: 'customerPhone',
    notes: 'notes',
    totalCents: 'totalCents',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CateringOrderScalarFieldEnum = (typeof CateringOrderScalarFieldEnum)[keyof typeof CateringOrderScalarFieldEnum]


  export const CateringItemScalarFieldEnum: {
    id: 'id',
    cateringOrderId: 'cateringOrderId',
    menuItemId: 'menuItemId',
    nameSnapshot: 'nameSnapshot',
    quantity: 'quantity',
    unitPriceCents: 'unitPriceCents'
  };

  export type CateringItemScalarFieldEnum = (typeof CateringItemScalarFieldEnum)[keyof typeof CateringItemScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    orderId: 'orderId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'MenuType'
   */
  export type EnumMenuTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MenuType'>
    


  /**
   * Reference to a field of type 'MenuType[]'
   */
  export type ListEnumMenuTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MenuType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'FulfillmentType'
   */
  export type EnumFulfillmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FulfillmentType'>
    


  /**
   * Reference to a field of type 'FulfillmentType[]'
   */
  export type ListEnumFulfillmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FulfillmentType[]'>
    


  /**
   * Reference to a field of type 'DeliveryPricingMode'
   */
  export type EnumDeliveryPricingModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryPricingMode'>
    


  /**
   * Reference to a field of type 'DeliveryPricingMode[]'
   */
  export type ListEnumDeliveryPricingModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryPricingMode[]'>
    


  /**
   * Reference to a field of type 'OrderSource'
   */
  export type EnumOrderSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderSource'>
    


  /**
   * Reference to a field of type 'OrderSource[]'
   */
  export type ListEnumOrderSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderSource[]'>
    


  /**
   * Reference to a field of type 'OrderCheckoutStatus'
   */
  export type EnumOrderCheckoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderCheckoutStatus'>
    


  /**
   * Reference to a field of type 'OrderCheckoutStatus[]'
   */
  export type ListEnumOrderCheckoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderCheckoutStatus[]'>
    


  /**
   * Reference to a field of type 'FulfillmentGroupStatus'
   */
  export type EnumFulfillmentGroupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FulfillmentGroupStatus'>
    


  /**
   * Reference to a field of type 'FulfillmentGroupStatus[]'
   */
  export type ListEnumFulfillmentGroupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FulfillmentGroupStatus[]'>
    


  /**
   * Reference to a field of type 'AdjustmentType'
   */
  export type EnumAdjustmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdjustmentType'>
    


  /**
   * Reference to a field of type 'AdjustmentType[]'
   */
  export type ListEnumAdjustmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdjustmentType[]'>
    


  /**
   * Reference to a field of type 'PaymentProvider'
   */
  export type EnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentProvider'>
    


  /**
   * Reference to a field of type 'PaymentProvider[]'
   */
  export type ListEnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentProvider[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'HoldStatus'
   */
  export type EnumHoldStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HoldStatus'>
    


  /**
   * Reference to a field of type 'HoldStatus[]'
   */
  export type ListEnumHoldStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HoldStatus[]'>
    


  /**
   * Reference to a field of type 'PromotionType'
   */
  export type EnumPromotionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromotionType'>
    


  /**
   * Reference to a field of type 'PromotionType[]'
   */
  export type ListEnumPromotionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromotionType[]'>
    


  /**
   * Reference to a field of type 'RewardTxnType'
   */
  export type EnumRewardTxnTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RewardTxnType'>
    


  /**
   * Reference to a field of type 'RewardTxnType[]'
   */
  export type ListEnumRewardTxnTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RewardTxnType[]'>
    


  /**
   * Reference to a field of type 'CateringStatus'
   */
  export type EnumCateringStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CateringStatus'>
    


  /**
   * Reference to a field of type 'CateringStatus[]'
   */
  export type ListEnumCateringStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CateringStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    googleId?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    orders?: OrderListRelationFilter
    createdOrders?: OrderListRelationFilter
    addresses?: AddressListRelationFilter
    paymentsReceived?: PaymentListRelationFilter
    cateringOrders?: CateringOrderListRelationFilter
    createdCateringOrders?: CateringOrderListRelationFilter
    rewardAccount?: XOR<RewardAccountNullableScalarRelationFilter, RewardAccountWhereInput> | null
    reviews?: ReviewListRelationFilter
    promotionRedemptions?: PromotionRedemptionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
    createdOrders?: OrderOrderByRelationAggregateInput
    addresses?: AddressOrderByRelationAggregateInput
    paymentsReceived?: PaymentOrderByRelationAggregateInput
    cateringOrders?: CateringOrderOrderByRelationAggregateInput
    createdCateringOrders?: CateringOrderOrderByRelationAggregateInput
    rewardAccount?: RewardAccountOrderByWithRelationInput
    reviews?: ReviewOrderByRelationAggregateInput
    promotionRedemptions?: PromotionRedemptionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    googleId?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    orders?: OrderListRelationFilter
    createdOrders?: OrderListRelationFilter
    addresses?: AddressListRelationFilter
    paymentsReceived?: PaymentListRelationFilter
    cateringOrders?: CateringOrderListRelationFilter
    createdCateringOrders?: CateringOrderListRelationFilter
    rewardAccount?: XOR<RewardAccountNullableScalarRelationFilter, RewardAccountWhereInput> | null
    reviews?: ReviewListRelationFilter
    promotionRedemptions?: PromotionRedemptionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    position?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    items?: MenuItemListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: MenuItemOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    position?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    items?: MenuItemListRelationFilter
  }, "id" | "name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
    position?: IntWithAggregatesFilter<"Category"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type MenuItemWhereInput = {
    AND?: MenuItemWhereInput | MenuItemWhereInput[]
    OR?: MenuItemWhereInput[]
    NOT?: MenuItemWhereInput | MenuItemWhereInput[]
    id?: IntFilter<"MenuItem"> | number
    categoryId?: IntNullableFilter<"MenuItem"> | number | null
    name?: StringFilter<"MenuItem"> | string
    description?: StringNullableFilter<"MenuItem"> | string | null
    imageUrl?: StringNullableFilter<"MenuItem"> | string | null
    nutrition?: JsonNullableFilter<"MenuItem">
    allergens?: JsonNullableFilter<"MenuItem">
    isActive?: BoolFilter<"MenuItem"> | boolean
    archivedAt?: DateTimeNullableFilter<"MenuItem"> | Date | string | null
    createdAt?: DateTimeFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeFilter<"MenuItem"> | Date | string
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    variants?: MenuVariantListRelationFilter
    addOnLinks?: MenuItemAddOnListRelationFilter
    cateringItems?: CateringItemListRelationFilter
  }

  export type MenuItemOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    nutrition?: SortOrderInput | SortOrder
    allergens?: SortOrderInput | SortOrder
    isActive?: SortOrder
    archivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CategoryOrderByWithRelationInput
    variants?: MenuVariantOrderByRelationAggregateInput
    addOnLinks?: MenuItemAddOnOrderByRelationAggregateInput
    cateringItems?: CateringItemOrderByRelationAggregateInput
  }

  export type MenuItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MenuItemWhereInput | MenuItemWhereInput[]
    OR?: MenuItemWhereInput[]
    NOT?: MenuItemWhereInput | MenuItemWhereInput[]
    categoryId?: IntNullableFilter<"MenuItem"> | number | null
    name?: StringFilter<"MenuItem"> | string
    description?: StringNullableFilter<"MenuItem"> | string | null
    imageUrl?: StringNullableFilter<"MenuItem"> | string | null
    nutrition?: JsonNullableFilter<"MenuItem">
    allergens?: JsonNullableFilter<"MenuItem">
    isActive?: BoolFilter<"MenuItem"> | boolean
    archivedAt?: DateTimeNullableFilter<"MenuItem"> | Date | string | null
    createdAt?: DateTimeFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeFilter<"MenuItem"> | Date | string
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    variants?: MenuVariantListRelationFilter
    addOnLinks?: MenuItemAddOnListRelationFilter
    cateringItems?: CateringItemListRelationFilter
  }, "id">

  export type MenuItemOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    nutrition?: SortOrderInput | SortOrder
    allergens?: SortOrderInput | SortOrder
    isActive?: SortOrder
    archivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuItemCountOrderByAggregateInput
    _avg?: MenuItemAvgOrderByAggregateInput
    _max?: MenuItemMaxOrderByAggregateInput
    _min?: MenuItemMinOrderByAggregateInput
    _sum?: MenuItemSumOrderByAggregateInput
  }

  export type MenuItemScalarWhereWithAggregatesInput = {
    AND?: MenuItemScalarWhereWithAggregatesInput | MenuItemScalarWhereWithAggregatesInput[]
    OR?: MenuItemScalarWhereWithAggregatesInput[]
    NOT?: MenuItemScalarWhereWithAggregatesInput | MenuItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MenuItem"> | number
    categoryId?: IntNullableWithAggregatesFilter<"MenuItem"> | number | null
    name?: StringWithAggregatesFilter<"MenuItem"> | string
    description?: StringNullableWithAggregatesFilter<"MenuItem"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"MenuItem"> | string | null
    nutrition?: JsonNullableWithAggregatesFilter<"MenuItem">
    allergens?: JsonNullableWithAggregatesFilter<"MenuItem">
    isActive?: BoolWithAggregatesFilter<"MenuItem"> | boolean
    archivedAt?: DateTimeNullableWithAggregatesFilter<"MenuItem"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MenuItem"> | Date | string
  }

  export type MenuVariantWhereInput = {
    AND?: MenuVariantWhereInput | MenuVariantWhereInput[]
    OR?: MenuVariantWhereInput[]
    NOT?: MenuVariantWhereInput | MenuVariantWhereInput[]
    id?: IntFilter<"MenuVariant"> | number
    menuItemId?: IntFilter<"MenuVariant"> | number
    label?: StringFilter<"MenuVariant"> | string
    basePriceCents?: IntFilter<"MenuVariant"> | number
    baseCapacity?: IntNullableFilter<"MenuVariant"> | number | null
    isActive?: BoolFilter<"MenuVariant"> | boolean
    prepMinutes?: IntNullableFilter<"MenuVariant"> | number | null
    packagingCostCents?: IntNullableFilter<"MenuVariant"> | number | null
    createdAt?: DateTimeFilter<"MenuVariant"> | Date | string
    updatedAt?: DateTimeFilter<"MenuVariant"> | Date | string
    menuItem?: XOR<MenuItemScalarRelationFilter, MenuItemWhereInput>
    offerings?: MenuOfferingListRelationFilter
    orderItems?: OrderItemListRelationFilter
  }

  export type MenuVariantOrderByWithRelationInput = {
    id?: SortOrder
    menuItemId?: SortOrder
    label?: SortOrder
    basePriceCents?: SortOrder
    baseCapacity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    prepMinutes?: SortOrderInput | SortOrder
    packagingCostCents?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menuItem?: MenuItemOrderByWithRelationInput
    offerings?: MenuOfferingOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
  }

  export type MenuVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MenuVariantWhereInput | MenuVariantWhereInput[]
    OR?: MenuVariantWhereInput[]
    NOT?: MenuVariantWhereInput | MenuVariantWhereInput[]
    menuItemId?: IntFilter<"MenuVariant"> | number
    label?: StringFilter<"MenuVariant"> | string
    basePriceCents?: IntFilter<"MenuVariant"> | number
    baseCapacity?: IntNullableFilter<"MenuVariant"> | number | null
    isActive?: BoolFilter<"MenuVariant"> | boolean
    prepMinutes?: IntNullableFilter<"MenuVariant"> | number | null
    packagingCostCents?: IntNullableFilter<"MenuVariant"> | number | null
    createdAt?: DateTimeFilter<"MenuVariant"> | Date | string
    updatedAt?: DateTimeFilter<"MenuVariant"> | Date | string
    menuItem?: XOR<MenuItemScalarRelationFilter, MenuItemWhereInput>
    offerings?: MenuOfferingListRelationFilter
    orderItems?: OrderItemListRelationFilter
  }, "id">

  export type MenuVariantOrderByWithAggregationInput = {
    id?: SortOrder
    menuItemId?: SortOrder
    label?: SortOrder
    basePriceCents?: SortOrder
    baseCapacity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    prepMinutes?: SortOrderInput | SortOrder
    packagingCostCents?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuVariantCountOrderByAggregateInput
    _avg?: MenuVariantAvgOrderByAggregateInput
    _max?: MenuVariantMaxOrderByAggregateInput
    _min?: MenuVariantMinOrderByAggregateInput
    _sum?: MenuVariantSumOrderByAggregateInput
  }

  export type MenuVariantScalarWhereWithAggregatesInput = {
    AND?: MenuVariantScalarWhereWithAggregatesInput | MenuVariantScalarWhereWithAggregatesInput[]
    OR?: MenuVariantScalarWhereWithAggregatesInput[]
    NOT?: MenuVariantScalarWhereWithAggregatesInput | MenuVariantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MenuVariant"> | number
    menuItemId?: IntWithAggregatesFilter<"MenuVariant"> | number
    label?: StringWithAggregatesFilter<"MenuVariant"> | string
    basePriceCents?: IntWithAggregatesFilter<"MenuVariant"> | number
    baseCapacity?: IntNullableWithAggregatesFilter<"MenuVariant"> | number | null
    isActive?: BoolWithAggregatesFilter<"MenuVariant"> | boolean
    prepMinutes?: IntNullableWithAggregatesFilter<"MenuVariant"> | number | null
    packagingCostCents?: IntNullableWithAggregatesFilter<"MenuVariant"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"MenuVariant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MenuVariant"> | Date | string
  }

  export type AddOnWhereInput = {
    AND?: AddOnWhereInput | AddOnWhereInput[]
    OR?: AddOnWhereInput[]
    NOT?: AddOnWhereInput | AddOnWhereInput[]
    id?: IntFilter<"AddOn"> | number
    name?: StringFilter<"AddOn"> | string
    description?: StringNullableFilter<"AddOn"> | string | null
    imageUrl?: StringNullableFilter<"AddOn"> | string | null
    priceCents?: IntFilter<"AddOn"> | number
    isActive?: BoolFilter<"AddOn"> | boolean
    createdAt?: DateTimeFilter<"AddOn"> | Date | string
    updatedAt?: DateTimeFilter<"AddOn"> | Date | string
    itemLinks?: MenuItemAddOnListRelationFilter
    orderLinks?: OrderItemAddOnListRelationFilter
  }

  export type AddOnOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    priceCents?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    itemLinks?: MenuItemAddOnOrderByRelationAggregateInput
    orderLinks?: OrderItemAddOnOrderByRelationAggregateInput
  }

  export type AddOnWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddOnWhereInput | AddOnWhereInput[]
    OR?: AddOnWhereInput[]
    NOT?: AddOnWhereInput | AddOnWhereInput[]
    name?: StringFilter<"AddOn"> | string
    description?: StringNullableFilter<"AddOn"> | string | null
    imageUrl?: StringNullableFilter<"AddOn"> | string | null
    priceCents?: IntFilter<"AddOn"> | number
    isActive?: BoolFilter<"AddOn"> | boolean
    createdAt?: DateTimeFilter<"AddOn"> | Date | string
    updatedAt?: DateTimeFilter<"AddOn"> | Date | string
    itemLinks?: MenuItemAddOnListRelationFilter
    orderLinks?: OrderItemAddOnListRelationFilter
  }, "id">

  export type AddOnOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    priceCents?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddOnCountOrderByAggregateInput
    _avg?: AddOnAvgOrderByAggregateInput
    _max?: AddOnMaxOrderByAggregateInput
    _min?: AddOnMinOrderByAggregateInput
    _sum?: AddOnSumOrderByAggregateInput
  }

  export type AddOnScalarWhereWithAggregatesInput = {
    AND?: AddOnScalarWhereWithAggregatesInput | AddOnScalarWhereWithAggregatesInput[]
    OR?: AddOnScalarWhereWithAggregatesInput[]
    NOT?: AddOnScalarWhereWithAggregatesInput | AddOnScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AddOn"> | number
    name?: StringWithAggregatesFilter<"AddOn"> | string
    description?: StringNullableWithAggregatesFilter<"AddOn"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"AddOn"> | string | null
    priceCents?: IntWithAggregatesFilter<"AddOn"> | number
    isActive?: BoolWithAggregatesFilter<"AddOn"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AddOn"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AddOn"> | Date | string
  }

  export type MenuItemAddOnWhereInput = {
    AND?: MenuItemAddOnWhereInput | MenuItemAddOnWhereInput[]
    OR?: MenuItemAddOnWhereInput[]
    NOT?: MenuItemAddOnWhereInput | MenuItemAddOnWhereInput[]
    menuItemId?: IntFilter<"MenuItemAddOn"> | number
    addOnId?: IntFilter<"MenuItemAddOn"> | number
    maxQtyPerItem?: IntNullableFilter<"MenuItemAddOn"> | number | null
    menuItem?: XOR<MenuItemScalarRelationFilter, MenuItemWhereInput>
    addOn?: XOR<AddOnScalarRelationFilter, AddOnWhereInput>
  }

  export type MenuItemAddOnOrderByWithRelationInput = {
    menuItemId?: SortOrder
    addOnId?: SortOrder
    maxQtyPerItem?: SortOrderInput | SortOrder
    menuItem?: MenuItemOrderByWithRelationInput
    addOn?: AddOnOrderByWithRelationInput
  }

  export type MenuItemAddOnWhereUniqueInput = Prisma.AtLeast<{
    menuItemId_addOnId?: MenuItemAddOnMenuItemIdAddOnIdCompoundUniqueInput
    AND?: MenuItemAddOnWhereInput | MenuItemAddOnWhereInput[]
    OR?: MenuItemAddOnWhereInput[]
    NOT?: MenuItemAddOnWhereInput | MenuItemAddOnWhereInput[]
    menuItemId?: IntFilter<"MenuItemAddOn"> | number
    addOnId?: IntFilter<"MenuItemAddOn"> | number
    maxQtyPerItem?: IntNullableFilter<"MenuItemAddOn"> | number | null
    menuItem?: XOR<MenuItemScalarRelationFilter, MenuItemWhereInput>
    addOn?: XOR<AddOnScalarRelationFilter, AddOnWhereInput>
  }, "menuItemId_addOnId">

  export type MenuItemAddOnOrderByWithAggregationInput = {
    menuItemId?: SortOrder
    addOnId?: SortOrder
    maxQtyPerItem?: SortOrderInput | SortOrder
    _count?: MenuItemAddOnCountOrderByAggregateInput
    _avg?: MenuItemAddOnAvgOrderByAggregateInput
    _max?: MenuItemAddOnMaxOrderByAggregateInput
    _min?: MenuItemAddOnMinOrderByAggregateInput
    _sum?: MenuItemAddOnSumOrderByAggregateInput
  }

  export type MenuItemAddOnScalarWhereWithAggregatesInput = {
    AND?: MenuItemAddOnScalarWhereWithAggregatesInput | MenuItemAddOnScalarWhereWithAggregatesInput[]
    OR?: MenuItemAddOnScalarWhereWithAggregatesInput[]
    NOT?: MenuItemAddOnScalarWhereWithAggregatesInput | MenuItemAddOnScalarWhereWithAggregatesInput[]
    menuItemId?: IntWithAggregatesFilter<"MenuItemAddOn"> | number
    addOnId?: IntWithAggregatesFilter<"MenuItemAddOn"> | number
    maxQtyPerItem?: IntNullableWithAggregatesFilter<"MenuItemAddOn"> | number | null
  }

  export type ServiceDayWhereInput = {
    AND?: ServiceDayWhereInput | ServiceDayWhereInput[]
    OR?: ServiceDayWhereInput[]
    NOT?: ServiceDayWhereInput | ServiceDayWhereInput[]
    id?: IntFilter<"ServiceDay"> | number
    menuDate?: DateTimeFilter<"ServiceDay"> | Date | string
    serviceDate?: DateTimeFilter<"ServiceDay"> | Date | string
    label?: StringNullableFilter<"ServiceDay"> | string | null
    isPublished?: BoolFilter<"ServiceDay"> | boolean
    isClosed?: BoolFilter<"ServiceDay"> | boolean
    closedReason?: StringNullableFilter<"ServiceDay"> | string | null
    orderingCutoffAt?: DateTimeNullableFilter<"ServiceDay"> | Date | string | null
    createdAt?: DateTimeFilter<"ServiceDay"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceDay"> | Date | string
    menus?: MenuListRelationFilter
    slots?: ServiceSlotListRelationFilter
    groups?: FulfillmentGroupListRelationFilter
  }

  export type ServiceDayOrderByWithRelationInput = {
    id?: SortOrder
    menuDate?: SortOrder
    serviceDate?: SortOrder
    label?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    isClosed?: SortOrder
    closedReason?: SortOrderInput | SortOrder
    orderingCutoffAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menus?: MenuOrderByRelationAggregateInput
    slots?: ServiceSlotOrderByRelationAggregateInput
    groups?: FulfillmentGroupOrderByRelationAggregateInput
  }

  export type ServiceDayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serviceDate?: Date | string
    AND?: ServiceDayWhereInput | ServiceDayWhereInput[]
    OR?: ServiceDayWhereInput[]
    NOT?: ServiceDayWhereInput | ServiceDayWhereInput[]
    menuDate?: DateTimeFilter<"ServiceDay"> | Date | string
    label?: StringNullableFilter<"ServiceDay"> | string | null
    isPublished?: BoolFilter<"ServiceDay"> | boolean
    isClosed?: BoolFilter<"ServiceDay"> | boolean
    closedReason?: StringNullableFilter<"ServiceDay"> | string | null
    orderingCutoffAt?: DateTimeNullableFilter<"ServiceDay"> | Date | string | null
    createdAt?: DateTimeFilter<"ServiceDay"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceDay"> | Date | string
    menus?: MenuListRelationFilter
    slots?: ServiceSlotListRelationFilter
    groups?: FulfillmentGroupListRelationFilter
  }, "id" | "serviceDate">

  export type ServiceDayOrderByWithAggregationInput = {
    id?: SortOrder
    menuDate?: SortOrder
    serviceDate?: SortOrder
    label?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    isClosed?: SortOrder
    closedReason?: SortOrderInput | SortOrder
    orderingCutoffAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceDayCountOrderByAggregateInput
    _avg?: ServiceDayAvgOrderByAggregateInput
    _max?: ServiceDayMaxOrderByAggregateInput
    _min?: ServiceDayMinOrderByAggregateInput
    _sum?: ServiceDaySumOrderByAggregateInput
  }

  export type ServiceDayScalarWhereWithAggregatesInput = {
    AND?: ServiceDayScalarWhereWithAggregatesInput | ServiceDayScalarWhereWithAggregatesInput[]
    OR?: ServiceDayScalarWhereWithAggregatesInput[]
    NOT?: ServiceDayScalarWhereWithAggregatesInput | ServiceDayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceDay"> | number
    menuDate?: DateTimeWithAggregatesFilter<"ServiceDay"> | Date | string
    serviceDate?: DateTimeWithAggregatesFilter<"ServiceDay"> | Date | string
    label?: StringNullableWithAggregatesFilter<"ServiceDay"> | string | null
    isPublished?: BoolWithAggregatesFilter<"ServiceDay"> | boolean
    isClosed?: BoolWithAggregatesFilter<"ServiceDay"> | boolean
    closedReason?: StringNullableWithAggregatesFilter<"ServiceDay"> | string | null
    orderingCutoffAt?: DateTimeNullableWithAggregatesFilter<"ServiceDay"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceDay"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceDay"> | Date | string
  }

  export type MenuWhereInput = {
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    id?: IntFilter<"Menu"> | number
    serviceDayId?: IntFilter<"Menu"> | number
    menuType?: EnumMenuTypeFilter<"Menu"> | $Enums.MenuType
    title?: StringNullableFilter<"Menu"> | string | null
    isPublished?: BoolFilter<"Menu"> | boolean
    displayOrder?: IntFilter<"Menu"> | number
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    serviceDay?: XOR<ServiceDayScalarRelationFilter, ServiceDayWhereInput>
    offerings?: MenuOfferingListRelationFilter
  }

  export type MenuOrderByWithRelationInput = {
    id?: SortOrder
    serviceDayId?: SortOrder
    menuType?: SortOrder
    title?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceDay?: ServiceDayOrderByWithRelationInput
    offerings?: MenuOfferingOrderByRelationAggregateInput
  }

  export type MenuWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serviceDayId_menuType?: MenuServiceDayIdMenuTypeCompoundUniqueInput
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    serviceDayId?: IntFilter<"Menu"> | number
    menuType?: EnumMenuTypeFilter<"Menu"> | $Enums.MenuType
    title?: StringNullableFilter<"Menu"> | string | null
    isPublished?: BoolFilter<"Menu"> | boolean
    displayOrder?: IntFilter<"Menu"> | number
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    serviceDay?: XOR<ServiceDayScalarRelationFilter, ServiceDayWhereInput>
    offerings?: MenuOfferingListRelationFilter
  }, "id" | "serviceDayId_menuType">

  export type MenuOrderByWithAggregationInput = {
    id?: SortOrder
    serviceDayId?: SortOrder
    menuType?: SortOrder
    title?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuCountOrderByAggregateInput
    _avg?: MenuAvgOrderByAggregateInput
    _max?: MenuMaxOrderByAggregateInput
    _min?: MenuMinOrderByAggregateInput
    _sum?: MenuSumOrderByAggregateInput
  }

  export type MenuScalarWhereWithAggregatesInput = {
    AND?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    OR?: MenuScalarWhereWithAggregatesInput[]
    NOT?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Menu"> | number
    serviceDayId?: IntWithAggregatesFilter<"Menu"> | number
    menuType?: EnumMenuTypeWithAggregatesFilter<"Menu"> | $Enums.MenuType
    title?: StringNullableWithAggregatesFilter<"Menu"> | string | null
    isPublished?: BoolWithAggregatesFilter<"Menu"> | boolean
    displayOrder?: IntWithAggregatesFilter<"Menu"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
  }

  export type MenuOfferingWhereInput = {
    AND?: MenuOfferingWhereInput | MenuOfferingWhereInput[]
    OR?: MenuOfferingWhereInput[]
    NOT?: MenuOfferingWhereInput | MenuOfferingWhereInput[]
    id?: IntFilter<"MenuOffering"> | number
    menuId?: IntFilter<"MenuOffering"> | number
    menuVariantId?: IntFilter<"MenuOffering"> | number
    priceOverrideCents?: IntNullableFilter<"MenuOffering"> | number | null
    capacityOverride?: IntNullableFilter<"MenuOffering"> | number | null
    isAvailable?: BoolFilter<"MenuOffering"> | boolean
    maxPerOrder?: IntNullableFilter<"MenuOffering"> | number | null
    position?: IntFilter<"MenuOffering"> | number
    createdAt?: DateTimeFilter<"MenuOffering"> | Date | string
    updatedAt?: DateTimeFilter<"MenuOffering"> | Date | string
    menu?: XOR<MenuScalarRelationFilter, MenuWhereInput>
    variant?: XOR<MenuVariantScalarRelationFilter, MenuVariantWhereInput>
    holds?: CapacityHoldListRelationFilter
  }

  export type MenuOfferingOrderByWithRelationInput = {
    id?: SortOrder
    menuId?: SortOrder
    menuVariantId?: SortOrder
    priceOverrideCents?: SortOrderInput | SortOrder
    capacityOverride?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    maxPerOrder?: SortOrderInput | SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menu?: MenuOrderByWithRelationInput
    variant?: MenuVariantOrderByWithRelationInput
    holds?: CapacityHoldOrderByRelationAggregateInput
  }

  export type MenuOfferingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    menuId_menuVariantId?: MenuOfferingMenuIdMenuVariantIdCompoundUniqueInput
    AND?: MenuOfferingWhereInput | MenuOfferingWhereInput[]
    OR?: MenuOfferingWhereInput[]
    NOT?: MenuOfferingWhereInput | MenuOfferingWhereInput[]
    menuId?: IntFilter<"MenuOffering"> | number
    menuVariantId?: IntFilter<"MenuOffering"> | number
    priceOverrideCents?: IntNullableFilter<"MenuOffering"> | number | null
    capacityOverride?: IntNullableFilter<"MenuOffering"> | number | null
    isAvailable?: BoolFilter<"MenuOffering"> | boolean
    maxPerOrder?: IntNullableFilter<"MenuOffering"> | number | null
    position?: IntFilter<"MenuOffering"> | number
    createdAt?: DateTimeFilter<"MenuOffering"> | Date | string
    updatedAt?: DateTimeFilter<"MenuOffering"> | Date | string
    menu?: XOR<MenuScalarRelationFilter, MenuWhereInput>
    variant?: XOR<MenuVariantScalarRelationFilter, MenuVariantWhereInput>
    holds?: CapacityHoldListRelationFilter
  }, "id" | "menuId_menuVariantId">

  export type MenuOfferingOrderByWithAggregationInput = {
    id?: SortOrder
    menuId?: SortOrder
    menuVariantId?: SortOrder
    priceOverrideCents?: SortOrderInput | SortOrder
    capacityOverride?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    maxPerOrder?: SortOrderInput | SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuOfferingCountOrderByAggregateInput
    _avg?: MenuOfferingAvgOrderByAggregateInput
    _max?: MenuOfferingMaxOrderByAggregateInput
    _min?: MenuOfferingMinOrderByAggregateInput
    _sum?: MenuOfferingSumOrderByAggregateInput
  }

  export type MenuOfferingScalarWhereWithAggregatesInput = {
    AND?: MenuOfferingScalarWhereWithAggregatesInput | MenuOfferingScalarWhereWithAggregatesInput[]
    OR?: MenuOfferingScalarWhereWithAggregatesInput[]
    NOT?: MenuOfferingScalarWhereWithAggregatesInput | MenuOfferingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MenuOffering"> | number
    menuId?: IntWithAggregatesFilter<"MenuOffering"> | number
    menuVariantId?: IntWithAggregatesFilter<"MenuOffering"> | number
    priceOverrideCents?: IntNullableWithAggregatesFilter<"MenuOffering"> | number | null
    capacityOverride?: IntNullableWithAggregatesFilter<"MenuOffering"> | number | null
    isAvailable?: BoolWithAggregatesFilter<"MenuOffering"> | boolean
    maxPerOrder?: IntNullableWithAggregatesFilter<"MenuOffering"> | number | null
    position?: IntWithAggregatesFilter<"MenuOffering"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MenuOffering"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MenuOffering"> | Date | string
  }

  export type PickupLocationWhereInput = {
    AND?: PickupLocationWhereInput | PickupLocationWhereInput[]
    OR?: PickupLocationWhereInput[]
    NOT?: PickupLocationWhereInput | PickupLocationWhereInput[]
    id?: IntFilter<"PickupLocation"> | number
    name?: StringFilter<"PickupLocation"> | string
    line1?: StringFilter<"PickupLocation"> | string
    line2?: StringNullableFilter<"PickupLocation"> | string | null
    city?: StringFilter<"PickupLocation"> | string
    state?: StringFilter<"PickupLocation"> | string
    postalCode?: StringFilter<"PickupLocation"> | string
    country?: StringFilter<"PickupLocation"> | string
    timezone?: StringNullableFilter<"PickupLocation"> | string | null
    instructions?: StringNullableFilter<"PickupLocation"> | string | null
    isActive?: BoolFilter<"PickupLocation"> | boolean
    createdAt?: DateTimeFilter<"PickupLocation"> | Date | string
    updatedAt?: DateTimeFilter<"PickupLocation"> | Date | string
    serviceSlots?: ServiceSlotListRelationFilter
    orders?: OrderListRelationFilter
  }

  export type PickupLocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    line1?: SortOrder
    line2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    timezone?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceSlots?: ServiceSlotOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
  }

  export type PickupLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PickupLocationWhereInput | PickupLocationWhereInput[]
    OR?: PickupLocationWhereInput[]
    NOT?: PickupLocationWhereInput | PickupLocationWhereInput[]
    name?: StringFilter<"PickupLocation"> | string
    line1?: StringFilter<"PickupLocation"> | string
    line2?: StringNullableFilter<"PickupLocation"> | string | null
    city?: StringFilter<"PickupLocation"> | string
    state?: StringFilter<"PickupLocation"> | string
    postalCode?: StringFilter<"PickupLocation"> | string
    country?: StringFilter<"PickupLocation"> | string
    timezone?: StringNullableFilter<"PickupLocation"> | string | null
    instructions?: StringNullableFilter<"PickupLocation"> | string | null
    isActive?: BoolFilter<"PickupLocation"> | boolean
    createdAt?: DateTimeFilter<"PickupLocation"> | Date | string
    updatedAt?: DateTimeFilter<"PickupLocation"> | Date | string
    serviceSlots?: ServiceSlotListRelationFilter
    orders?: OrderListRelationFilter
  }, "id">

  export type PickupLocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    line1?: SortOrder
    line2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    timezone?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PickupLocationCountOrderByAggregateInput
    _avg?: PickupLocationAvgOrderByAggregateInput
    _max?: PickupLocationMaxOrderByAggregateInput
    _min?: PickupLocationMinOrderByAggregateInput
    _sum?: PickupLocationSumOrderByAggregateInput
  }

  export type PickupLocationScalarWhereWithAggregatesInput = {
    AND?: PickupLocationScalarWhereWithAggregatesInput | PickupLocationScalarWhereWithAggregatesInput[]
    OR?: PickupLocationScalarWhereWithAggregatesInput[]
    NOT?: PickupLocationScalarWhereWithAggregatesInput | PickupLocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PickupLocation"> | number
    name?: StringWithAggregatesFilter<"PickupLocation"> | string
    line1?: StringWithAggregatesFilter<"PickupLocation"> | string
    line2?: StringNullableWithAggregatesFilter<"PickupLocation"> | string | null
    city?: StringWithAggregatesFilter<"PickupLocation"> | string
    state?: StringWithAggregatesFilter<"PickupLocation"> | string
    postalCode?: StringWithAggregatesFilter<"PickupLocation"> | string
    country?: StringWithAggregatesFilter<"PickupLocation"> | string
    timezone?: StringNullableWithAggregatesFilter<"PickupLocation"> | string | null
    instructions?: StringNullableWithAggregatesFilter<"PickupLocation"> | string | null
    isActive?: BoolWithAggregatesFilter<"PickupLocation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PickupLocation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PickupLocation"> | Date | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: IntFilter<"Address"> | number
    userId?: IntNullableFilter<"Address"> | number | null
    label?: StringNullableFilter<"Address"> | string | null
    line1?: StringFilter<"Address"> | string
    line2?: StringNullableFilter<"Address"> | string | null
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    lat?: FloatNullableFilter<"Address"> | number | null
    lng?: FloatNullableFilter<"Address"> | number | null
    isDefault?: BoolFilter<"Address"> | boolean
    isSnapshot?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    deliveryOrders?: OrderListRelationFilter
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    label?: SortOrderInput | SortOrder
    line1?: SortOrder
    line2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isSnapshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    deliveryOrders?: OrderOrderByRelationAggregateInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    userId?: IntNullableFilter<"Address"> | number | null
    label?: StringNullableFilter<"Address"> | string | null
    line1?: StringFilter<"Address"> | string
    line2?: StringNullableFilter<"Address"> | string | null
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    lat?: FloatNullableFilter<"Address"> | number | null
    lng?: FloatNullableFilter<"Address"> | number | null
    isDefault?: BoolFilter<"Address"> | boolean
    isSnapshot?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    deliveryOrders?: OrderListRelationFilter
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    label?: SortOrderInput | SortOrder
    line1?: SortOrder
    line2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isSnapshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _avg?: AddressAvgOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
    _sum?: AddressSumOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Address"> | number
    userId?: IntNullableWithAggregatesFilter<"Address"> | number | null
    label?: StringNullableWithAggregatesFilter<"Address"> | string | null
    line1?: StringWithAggregatesFilter<"Address"> | string
    line2?: StringNullableWithAggregatesFilter<"Address"> | string | null
    city?: StringWithAggregatesFilter<"Address"> | string
    state?: StringWithAggregatesFilter<"Address"> | string
    postalCode?: StringWithAggregatesFilter<"Address"> | string
    country?: StringWithAggregatesFilter<"Address"> | string
    lat?: FloatNullableWithAggregatesFilter<"Address"> | number | null
    lng?: FloatNullableWithAggregatesFilter<"Address"> | number | null
    isDefault?: BoolWithAggregatesFilter<"Address"> | boolean
    isSnapshot?: BoolWithAggregatesFilter<"Address"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
  }

  export type SlotTemplateWhereInput = {
    AND?: SlotTemplateWhereInput | SlotTemplateWhereInput[]
    OR?: SlotTemplateWhereInput[]
    NOT?: SlotTemplateWhereInput | SlotTemplateWhereInput[]
    id?: IntFilter<"SlotTemplate"> | number
    label?: StringFilter<"SlotTemplate"> | string
    startMin?: IntFilter<"SlotTemplate"> | number
    endMin?: IntFilter<"SlotTemplate"> | number
    defaultCapacity?: IntFilter<"SlotTemplate"> | number
    isActive?: BoolFilter<"SlotTemplate"> | boolean
    createdAt?: DateTimeFilter<"SlotTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"SlotTemplate"> | Date | string
    serviceSlots?: ServiceSlotListRelationFilter
  }

  export type SlotTemplateOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    startMin?: SortOrder
    endMin?: SortOrder
    defaultCapacity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceSlots?: ServiceSlotOrderByRelationAggregateInput
  }

  export type SlotTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SlotTemplateWhereInput | SlotTemplateWhereInput[]
    OR?: SlotTemplateWhereInput[]
    NOT?: SlotTemplateWhereInput | SlotTemplateWhereInput[]
    label?: StringFilter<"SlotTemplate"> | string
    startMin?: IntFilter<"SlotTemplate"> | number
    endMin?: IntFilter<"SlotTemplate"> | number
    defaultCapacity?: IntFilter<"SlotTemplate"> | number
    isActive?: BoolFilter<"SlotTemplate"> | boolean
    createdAt?: DateTimeFilter<"SlotTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"SlotTemplate"> | Date | string
    serviceSlots?: ServiceSlotListRelationFilter
  }, "id">

  export type SlotTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    startMin?: SortOrder
    endMin?: SortOrder
    defaultCapacity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SlotTemplateCountOrderByAggregateInput
    _avg?: SlotTemplateAvgOrderByAggregateInput
    _max?: SlotTemplateMaxOrderByAggregateInput
    _min?: SlotTemplateMinOrderByAggregateInput
    _sum?: SlotTemplateSumOrderByAggregateInput
  }

  export type SlotTemplateScalarWhereWithAggregatesInput = {
    AND?: SlotTemplateScalarWhereWithAggregatesInput | SlotTemplateScalarWhereWithAggregatesInput[]
    OR?: SlotTemplateScalarWhereWithAggregatesInput[]
    NOT?: SlotTemplateScalarWhereWithAggregatesInput | SlotTemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SlotTemplate"> | number
    label?: StringWithAggregatesFilter<"SlotTemplate"> | string
    startMin?: IntWithAggregatesFilter<"SlotTemplate"> | number
    endMin?: IntWithAggregatesFilter<"SlotTemplate"> | number
    defaultCapacity?: IntWithAggregatesFilter<"SlotTemplate"> | number
    isActive?: BoolWithAggregatesFilter<"SlotTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SlotTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SlotTemplate"> | Date | string
  }

  export type ServiceSlotWhereInput = {
    AND?: ServiceSlotWhereInput | ServiceSlotWhereInput[]
    OR?: ServiceSlotWhereInput[]
    NOT?: ServiceSlotWhereInput | ServiceSlotWhereInput[]
    id?: IntFilter<"ServiceSlot"> | number
    serviceDayId?: IntFilter<"ServiceSlot"> | number
    slotTemplateId?: IntFilter<"ServiceSlot"> | number
    fulfillmentType?: EnumFulfillmentTypeFilter<"ServiceSlot"> | $Enums.FulfillmentType
    pickupLocationId?: IntNullableFilter<"ServiceSlot"> | number | null
    slotKey?: StringFilter<"ServiceSlot"> | string
    capacityOverride?: IntNullableFilter<"ServiceSlot"> | number | null
    isClosed?: BoolFilter<"ServiceSlot"> | boolean
    createdAt?: DateTimeFilter<"ServiceSlot"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceSlot"> | Date | string
    serviceDay?: XOR<ServiceDayScalarRelationFilter, ServiceDayWhereInput>
    template?: XOR<SlotTemplateScalarRelationFilter, SlotTemplateWhereInput>
    pickupLocation?: XOR<PickupLocationNullableScalarRelationFilter, PickupLocationWhereInput> | null
    groups?: FulfillmentGroupListRelationFilter
  }

  export type ServiceSlotOrderByWithRelationInput = {
    id?: SortOrder
    serviceDayId?: SortOrder
    slotTemplateId?: SortOrder
    fulfillmentType?: SortOrder
    pickupLocationId?: SortOrderInput | SortOrder
    slotKey?: SortOrder
    capacityOverride?: SortOrderInput | SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceDay?: ServiceDayOrderByWithRelationInput
    template?: SlotTemplateOrderByWithRelationInput
    pickupLocation?: PickupLocationOrderByWithRelationInput
    groups?: FulfillmentGroupOrderByRelationAggregateInput
  }

  export type ServiceSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slotKey?: string
    AND?: ServiceSlotWhereInput | ServiceSlotWhereInput[]
    OR?: ServiceSlotWhereInput[]
    NOT?: ServiceSlotWhereInput | ServiceSlotWhereInput[]
    serviceDayId?: IntFilter<"ServiceSlot"> | number
    slotTemplateId?: IntFilter<"ServiceSlot"> | number
    fulfillmentType?: EnumFulfillmentTypeFilter<"ServiceSlot"> | $Enums.FulfillmentType
    pickupLocationId?: IntNullableFilter<"ServiceSlot"> | number | null
    capacityOverride?: IntNullableFilter<"ServiceSlot"> | number | null
    isClosed?: BoolFilter<"ServiceSlot"> | boolean
    createdAt?: DateTimeFilter<"ServiceSlot"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceSlot"> | Date | string
    serviceDay?: XOR<ServiceDayScalarRelationFilter, ServiceDayWhereInput>
    template?: XOR<SlotTemplateScalarRelationFilter, SlotTemplateWhereInput>
    pickupLocation?: XOR<PickupLocationNullableScalarRelationFilter, PickupLocationWhereInput> | null
    groups?: FulfillmentGroupListRelationFilter
  }, "id" | "slotKey">

  export type ServiceSlotOrderByWithAggregationInput = {
    id?: SortOrder
    serviceDayId?: SortOrder
    slotTemplateId?: SortOrder
    fulfillmentType?: SortOrder
    pickupLocationId?: SortOrderInput | SortOrder
    slotKey?: SortOrder
    capacityOverride?: SortOrderInput | SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceSlotCountOrderByAggregateInput
    _avg?: ServiceSlotAvgOrderByAggregateInput
    _max?: ServiceSlotMaxOrderByAggregateInput
    _min?: ServiceSlotMinOrderByAggregateInput
    _sum?: ServiceSlotSumOrderByAggregateInput
  }

  export type ServiceSlotScalarWhereWithAggregatesInput = {
    AND?: ServiceSlotScalarWhereWithAggregatesInput | ServiceSlotScalarWhereWithAggregatesInput[]
    OR?: ServiceSlotScalarWhereWithAggregatesInput[]
    NOT?: ServiceSlotScalarWhereWithAggregatesInput | ServiceSlotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceSlot"> | number
    serviceDayId?: IntWithAggregatesFilter<"ServiceSlot"> | number
    slotTemplateId?: IntWithAggregatesFilter<"ServiceSlot"> | number
    fulfillmentType?: EnumFulfillmentTypeWithAggregatesFilter<"ServiceSlot"> | $Enums.FulfillmentType
    pickupLocationId?: IntNullableWithAggregatesFilter<"ServiceSlot"> | number | null
    slotKey?: StringWithAggregatesFilter<"ServiceSlot"> | string
    capacityOverride?: IntNullableWithAggregatesFilter<"ServiceSlot"> | number | null
    isClosed?: BoolWithAggregatesFilter<"ServiceSlot"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ServiceSlot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceSlot"> | Date | string
  }

  export type DeliverySettingsWhereInput = {
    AND?: DeliverySettingsWhereInput | DeliverySettingsWhereInput[]
    OR?: DeliverySettingsWhereInput[]
    NOT?: DeliverySettingsWhereInput | DeliverySettingsWhereInput[]
    id?: IntFilter<"DeliverySettings"> | number
    originAddress?: StringFilter<"DeliverySettings"> | string
    originLat?: FloatNullableFilter<"DeliverySettings"> | number | null
    originLng?: FloatNullableFilter<"DeliverySettings"> | number | null
    maxRadiusMiles?: FloatFilter<"DeliverySettings"> | number
    feeTiers?: JsonFilter<"DeliverySettings">
    bundlePolicy?: JsonNullableFilter<"DeliverySettings">
    pricingMode?: EnumDeliveryPricingModeFilter<"DeliverySettings"> | $Enums.DeliveryPricingMode
    createdAt?: DateTimeFilter<"DeliverySettings"> | Date | string
    updatedAt?: DateTimeFilter<"DeliverySettings"> | Date | string
  }

  export type DeliverySettingsOrderByWithRelationInput = {
    id?: SortOrder
    originAddress?: SortOrder
    originLat?: SortOrderInput | SortOrder
    originLng?: SortOrderInput | SortOrder
    maxRadiusMiles?: SortOrder
    feeTiers?: SortOrder
    bundlePolicy?: SortOrderInput | SortOrder
    pricingMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliverySettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeliverySettingsWhereInput | DeliverySettingsWhereInput[]
    OR?: DeliverySettingsWhereInput[]
    NOT?: DeliverySettingsWhereInput | DeliverySettingsWhereInput[]
    originAddress?: StringFilter<"DeliverySettings"> | string
    originLat?: FloatNullableFilter<"DeliverySettings"> | number | null
    originLng?: FloatNullableFilter<"DeliverySettings"> | number | null
    maxRadiusMiles?: FloatFilter<"DeliverySettings"> | number
    feeTiers?: JsonFilter<"DeliverySettings">
    bundlePolicy?: JsonNullableFilter<"DeliverySettings">
    pricingMode?: EnumDeliveryPricingModeFilter<"DeliverySettings"> | $Enums.DeliveryPricingMode
    createdAt?: DateTimeFilter<"DeliverySettings"> | Date | string
    updatedAt?: DateTimeFilter<"DeliverySettings"> | Date | string
  }, "id">

  export type DeliverySettingsOrderByWithAggregationInput = {
    id?: SortOrder
    originAddress?: SortOrder
    originLat?: SortOrderInput | SortOrder
    originLng?: SortOrderInput | SortOrder
    maxRadiusMiles?: SortOrder
    feeTiers?: SortOrder
    bundlePolicy?: SortOrderInput | SortOrder
    pricingMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeliverySettingsCountOrderByAggregateInput
    _avg?: DeliverySettingsAvgOrderByAggregateInput
    _max?: DeliverySettingsMaxOrderByAggregateInput
    _min?: DeliverySettingsMinOrderByAggregateInput
    _sum?: DeliverySettingsSumOrderByAggregateInput
  }

  export type DeliverySettingsScalarWhereWithAggregatesInput = {
    AND?: DeliverySettingsScalarWhereWithAggregatesInput | DeliverySettingsScalarWhereWithAggregatesInput[]
    OR?: DeliverySettingsScalarWhereWithAggregatesInput[]
    NOT?: DeliverySettingsScalarWhereWithAggregatesInput | DeliverySettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeliverySettings"> | number
    originAddress?: StringWithAggregatesFilter<"DeliverySettings"> | string
    originLat?: FloatNullableWithAggregatesFilter<"DeliverySettings"> | number | null
    originLng?: FloatNullableWithAggregatesFilter<"DeliverySettings"> | number | null
    maxRadiusMiles?: FloatWithAggregatesFilter<"DeliverySettings"> | number
    feeTiers?: JsonWithAggregatesFilter<"DeliverySettings">
    bundlePolicy?: JsonNullableWithAggregatesFilter<"DeliverySettings">
    pricingMode?: EnumDeliveryPricingModeWithAggregatesFilter<"DeliverySettings"> | $Enums.DeliveryPricingMode
    createdAt?: DateTimeWithAggregatesFilter<"DeliverySettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeliverySettings"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    userId?: IntNullableFilter<"Order"> | number | null
    createdByUserId?: IntNullableFilter<"Order"> | number | null
    source?: EnumOrderSourceFilter<"Order"> | $Enums.OrderSource
    sourceRef?: StringNullableFilter<"Order"> | string | null
    currency?: StringFilter<"Order"> | string
    checkoutStatus?: EnumOrderCheckoutStatusFilter<"Order"> | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFilter<"Order"> | $Enums.DeliveryPricingMode
    fulfillmentType?: EnumFulfillmentTypeNullableFilter<"Order"> | $Enums.FulfillmentType | null
    pickupLocationId?: IntNullableFilter<"Order"> | number | null
    deliveryAddressId?: IntNullableFilter<"Order"> | number | null
    deliveryDistanceMiles?: FloatNullableFilter<"Order"> | number | null
    customerName?: StringNullableFilter<"Order"> | string | null
    customerEmail?: StringNullableFilter<"Order"> | string | null
    customerPhone?: StringNullableFilter<"Order"> | string | null
    customerNotes?: StringNullableFilter<"Order"> | string | null
    internalNotes?: StringNullableFilter<"Order"> | string | null
    subtotalCents?: IntFilter<"Order"> | number
    adjustmentsCents?: IntFilter<"Order"> | number
    totalCents?: IntFilter<"Order"> | number
    refundedCents?: IntFilter<"Order"> | number
    placedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    pickupLocation?: XOR<PickupLocationNullableScalarRelationFilter, PickupLocationWhereInput> | null
    deliveryAddress?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    groups?: FulfillmentGroupListRelationFilter
    items?: OrderItemListRelationFilter
    adjustments?: OrderAdjustmentListRelationFilter
    payments?: PaymentListRelationFilter
    events?: OrderEventListRelationFilter
    promoRedemptions?: PromotionRedemptionListRelationFilter
    capacityHolds?: CapacityHoldListRelationFilter
    rewardTransactions?: RewardTransactionListRelationFilter
    reviews?: ReviewListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    source?: SortOrder
    sourceRef?: SortOrderInput | SortOrder
    currency?: SortOrder
    checkoutStatus?: SortOrder
    deliveryPricingMode?: SortOrder
    fulfillmentType?: SortOrderInput | SortOrder
    pickupLocationId?: SortOrderInput | SortOrder
    deliveryAddressId?: SortOrderInput | SortOrder
    deliveryDistanceMiles?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    customerEmail?: SortOrderInput | SortOrder
    customerPhone?: SortOrderInput | SortOrder
    customerNotes?: SortOrderInput | SortOrder
    internalNotes?: SortOrderInput | SortOrder
    subtotalCents?: SortOrder
    adjustmentsCents?: SortOrder
    totalCents?: SortOrder
    refundedCents?: SortOrder
    placedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    pickupLocation?: PickupLocationOrderByWithRelationInput
    deliveryAddress?: AddressOrderByWithRelationInput
    groups?: FulfillmentGroupOrderByRelationAggregateInput
    items?: OrderItemOrderByRelationAggregateInput
    adjustments?: OrderAdjustmentOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    events?: OrderEventOrderByRelationAggregateInput
    promoRedemptions?: PromotionRedemptionOrderByRelationAggregateInput
    capacityHolds?: CapacityHoldOrderByRelationAggregateInput
    rewardTransactions?: RewardTransactionOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: IntNullableFilter<"Order"> | number | null
    createdByUserId?: IntNullableFilter<"Order"> | number | null
    source?: EnumOrderSourceFilter<"Order"> | $Enums.OrderSource
    sourceRef?: StringNullableFilter<"Order"> | string | null
    currency?: StringFilter<"Order"> | string
    checkoutStatus?: EnumOrderCheckoutStatusFilter<"Order"> | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFilter<"Order"> | $Enums.DeliveryPricingMode
    fulfillmentType?: EnumFulfillmentTypeNullableFilter<"Order"> | $Enums.FulfillmentType | null
    pickupLocationId?: IntNullableFilter<"Order"> | number | null
    deliveryAddressId?: IntNullableFilter<"Order"> | number | null
    deliveryDistanceMiles?: FloatNullableFilter<"Order"> | number | null
    customerName?: StringNullableFilter<"Order"> | string | null
    customerEmail?: StringNullableFilter<"Order"> | string | null
    customerPhone?: StringNullableFilter<"Order"> | string | null
    customerNotes?: StringNullableFilter<"Order"> | string | null
    internalNotes?: StringNullableFilter<"Order"> | string | null
    subtotalCents?: IntFilter<"Order"> | number
    adjustmentsCents?: IntFilter<"Order"> | number
    totalCents?: IntFilter<"Order"> | number
    refundedCents?: IntFilter<"Order"> | number
    placedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    pickupLocation?: XOR<PickupLocationNullableScalarRelationFilter, PickupLocationWhereInput> | null
    deliveryAddress?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    groups?: FulfillmentGroupListRelationFilter
    items?: OrderItemListRelationFilter
    adjustments?: OrderAdjustmentListRelationFilter
    payments?: PaymentListRelationFilter
    events?: OrderEventListRelationFilter
    promoRedemptions?: PromotionRedemptionListRelationFilter
    capacityHolds?: CapacityHoldListRelationFilter
    rewardTransactions?: RewardTransactionListRelationFilter
    reviews?: ReviewListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    source?: SortOrder
    sourceRef?: SortOrderInput | SortOrder
    currency?: SortOrder
    checkoutStatus?: SortOrder
    deliveryPricingMode?: SortOrder
    fulfillmentType?: SortOrderInput | SortOrder
    pickupLocationId?: SortOrderInput | SortOrder
    deliveryAddressId?: SortOrderInput | SortOrder
    deliveryDistanceMiles?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    customerEmail?: SortOrderInput | SortOrder
    customerPhone?: SortOrderInput | SortOrder
    customerNotes?: SortOrderInput | SortOrder
    internalNotes?: SortOrderInput | SortOrder
    subtotalCents?: SortOrder
    adjustmentsCents?: SortOrder
    totalCents?: SortOrder
    refundedCents?: SortOrder
    placedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    userId?: IntNullableWithAggregatesFilter<"Order"> | number | null
    createdByUserId?: IntNullableWithAggregatesFilter<"Order"> | number | null
    source?: EnumOrderSourceWithAggregatesFilter<"Order"> | $Enums.OrderSource
    sourceRef?: StringNullableWithAggregatesFilter<"Order"> | string | null
    currency?: StringWithAggregatesFilter<"Order"> | string
    checkoutStatus?: EnumOrderCheckoutStatusWithAggregatesFilter<"Order"> | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeWithAggregatesFilter<"Order"> | $Enums.DeliveryPricingMode
    fulfillmentType?: EnumFulfillmentTypeNullableWithAggregatesFilter<"Order"> | $Enums.FulfillmentType | null
    pickupLocationId?: IntNullableWithAggregatesFilter<"Order"> | number | null
    deliveryAddressId?: IntNullableWithAggregatesFilter<"Order"> | number | null
    deliveryDistanceMiles?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    customerName?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customerEmail?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customerPhone?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customerNotes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    internalNotes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    subtotalCents?: IntWithAggregatesFilter<"Order"> | number
    adjustmentsCents?: IntWithAggregatesFilter<"Order"> | number
    totalCents?: IntWithAggregatesFilter<"Order"> | number
    refundedCents?: IntWithAggregatesFilter<"Order"> | number
    placedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type FulfillmentGroupWhereInput = {
    AND?: FulfillmentGroupWhereInput | FulfillmentGroupWhereInput[]
    OR?: FulfillmentGroupWhereInput[]
    NOT?: FulfillmentGroupWhereInput | FulfillmentGroupWhereInput[]
    id?: IntFilter<"FulfillmentGroup"> | number
    orderId?: IntFilter<"FulfillmentGroup"> | number
    serviceDayId?: IntFilter<"FulfillmentGroup"> | number
    serviceSlotId?: IntNullableFilter<"FulfillmentGroup"> | number | null
    status?: EnumFulfillmentGroupStatusFilter<"FulfillmentGroup"> | $Enums.FulfillmentGroupStatus
    sequence?: IntFilter<"FulfillmentGroup"> | number
    createdAt?: DateTimeFilter<"FulfillmentGroup"> | Date | string
    updatedAt?: DateTimeFilter<"FulfillmentGroup"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    serviceDay?: XOR<ServiceDayScalarRelationFilter, ServiceDayWhereInput>
    serviceSlot?: XOR<ServiceSlotNullableScalarRelationFilter, ServiceSlotWhereInput> | null
    items?: OrderItemListRelationFilter
    adjustments?: OrderAdjustmentListRelationFilter
    events?: OrderEventListRelationFilter
  }

  export type FulfillmentGroupOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceDayId?: SortOrder
    serviceSlotId?: SortOrderInput | SortOrder
    status?: SortOrder
    sequence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    serviceDay?: ServiceDayOrderByWithRelationInput
    serviceSlot?: ServiceSlotOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    adjustments?: OrderAdjustmentOrderByRelationAggregateInput
    events?: OrderEventOrderByRelationAggregateInput
  }

  export type FulfillmentGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderId_serviceDayId?: FulfillmentGroupOrderIdServiceDayIdCompoundUniqueInput
    AND?: FulfillmentGroupWhereInput | FulfillmentGroupWhereInput[]
    OR?: FulfillmentGroupWhereInput[]
    NOT?: FulfillmentGroupWhereInput | FulfillmentGroupWhereInput[]
    orderId?: IntFilter<"FulfillmentGroup"> | number
    serviceDayId?: IntFilter<"FulfillmentGroup"> | number
    serviceSlotId?: IntNullableFilter<"FulfillmentGroup"> | number | null
    status?: EnumFulfillmentGroupStatusFilter<"FulfillmentGroup"> | $Enums.FulfillmentGroupStatus
    sequence?: IntFilter<"FulfillmentGroup"> | number
    createdAt?: DateTimeFilter<"FulfillmentGroup"> | Date | string
    updatedAt?: DateTimeFilter<"FulfillmentGroup"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    serviceDay?: XOR<ServiceDayScalarRelationFilter, ServiceDayWhereInput>
    serviceSlot?: XOR<ServiceSlotNullableScalarRelationFilter, ServiceSlotWhereInput> | null
    items?: OrderItemListRelationFilter
    adjustments?: OrderAdjustmentListRelationFilter
    events?: OrderEventListRelationFilter
  }, "id" | "orderId_serviceDayId">

  export type FulfillmentGroupOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceDayId?: SortOrder
    serviceSlotId?: SortOrderInput | SortOrder
    status?: SortOrder
    sequence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FulfillmentGroupCountOrderByAggregateInput
    _avg?: FulfillmentGroupAvgOrderByAggregateInput
    _max?: FulfillmentGroupMaxOrderByAggregateInput
    _min?: FulfillmentGroupMinOrderByAggregateInput
    _sum?: FulfillmentGroupSumOrderByAggregateInput
  }

  export type FulfillmentGroupScalarWhereWithAggregatesInput = {
    AND?: FulfillmentGroupScalarWhereWithAggregatesInput | FulfillmentGroupScalarWhereWithAggregatesInput[]
    OR?: FulfillmentGroupScalarWhereWithAggregatesInput[]
    NOT?: FulfillmentGroupScalarWhereWithAggregatesInput | FulfillmentGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FulfillmentGroup"> | number
    orderId?: IntWithAggregatesFilter<"FulfillmentGroup"> | number
    serviceDayId?: IntWithAggregatesFilter<"FulfillmentGroup"> | number
    serviceSlotId?: IntNullableWithAggregatesFilter<"FulfillmentGroup"> | number | null
    status?: EnumFulfillmentGroupStatusWithAggregatesFilter<"FulfillmentGroup"> | $Enums.FulfillmentGroupStatus
    sequence?: IntWithAggregatesFilter<"FulfillmentGroup"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FulfillmentGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FulfillmentGroup"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    fulfillmentGroupId?: IntFilter<"OrderItem"> | number
    menuVariantId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    unitPriceCents?: IntFilter<"OrderItem"> | number
    nameSnapshot?: StringFilter<"OrderItem"> | string
    variantLabelSnapshot?: StringFilter<"OrderItem"> | string
    imageUrlSnapshot?: StringNullableFilter<"OrderItem"> | string | null
    notes?: StringNullableFilter<"OrderItem"> | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    group?: XOR<FulfillmentGroupScalarRelationFilter, FulfillmentGroupWhereInput>
    variant?: XOR<MenuVariantScalarRelationFilter, MenuVariantWhereInput>
    addOns?: OrderItemAddOnListRelationFilter
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
    menuVariantId?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    nameSnapshot?: SortOrder
    variantLabelSnapshot?: SortOrder
    imageUrlSnapshot?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    group?: FulfillmentGroupOrderByWithRelationInput
    variant?: MenuVariantOrderByWithRelationInput
    addOns?: OrderItemAddOnOrderByRelationAggregateInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: IntFilter<"OrderItem"> | number
    fulfillmentGroupId?: IntFilter<"OrderItem"> | number
    menuVariantId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    unitPriceCents?: IntFilter<"OrderItem"> | number
    nameSnapshot?: StringFilter<"OrderItem"> | string
    variantLabelSnapshot?: StringFilter<"OrderItem"> | string
    imageUrlSnapshot?: StringNullableFilter<"OrderItem"> | string | null
    notes?: StringNullableFilter<"OrderItem"> | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    group?: XOR<FulfillmentGroupScalarRelationFilter, FulfillmentGroupWhereInput>
    variant?: XOR<MenuVariantScalarRelationFilter, MenuVariantWhereInput>
    addOns?: OrderItemAddOnListRelationFilter
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
    menuVariantId?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    nameSnapshot?: SortOrder
    variantLabelSnapshot?: SortOrder
    imageUrlSnapshot?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItem"> | number
    orderId?: IntWithAggregatesFilter<"OrderItem"> | number
    fulfillmentGroupId?: IntWithAggregatesFilter<"OrderItem"> | number
    menuVariantId?: IntWithAggregatesFilter<"OrderItem"> | number
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    unitPriceCents?: IntWithAggregatesFilter<"OrderItem"> | number
    nameSnapshot?: StringWithAggregatesFilter<"OrderItem"> | string
    variantLabelSnapshot?: StringWithAggregatesFilter<"OrderItem"> | string
    imageUrlSnapshot?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    notes?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type OrderItemAddOnWhereInput = {
    AND?: OrderItemAddOnWhereInput | OrderItemAddOnWhereInput[]
    OR?: OrderItemAddOnWhereInput[]
    NOT?: OrderItemAddOnWhereInput | OrderItemAddOnWhereInput[]
    id?: IntFilter<"OrderItemAddOn"> | number
    orderItemId?: IntFilter<"OrderItemAddOn"> | number
    addOnId?: IntNullableFilter<"OrderItemAddOn"> | number | null
    quantity?: IntFilter<"OrderItemAddOn"> | number
    unitPriceCents?: IntFilter<"OrderItemAddOn"> | number
    nameSnapshot?: StringFilter<"OrderItemAddOn"> | string
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
    addOn?: XOR<AddOnNullableScalarRelationFilter, AddOnWhereInput> | null
  }

  export type OrderItemAddOnOrderByWithRelationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    addOnId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    nameSnapshot?: SortOrder
    orderItem?: OrderItemOrderByWithRelationInput
    addOn?: AddOnOrderByWithRelationInput
  }

  export type OrderItemAddOnWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderItemAddOnWhereInput | OrderItemAddOnWhereInput[]
    OR?: OrderItemAddOnWhereInput[]
    NOT?: OrderItemAddOnWhereInput | OrderItemAddOnWhereInput[]
    orderItemId?: IntFilter<"OrderItemAddOn"> | number
    addOnId?: IntNullableFilter<"OrderItemAddOn"> | number | null
    quantity?: IntFilter<"OrderItemAddOn"> | number
    unitPriceCents?: IntFilter<"OrderItemAddOn"> | number
    nameSnapshot?: StringFilter<"OrderItemAddOn"> | string
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
    addOn?: XOR<AddOnNullableScalarRelationFilter, AddOnWhereInput> | null
  }, "id">

  export type OrderItemAddOnOrderByWithAggregationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    addOnId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    nameSnapshot?: SortOrder
    _count?: OrderItemAddOnCountOrderByAggregateInput
    _avg?: OrderItemAddOnAvgOrderByAggregateInput
    _max?: OrderItemAddOnMaxOrderByAggregateInput
    _min?: OrderItemAddOnMinOrderByAggregateInput
    _sum?: OrderItemAddOnSumOrderByAggregateInput
  }

  export type OrderItemAddOnScalarWhereWithAggregatesInput = {
    AND?: OrderItemAddOnScalarWhereWithAggregatesInput | OrderItemAddOnScalarWhereWithAggregatesInput[]
    OR?: OrderItemAddOnScalarWhereWithAggregatesInput[]
    NOT?: OrderItemAddOnScalarWhereWithAggregatesInput | OrderItemAddOnScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItemAddOn"> | number
    orderItemId?: IntWithAggregatesFilter<"OrderItemAddOn"> | number
    addOnId?: IntNullableWithAggregatesFilter<"OrderItemAddOn"> | number | null
    quantity?: IntWithAggregatesFilter<"OrderItemAddOn"> | number
    unitPriceCents?: IntWithAggregatesFilter<"OrderItemAddOn"> | number
    nameSnapshot?: StringWithAggregatesFilter<"OrderItemAddOn"> | string
  }

  export type OrderAdjustmentWhereInput = {
    AND?: OrderAdjustmentWhereInput | OrderAdjustmentWhereInput[]
    OR?: OrderAdjustmentWhereInput[]
    NOT?: OrderAdjustmentWhereInput | OrderAdjustmentWhereInput[]
    id?: IntFilter<"OrderAdjustment"> | number
    orderId?: IntFilter<"OrderAdjustment"> | number
    fulfillmentGroupId?: IntNullableFilter<"OrderAdjustment"> | number | null
    type?: EnumAdjustmentTypeFilter<"OrderAdjustment"> | $Enums.AdjustmentType
    label?: StringNullableFilter<"OrderAdjustment"> | string | null
    amountCents?: IntFilter<"OrderAdjustment"> | number
    metadata?: JsonNullableFilter<"OrderAdjustment">
    createdAt?: DateTimeFilter<"OrderAdjustment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    group?: XOR<FulfillmentGroupNullableScalarRelationFilter, FulfillmentGroupWhereInput> | null
  }

  export type OrderAdjustmentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrderInput | SortOrder
    type?: SortOrder
    label?: SortOrderInput | SortOrder
    amountCents?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    group?: FulfillmentGroupOrderByWithRelationInput
  }

  export type OrderAdjustmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderAdjustmentWhereInput | OrderAdjustmentWhereInput[]
    OR?: OrderAdjustmentWhereInput[]
    NOT?: OrderAdjustmentWhereInput | OrderAdjustmentWhereInput[]
    orderId?: IntFilter<"OrderAdjustment"> | number
    fulfillmentGroupId?: IntNullableFilter<"OrderAdjustment"> | number | null
    type?: EnumAdjustmentTypeFilter<"OrderAdjustment"> | $Enums.AdjustmentType
    label?: StringNullableFilter<"OrderAdjustment"> | string | null
    amountCents?: IntFilter<"OrderAdjustment"> | number
    metadata?: JsonNullableFilter<"OrderAdjustment">
    createdAt?: DateTimeFilter<"OrderAdjustment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    group?: XOR<FulfillmentGroupNullableScalarRelationFilter, FulfillmentGroupWhereInput> | null
  }, "id">

  export type OrderAdjustmentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrderInput | SortOrder
    type?: SortOrder
    label?: SortOrderInput | SortOrder
    amountCents?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OrderAdjustmentCountOrderByAggregateInput
    _avg?: OrderAdjustmentAvgOrderByAggregateInput
    _max?: OrderAdjustmentMaxOrderByAggregateInput
    _min?: OrderAdjustmentMinOrderByAggregateInput
    _sum?: OrderAdjustmentSumOrderByAggregateInput
  }

  export type OrderAdjustmentScalarWhereWithAggregatesInput = {
    AND?: OrderAdjustmentScalarWhereWithAggregatesInput | OrderAdjustmentScalarWhereWithAggregatesInput[]
    OR?: OrderAdjustmentScalarWhereWithAggregatesInput[]
    NOT?: OrderAdjustmentScalarWhereWithAggregatesInput | OrderAdjustmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderAdjustment"> | number
    orderId?: IntWithAggregatesFilter<"OrderAdjustment"> | number
    fulfillmentGroupId?: IntNullableWithAggregatesFilter<"OrderAdjustment"> | number | null
    type?: EnumAdjustmentTypeWithAggregatesFilter<"OrderAdjustment"> | $Enums.AdjustmentType
    label?: StringNullableWithAggregatesFilter<"OrderAdjustment"> | string | null
    amountCents?: IntWithAggregatesFilter<"OrderAdjustment"> | number
    metadata?: JsonNullableWithAggregatesFilter<"OrderAdjustment">
    createdAt?: DateTimeWithAggregatesFilter<"OrderAdjustment"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    orderId?: IntFilter<"Payment"> | number
    provider?: EnumPaymentProviderFilter<"Payment"> | $Enums.PaymentProvider
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amountCents?: IntFilter<"Payment"> | number
    providerRef?: StringNullableFilter<"Payment"> | string | null
    receivedByUserId?: IntNullableFilter<"Payment"> | number | null
    receivedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    receivedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    method?: SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    providerRef?: SortOrderInput | SortOrder
    receivedByUserId?: SortOrderInput | SortOrder
    receivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    receivedBy?: UserOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    orderId?: IntFilter<"Payment"> | number
    provider?: EnumPaymentProviderFilter<"Payment"> | $Enums.PaymentProvider
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amountCents?: IntFilter<"Payment"> | number
    providerRef?: StringNullableFilter<"Payment"> | string | null
    receivedByUserId?: IntNullableFilter<"Payment"> | number | null
    receivedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    receivedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    method?: SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    providerRef?: SortOrderInput | SortOrder
    receivedByUserId?: SortOrderInput | SortOrder
    receivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    orderId?: IntWithAggregatesFilter<"Payment"> | number
    provider?: EnumPaymentProviderWithAggregatesFilter<"Payment"> | $Enums.PaymentProvider
    method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    amountCents?: IntWithAggregatesFilter<"Payment"> | number
    providerRef?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    receivedByUserId?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    receivedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type OrderEventWhereInput = {
    AND?: OrderEventWhereInput | OrderEventWhereInput[]
    OR?: OrderEventWhereInput[]
    NOT?: OrderEventWhereInput | OrderEventWhereInput[]
    id?: IntFilter<"OrderEvent"> | number
    orderId?: IntFilter<"OrderEvent"> | number
    fulfillmentGroupId?: IntNullableFilter<"OrderEvent"> | number | null
    type?: StringFilter<"OrderEvent"> | string
    payload?: JsonNullableFilter<"OrderEvent">
    createdAt?: DateTimeFilter<"OrderEvent"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    group?: XOR<FulfillmentGroupNullableScalarRelationFilter, FulfillmentGroupWhereInput> | null
  }

  export type OrderEventOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrderInput | SortOrder
    type?: SortOrder
    payload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    group?: FulfillmentGroupOrderByWithRelationInput
  }

  export type OrderEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderEventWhereInput | OrderEventWhereInput[]
    OR?: OrderEventWhereInput[]
    NOT?: OrderEventWhereInput | OrderEventWhereInput[]
    orderId?: IntFilter<"OrderEvent"> | number
    fulfillmentGroupId?: IntNullableFilter<"OrderEvent"> | number | null
    type?: StringFilter<"OrderEvent"> | string
    payload?: JsonNullableFilter<"OrderEvent">
    createdAt?: DateTimeFilter<"OrderEvent"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    group?: XOR<FulfillmentGroupNullableScalarRelationFilter, FulfillmentGroupWhereInput> | null
  }, "id">

  export type OrderEventOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrderInput | SortOrder
    type?: SortOrder
    payload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OrderEventCountOrderByAggregateInput
    _avg?: OrderEventAvgOrderByAggregateInput
    _max?: OrderEventMaxOrderByAggregateInput
    _min?: OrderEventMinOrderByAggregateInput
    _sum?: OrderEventSumOrderByAggregateInput
  }

  export type OrderEventScalarWhereWithAggregatesInput = {
    AND?: OrderEventScalarWhereWithAggregatesInput | OrderEventScalarWhereWithAggregatesInput[]
    OR?: OrderEventScalarWhereWithAggregatesInput[]
    NOT?: OrderEventScalarWhereWithAggregatesInput | OrderEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderEvent"> | number
    orderId?: IntWithAggregatesFilter<"OrderEvent"> | number
    fulfillmentGroupId?: IntNullableWithAggregatesFilter<"OrderEvent"> | number | null
    type?: StringWithAggregatesFilter<"OrderEvent"> | string
    payload?: JsonNullableWithAggregatesFilter<"OrderEvent">
    createdAt?: DateTimeWithAggregatesFilter<"OrderEvent"> | Date | string
  }

  export type CapacityHoldWhereInput = {
    AND?: CapacityHoldWhereInput | CapacityHoldWhereInput[]
    OR?: CapacityHoldWhereInput[]
    NOT?: CapacityHoldWhereInput | CapacityHoldWhereInput[]
    id?: IntFilter<"CapacityHold"> | number
    menuOfferingId?: IntFilter<"CapacityHold"> | number
    orderId?: IntNullableFilter<"CapacityHold"> | number | null
    quantity?: IntFilter<"CapacityHold"> | number
    status?: EnumHoldStatusFilter<"CapacityHold"> | $Enums.HoldStatus
    expiresAt?: DateTimeFilter<"CapacityHold"> | Date | string
    createdAt?: DateTimeFilter<"CapacityHold"> | Date | string
    offering?: XOR<MenuOfferingScalarRelationFilter, MenuOfferingWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }

  export type CapacityHoldOrderByWithRelationInput = {
    id?: SortOrder
    menuOfferingId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    offering?: MenuOfferingOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type CapacityHoldWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CapacityHoldWhereInput | CapacityHoldWhereInput[]
    OR?: CapacityHoldWhereInput[]
    NOT?: CapacityHoldWhereInput | CapacityHoldWhereInput[]
    menuOfferingId?: IntFilter<"CapacityHold"> | number
    orderId?: IntNullableFilter<"CapacityHold"> | number | null
    quantity?: IntFilter<"CapacityHold"> | number
    status?: EnumHoldStatusFilter<"CapacityHold"> | $Enums.HoldStatus
    expiresAt?: DateTimeFilter<"CapacityHold"> | Date | string
    createdAt?: DateTimeFilter<"CapacityHold"> | Date | string
    offering?: XOR<MenuOfferingScalarRelationFilter, MenuOfferingWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }, "id">

  export type CapacityHoldOrderByWithAggregationInput = {
    id?: SortOrder
    menuOfferingId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: CapacityHoldCountOrderByAggregateInput
    _avg?: CapacityHoldAvgOrderByAggregateInput
    _max?: CapacityHoldMaxOrderByAggregateInput
    _min?: CapacityHoldMinOrderByAggregateInput
    _sum?: CapacityHoldSumOrderByAggregateInput
  }

  export type CapacityHoldScalarWhereWithAggregatesInput = {
    AND?: CapacityHoldScalarWhereWithAggregatesInput | CapacityHoldScalarWhereWithAggregatesInput[]
    OR?: CapacityHoldScalarWhereWithAggregatesInput[]
    NOT?: CapacityHoldScalarWhereWithAggregatesInput | CapacityHoldScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CapacityHold"> | number
    menuOfferingId?: IntWithAggregatesFilter<"CapacityHold"> | number
    orderId?: IntNullableWithAggregatesFilter<"CapacityHold"> | number | null
    quantity?: IntWithAggregatesFilter<"CapacityHold"> | number
    status?: EnumHoldStatusWithAggregatesFilter<"CapacityHold"> | $Enums.HoldStatus
    expiresAt?: DateTimeWithAggregatesFilter<"CapacityHold"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"CapacityHold"> | Date | string
  }

  export type PromotionWhereInput = {
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    id?: IntFilter<"Promotion"> | number
    code?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    type?: EnumPromotionTypeFilter<"Promotion"> | $Enums.PromotionType
    amountCents?: IntNullableFilter<"Promotion"> | number | null
    percentBps?: IntNullableFilter<"Promotion"> | number | null
    minSubtotalCents?: IntNullableFilter<"Promotion"> | number | null
    maxRedemptions?: IntNullableFilter<"Promotion"> | number | null
    perUserLimit?: IntNullableFilter<"Promotion"> | number | null
    startsAt?: DateTimeFilter<"Promotion"> | Date | string
    endsAt?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    isActive?: BoolFilter<"Promotion"> | boolean
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    redemptions?: PromotionRedemptionListRelationFilter
  }

  export type PromotionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    amountCents?: SortOrderInput | SortOrder
    percentBps?: SortOrderInput | SortOrder
    minSubtotalCents?: SortOrderInput | SortOrder
    maxRedemptions?: SortOrderInput | SortOrder
    perUserLimit?: SortOrderInput | SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    redemptions?: PromotionRedemptionOrderByRelationAggregateInput
  }

  export type PromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    description?: StringNullableFilter<"Promotion"> | string | null
    type?: EnumPromotionTypeFilter<"Promotion"> | $Enums.PromotionType
    amountCents?: IntNullableFilter<"Promotion"> | number | null
    percentBps?: IntNullableFilter<"Promotion"> | number | null
    minSubtotalCents?: IntNullableFilter<"Promotion"> | number | null
    maxRedemptions?: IntNullableFilter<"Promotion"> | number | null
    perUserLimit?: IntNullableFilter<"Promotion"> | number | null
    startsAt?: DateTimeFilter<"Promotion"> | Date | string
    endsAt?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    isActive?: BoolFilter<"Promotion"> | boolean
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    redemptions?: PromotionRedemptionListRelationFilter
  }, "id" | "code">

  export type PromotionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    amountCents?: SortOrderInput | SortOrder
    percentBps?: SortOrderInput | SortOrder
    minSubtotalCents?: SortOrderInput | SortOrder
    maxRedemptions?: SortOrderInput | SortOrder
    perUserLimit?: SortOrderInput | SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromotionCountOrderByAggregateInput
    _avg?: PromotionAvgOrderByAggregateInput
    _max?: PromotionMaxOrderByAggregateInput
    _min?: PromotionMinOrderByAggregateInput
    _sum?: PromotionSumOrderByAggregateInput
  }

  export type PromotionScalarWhereWithAggregatesInput = {
    AND?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    OR?: PromotionScalarWhereWithAggregatesInput[]
    NOT?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Promotion"> | number
    code?: StringWithAggregatesFilter<"Promotion"> | string
    description?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    type?: EnumPromotionTypeWithAggregatesFilter<"Promotion"> | $Enums.PromotionType
    amountCents?: IntNullableWithAggregatesFilter<"Promotion"> | number | null
    percentBps?: IntNullableWithAggregatesFilter<"Promotion"> | number | null
    minSubtotalCents?: IntNullableWithAggregatesFilter<"Promotion"> | number | null
    maxRedemptions?: IntNullableWithAggregatesFilter<"Promotion"> | number | null
    perUserLimit?: IntNullableWithAggregatesFilter<"Promotion"> | number | null
    startsAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    endsAt?: DateTimeNullableWithAggregatesFilter<"Promotion"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Promotion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
  }

  export type PromotionRedemptionWhereInput = {
    AND?: PromotionRedemptionWhereInput | PromotionRedemptionWhereInput[]
    OR?: PromotionRedemptionWhereInput[]
    NOT?: PromotionRedemptionWhereInput | PromotionRedemptionWhereInput[]
    id?: IntFilter<"PromotionRedemption"> | number
    promotionId?: IntFilter<"PromotionRedemption"> | number
    orderId?: IntFilter<"PromotionRedemption"> | number
    userId?: IntNullableFilter<"PromotionRedemption"> | number | null
    discountCentsApplied?: IntFilter<"PromotionRedemption"> | number
    createdAt?: DateTimeFilter<"PromotionRedemption"> | Date | string
    promotion?: XOR<PromotionScalarRelationFilter, PromotionWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PromotionRedemptionOrderByWithRelationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrderInput | SortOrder
    discountCentsApplied?: SortOrder
    createdAt?: SortOrder
    promotion?: PromotionOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PromotionRedemptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    promotionId_orderId?: PromotionRedemptionPromotionIdOrderIdCompoundUniqueInput
    AND?: PromotionRedemptionWhereInput | PromotionRedemptionWhereInput[]
    OR?: PromotionRedemptionWhereInput[]
    NOT?: PromotionRedemptionWhereInput | PromotionRedemptionWhereInput[]
    promotionId?: IntFilter<"PromotionRedemption"> | number
    orderId?: IntFilter<"PromotionRedemption"> | number
    userId?: IntNullableFilter<"PromotionRedemption"> | number | null
    discountCentsApplied?: IntFilter<"PromotionRedemption"> | number
    createdAt?: DateTimeFilter<"PromotionRedemption"> | Date | string
    promotion?: XOR<PromotionScalarRelationFilter, PromotionWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "promotionId_orderId">

  export type PromotionRedemptionOrderByWithAggregationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrderInput | SortOrder
    discountCentsApplied?: SortOrder
    createdAt?: SortOrder
    _count?: PromotionRedemptionCountOrderByAggregateInput
    _avg?: PromotionRedemptionAvgOrderByAggregateInput
    _max?: PromotionRedemptionMaxOrderByAggregateInput
    _min?: PromotionRedemptionMinOrderByAggregateInput
    _sum?: PromotionRedemptionSumOrderByAggregateInput
  }

  export type PromotionRedemptionScalarWhereWithAggregatesInput = {
    AND?: PromotionRedemptionScalarWhereWithAggregatesInput | PromotionRedemptionScalarWhereWithAggregatesInput[]
    OR?: PromotionRedemptionScalarWhereWithAggregatesInput[]
    NOT?: PromotionRedemptionScalarWhereWithAggregatesInput | PromotionRedemptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PromotionRedemption"> | number
    promotionId?: IntWithAggregatesFilter<"PromotionRedemption"> | number
    orderId?: IntWithAggregatesFilter<"PromotionRedemption"> | number
    userId?: IntNullableWithAggregatesFilter<"PromotionRedemption"> | number | null
    discountCentsApplied?: IntWithAggregatesFilter<"PromotionRedemption"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PromotionRedemption"> | Date | string
  }

  export type RewardAccountWhereInput = {
    AND?: RewardAccountWhereInput | RewardAccountWhereInput[]
    OR?: RewardAccountWhereInput[]
    NOT?: RewardAccountWhereInput | RewardAccountWhereInput[]
    id?: IntFilter<"RewardAccount"> | number
    userId?: IntFilter<"RewardAccount"> | number
    balancePoints?: IntFilter<"RewardAccount"> | number
    createdAt?: DateTimeFilter<"RewardAccount"> | Date | string
    updatedAt?: DateTimeFilter<"RewardAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    txns?: RewardTransactionListRelationFilter
  }

  export type RewardAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    balancePoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    txns?: RewardTransactionOrderByRelationAggregateInput
  }

  export type RewardAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: RewardAccountWhereInput | RewardAccountWhereInput[]
    OR?: RewardAccountWhereInput[]
    NOT?: RewardAccountWhereInput | RewardAccountWhereInput[]
    balancePoints?: IntFilter<"RewardAccount"> | number
    createdAt?: DateTimeFilter<"RewardAccount"> | Date | string
    updatedAt?: DateTimeFilter<"RewardAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    txns?: RewardTransactionListRelationFilter
  }, "id" | "userId">

  export type RewardAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    balancePoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RewardAccountCountOrderByAggregateInput
    _avg?: RewardAccountAvgOrderByAggregateInput
    _max?: RewardAccountMaxOrderByAggregateInput
    _min?: RewardAccountMinOrderByAggregateInput
    _sum?: RewardAccountSumOrderByAggregateInput
  }

  export type RewardAccountScalarWhereWithAggregatesInput = {
    AND?: RewardAccountScalarWhereWithAggregatesInput | RewardAccountScalarWhereWithAggregatesInput[]
    OR?: RewardAccountScalarWhereWithAggregatesInput[]
    NOT?: RewardAccountScalarWhereWithAggregatesInput | RewardAccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RewardAccount"> | number
    userId?: IntWithAggregatesFilter<"RewardAccount"> | number
    balancePoints?: IntWithAggregatesFilter<"RewardAccount"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RewardAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RewardAccount"> | Date | string
  }

  export type RewardTransactionWhereInput = {
    AND?: RewardTransactionWhereInput | RewardTransactionWhereInput[]
    OR?: RewardTransactionWhereInput[]
    NOT?: RewardTransactionWhereInput | RewardTransactionWhereInput[]
    id?: IntFilter<"RewardTransaction"> | number
    rewardAccountId?: IntFilter<"RewardTransaction"> | number
    type?: EnumRewardTxnTypeFilter<"RewardTransaction"> | $Enums.RewardTxnType
    amountPoints?: IntFilter<"RewardTransaction"> | number
    orderId?: IntNullableFilter<"RewardTransaction"> | number | null
    note?: StringNullableFilter<"RewardTransaction"> | string | null
    createdAt?: DateTimeFilter<"RewardTransaction"> | Date | string
    account?: XOR<RewardAccountScalarRelationFilter, RewardAccountWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }

  export type RewardTransactionOrderByWithRelationInput = {
    id?: SortOrder
    rewardAccountId?: SortOrder
    type?: SortOrder
    amountPoints?: SortOrder
    orderId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    account?: RewardAccountOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type RewardTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RewardTransactionWhereInput | RewardTransactionWhereInput[]
    OR?: RewardTransactionWhereInput[]
    NOT?: RewardTransactionWhereInput | RewardTransactionWhereInput[]
    rewardAccountId?: IntFilter<"RewardTransaction"> | number
    type?: EnumRewardTxnTypeFilter<"RewardTransaction"> | $Enums.RewardTxnType
    amountPoints?: IntFilter<"RewardTransaction"> | number
    orderId?: IntNullableFilter<"RewardTransaction"> | number | null
    note?: StringNullableFilter<"RewardTransaction"> | string | null
    createdAt?: DateTimeFilter<"RewardTransaction"> | Date | string
    account?: XOR<RewardAccountScalarRelationFilter, RewardAccountWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }, "id">

  export type RewardTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    rewardAccountId?: SortOrder
    type?: SortOrder
    amountPoints?: SortOrder
    orderId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RewardTransactionCountOrderByAggregateInput
    _avg?: RewardTransactionAvgOrderByAggregateInput
    _max?: RewardTransactionMaxOrderByAggregateInput
    _min?: RewardTransactionMinOrderByAggregateInput
    _sum?: RewardTransactionSumOrderByAggregateInput
  }

  export type RewardTransactionScalarWhereWithAggregatesInput = {
    AND?: RewardTransactionScalarWhereWithAggregatesInput | RewardTransactionScalarWhereWithAggregatesInput[]
    OR?: RewardTransactionScalarWhereWithAggregatesInput[]
    NOT?: RewardTransactionScalarWhereWithAggregatesInput | RewardTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RewardTransaction"> | number
    rewardAccountId?: IntWithAggregatesFilter<"RewardTransaction"> | number
    type?: EnumRewardTxnTypeWithAggregatesFilter<"RewardTransaction"> | $Enums.RewardTxnType
    amountPoints?: IntWithAggregatesFilter<"RewardTransaction"> | number
    orderId?: IntNullableWithAggregatesFilter<"RewardTransaction"> | number | null
    note?: StringNullableWithAggregatesFilter<"RewardTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RewardTransaction"> | Date | string
  }

  export type CateringOrderWhereInput = {
    AND?: CateringOrderWhereInput | CateringOrderWhereInput[]
    OR?: CateringOrderWhereInput[]
    NOT?: CateringOrderWhereInput | CateringOrderWhereInput[]
    id?: IntFilter<"CateringOrder"> | number
    userId?: IntNullableFilter<"CateringOrder"> | number | null
    createdByUserId?: IntNullableFilter<"CateringOrder"> | number | null
    source?: EnumOrderSourceFilter<"CateringOrder"> | $Enums.OrderSource
    sourceRef?: StringNullableFilter<"CateringOrder"> | string | null
    status?: EnumCateringStatusFilter<"CateringOrder"> | $Enums.CateringStatus
    eventDate?: DateTimeFilter<"CateringOrder"> | Date | string
    guestCount?: IntFilter<"CateringOrder"> | number
    customerName?: StringNullableFilter<"CateringOrder"> | string | null
    customerEmail?: StringNullableFilter<"CateringOrder"> | string | null
    customerPhone?: StringNullableFilter<"CateringOrder"> | string | null
    notes?: StringNullableFilter<"CateringOrder"> | string | null
    totalCents?: IntFilter<"CateringOrder"> | number
    createdAt?: DateTimeFilter<"CateringOrder"> | Date | string
    updatedAt?: DateTimeFilter<"CateringOrder"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: CateringItemListRelationFilter
  }

  export type CateringOrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    source?: SortOrder
    sourceRef?: SortOrderInput | SortOrder
    status?: SortOrder
    eventDate?: SortOrder
    guestCount?: SortOrder
    customerName?: SortOrderInput | SortOrder
    customerEmail?: SortOrderInput | SortOrder
    customerPhone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    totalCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    items?: CateringItemOrderByRelationAggregateInput
  }

  export type CateringOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CateringOrderWhereInput | CateringOrderWhereInput[]
    OR?: CateringOrderWhereInput[]
    NOT?: CateringOrderWhereInput | CateringOrderWhereInput[]
    userId?: IntNullableFilter<"CateringOrder"> | number | null
    createdByUserId?: IntNullableFilter<"CateringOrder"> | number | null
    source?: EnumOrderSourceFilter<"CateringOrder"> | $Enums.OrderSource
    sourceRef?: StringNullableFilter<"CateringOrder"> | string | null
    status?: EnumCateringStatusFilter<"CateringOrder"> | $Enums.CateringStatus
    eventDate?: DateTimeFilter<"CateringOrder"> | Date | string
    guestCount?: IntFilter<"CateringOrder"> | number
    customerName?: StringNullableFilter<"CateringOrder"> | string | null
    customerEmail?: StringNullableFilter<"CateringOrder"> | string | null
    customerPhone?: StringNullableFilter<"CateringOrder"> | string | null
    notes?: StringNullableFilter<"CateringOrder"> | string | null
    totalCents?: IntFilter<"CateringOrder"> | number
    createdAt?: DateTimeFilter<"CateringOrder"> | Date | string
    updatedAt?: DateTimeFilter<"CateringOrder"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: CateringItemListRelationFilter
  }, "id">

  export type CateringOrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    source?: SortOrder
    sourceRef?: SortOrderInput | SortOrder
    status?: SortOrder
    eventDate?: SortOrder
    guestCount?: SortOrder
    customerName?: SortOrderInput | SortOrder
    customerEmail?: SortOrderInput | SortOrder
    customerPhone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    totalCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CateringOrderCountOrderByAggregateInput
    _avg?: CateringOrderAvgOrderByAggregateInput
    _max?: CateringOrderMaxOrderByAggregateInput
    _min?: CateringOrderMinOrderByAggregateInput
    _sum?: CateringOrderSumOrderByAggregateInput
  }

  export type CateringOrderScalarWhereWithAggregatesInput = {
    AND?: CateringOrderScalarWhereWithAggregatesInput | CateringOrderScalarWhereWithAggregatesInput[]
    OR?: CateringOrderScalarWhereWithAggregatesInput[]
    NOT?: CateringOrderScalarWhereWithAggregatesInput | CateringOrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CateringOrder"> | number
    userId?: IntNullableWithAggregatesFilter<"CateringOrder"> | number | null
    createdByUserId?: IntNullableWithAggregatesFilter<"CateringOrder"> | number | null
    source?: EnumOrderSourceWithAggregatesFilter<"CateringOrder"> | $Enums.OrderSource
    sourceRef?: StringNullableWithAggregatesFilter<"CateringOrder"> | string | null
    status?: EnumCateringStatusWithAggregatesFilter<"CateringOrder"> | $Enums.CateringStatus
    eventDate?: DateTimeWithAggregatesFilter<"CateringOrder"> | Date | string
    guestCount?: IntWithAggregatesFilter<"CateringOrder"> | number
    customerName?: StringNullableWithAggregatesFilter<"CateringOrder"> | string | null
    customerEmail?: StringNullableWithAggregatesFilter<"CateringOrder"> | string | null
    customerPhone?: StringNullableWithAggregatesFilter<"CateringOrder"> | string | null
    notes?: StringNullableWithAggregatesFilter<"CateringOrder"> | string | null
    totalCents?: IntWithAggregatesFilter<"CateringOrder"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CateringOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CateringOrder"> | Date | string
  }

  export type CateringItemWhereInput = {
    AND?: CateringItemWhereInput | CateringItemWhereInput[]
    OR?: CateringItemWhereInput[]
    NOT?: CateringItemWhereInput | CateringItemWhereInput[]
    id?: IntFilter<"CateringItem"> | number
    cateringOrderId?: IntFilter<"CateringItem"> | number
    menuItemId?: IntNullableFilter<"CateringItem"> | number | null
    nameSnapshot?: StringFilter<"CateringItem"> | string
    quantity?: IntFilter<"CateringItem"> | number
    unitPriceCents?: IntFilter<"CateringItem"> | number
    cateringOrder?: XOR<CateringOrderScalarRelationFilter, CateringOrderWhereInput>
    menuItem?: XOR<MenuItemNullableScalarRelationFilter, MenuItemWhereInput> | null
  }

  export type CateringItemOrderByWithRelationInput = {
    id?: SortOrder
    cateringOrderId?: SortOrder
    menuItemId?: SortOrderInput | SortOrder
    nameSnapshot?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    cateringOrder?: CateringOrderOrderByWithRelationInput
    menuItem?: MenuItemOrderByWithRelationInput
  }

  export type CateringItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CateringItemWhereInput | CateringItemWhereInput[]
    OR?: CateringItemWhereInput[]
    NOT?: CateringItemWhereInput | CateringItemWhereInput[]
    cateringOrderId?: IntFilter<"CateringItem"> | number
    menuItemId?: IntNullableFilter<"CateringItem"> | number | null
    nameSnapshot?: StringFilter<"CateringItem"> | string
    quantity?: IntFilter<"CateringItem"> | number
    unitPriceCents?: IntFilter<"CateringItem"> | number
    cateringOrder?: XOR<CateringOrderScalarRelationFilter, CateringOrderWhereInput>
    menuItem?: XOR<MenuItemNullableScalarRelationFilter, MenuItemWhereInput> | null
  }, "id">

  export type CateringItemOrderByWithAggregationInput = {
    id?: SortOrder
    cateringOrderId?: SortOrder
    menuItemId?: SortOrderInput | SortOrder
    nameSnapshot?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    _count?: CateringItemCountOrderByAggregateInput
    _avg?: CateringItemAvgOrderByAggregateInput
    _max?: CateringItemMaxOrderByAggregateInput
    _min?: CateringItemMinOrderByAggregateInput
    _sum?: CateringItemSumOrderByAggregateInput
  }

  export type CateringItemScalarWhereWithAggregatesInput = {
    AND?: CateringItemScalarWhereWithAggregatesInput | CateringItemScalarWhereWithAggregatesInput[]
    OR?: CateringItemScalarWhereWithAggregatesInput[]
    NOT?: CateringItemScalarWhereWithAggregatesInput | CateringItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CateringItem"> | number
    cateringOrderId?: IntWithAggregatesFilter<"CateringItem"> | number
    menuItemId?: IntNullableWithAggregatesFilter<"CateringItem"> | number | null
    nameSnapshot?: StringWithAggregatesFilter<"CateringItem"> | string
    quantity?: IntWithAggregatesFilter<"CateringItem"> | number
    unitPriceCents?: IntWithAggregatesFilter<"CateringItem"> | number
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: IntFilter<"Review"> | number
    userId?: IntFilter<"Review"> | number
    orderId?: IntNullableFilter<"Review"> | number | null
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    userId?: IntFilter<"Review"> | number
    orderId?: IntNullableFilter<"Review"> | number | null
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Review"> | number
    userId?: IntWithAggregatesFilter<"Review"> | number
    orderId?: IntNullableWithAggregatesFilter<"Review"> | number | null
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    cateringOrders?: CateringOrderCreateNestedManyWithoutUserInput
    createdCateringOrders?: CateringOrderCreateNestedManyWithoutCreatedByInput
    rewardAccount?: RewardAccountCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    promotionRedemptions?: PromotionRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    cateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutUserInput
    createdCateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutCreatedByInput
    rewardAccount?: RewardAccountUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    promotionRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    cateringOrders?: CateringOrderUpdateManyWithoutUserNestedInput
    createdCateringOrders?: CateringOrderUpdateManyWithoutCreatedByNestedInput
    rewardAccount?: RewardAccountUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    cateringOrders?: CateringOrderUncheckedUpdateManyWithoutUserNestedInput
    createdCateringOrders?: CateringOrderUncheckedUpdateManyWithoutCreatedByNestedInput
    rewardAccount?: RewardAccountUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    name: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MenuItemCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MenuItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MenuItemUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MenuItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemCreateInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutItemsInput
    variants?: MenuVariantCreateNestedManyWithoutMenuItemInput
    addOnLinks?: MenuItemAddOnCreateNestedManyWithoutMenuItemInput
    cateringItems?: CateringItemCreateNestedManyWithoutMenuItemInput
  }

  export type MenuItemUncheckedCreateInput = {
    id?: number
    categoryId?: number | null
    name: string
    description?: string | null
    imageUrl?: string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: MenuVariantUncheckedCreateNestedManyWithoutMenuItemInput
    addOnLinks?: MenuItemAddOnUncheckedCreateNestedManyWithoutMenuItemInput
    cateringItems?: CateringItemUncheckedCreateNestedManyWithoutMenuItemInput
  }

  export type MenuItemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutItemsNestedInput
    variants?: MenuVariantUpdateManyWithoutMenuItemNestedInput
    addOnLinks?: MenuItemAddOnUpdateManyWithoutMenuItemNestedInput
    cateringItems?: CateringItemUpdateManyWithoutMenuItemNestedInput
  }

  export type MenuItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: MenuVariantUncheckedUpdateManyWithoutMenuItemNestedInput
    addOnLinks?: MenuItemAddOnUncheckedUpdateManyWithoutMenuItemNestedInput
    cateringItems?: CateringItemUncheckedUpdateManyWithoutMenuItemNestedInput
  }

  export type MenuItemCreateManyInput = {
    id?: number
    categoryId?: number | null
    name: string
    description?: string | null
    imageUrl?: string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuVariantCreateInput = {
    label: string
    basePriceCents: number
    baseCapacity?: number | null
    isActive?: boolean
    prepMinutes?: number | null
    packagingCostCents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menuItem: MenuItemCreateNestedOneWithoutVariantsInput
    offerings?: MenuOfferingCreateNestedManyWithoutVariantInput
    orderItems?: OrderItemCreateNestedManyWithoutVariantInput
  }

  export type MenuVariantUncheckedCreateInput = {
    id?: number
    menuItemId: number
    label: string
    basePriceCents: number
    baseCapacity?: number | null
    isActive?: boolean
    prepMinutes?: number | null
    packagingCostCents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offerings?: MenuOfferingUncheckedCreateNestedManyWithoutVariantInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutVariantInput
  }

  export type MenuVariantUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    basePriceCents?: IntFieldUpdateOperationsInput | number
    baseCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prepMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    packagingCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuItem?: MenuItemUpdateOneRequiredWithoutVariantsNestedInput
    offerings?: MenuOfferingUpdateManyWithoutVariantNestedInput
    orderItems?: OrderItemUpdateManyWithoutVariantNestedInput
  }

  export type MenuVariantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuItemId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    basePriceCents?: IntFieldUpdateOperationsInput | number
    baseCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prepMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    packagingCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: MenuOfferingUncheckedUpdateManyWithoutVariantNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type MenuVariantCreateManyInput = {
    id?: number
    menuItemId: number
    label: string
    basePriceCents: number
    baseCapacity?: number | null
    isActive?: boolean
    prepMinutes?: number | null
    packagingCostCents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuVariantUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    basePriceCents?: IntFieldUpdateOperationsInput | number
    baseCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prepMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    packagingCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuVariantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuItemId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    basePriceCents?: IntFieldUpdateOperationsInput | number
    baseCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prepMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    packagingCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddOnCreateInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    priceCents: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    itemLinks?: MenuItemAddOnCreateNestedManyWithoutAddOnInput
    orderLinks?: OrderItemAddOnCreateNestedManyWithoutAddOnInput
  }

  export type AddOnUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    priceCents: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    itemLinks?: MenuItemAddOnUncheckedCreateNestedManyWithoutAddOnInput
    orderLinks?: OrderItemAddOnUncheckedCreateNestedManyWithoutAddOnInput
  }

  export type AddOnUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemLinks?: MenuItemAddOnUpdateManyWithoutAddOnNestedInput
    orderLinks?: OrderItemAddOnUpdateManyWithoutAddOnNestedInput
  }

  export type AddOnUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemLinks?: MenuItemAddOnUncheckedUpdateManyWithoutAddOnNestedInput
    orderLinks?: OrderItemAddOnUncheckedUpdateManyWithoutAddOnNestedInput
  }

  export type AddOnCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    priceCents: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddOnUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddOnUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemAddOnCreateInput = {
    maxQtyPerItem?: number | null
    menuItem: MenuItemCreateNestedOneWithoutAddOnLinksInput
    addOn: AddOnCreateNestedOneWithoutItemLinksInput
  }

  export type MenuItemAddOnUncheckedCreateInput = {
    menuItemId: number
    addOnId: number
    maxQtyPerItem?: number | null
  }

  export type MenuItemAddOnUpdateInput = {
    maxQtyPerItem?: NullableIntFieldUpdateOperationsInput | number | null
    menuItem?: MenuItemUpdateOneRequiredWithoutAddOnLinksNestedInput
    addOn?: AddOnUpdateOneRequiredWithoutItemLinksNestedInput
  }

  export type MenuItemAddOnUncheckedUpdateInput = {
    menuItemId?: IntFieldUpdateOperationsInput | number
    addOnId?: IntFieldUpdateOperationsInput | number
    maxQtyPerItem?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MenuItemAddOnCreateManyInput = {
    menuItemId: number
    addOnId: number
    maxQtyPerItem?: number | null
  }

  export type MenuItemAddOnUpdateManyMutationInput = {
    maxQtyPerItem?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MenuItemAddOnUncheckedUpdateManyInput = {
    menuItemId?: IntFieldUpdateOperationsInput | number
    addOnId?: IntFieldUpdateOperationsInput | number
    maxQtyPerItem?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServiceDayCreateInput = {
    menuDate: Date | string
    serviceDate: Date | string
    label?: string | null
    isPublished?: boolean
    isClosed?: boolean
    closedReason?: string | null
    orderingCutoffAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menus?: MenuCreateNestedManyWithoutServiceDayInput
    slots?: ServiceSlotCreateNestedManyWithoutServiceDayInput
    groups?: FulfillmentGroupCreateNestedManyWithoutServiceDayInput
  }

  export type ServiceDayUncheckedCreateInput = {
    id?: number
    menuDate: Date | string
    serviceDate: Date | string
    label?: string | null
    isPublished?: boolean
    isClosed?: boolean
    closedReason?: string | null
    orderingCutoffAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menus?: MenuUncheckedCreateNestedManyWithoutServiceDayInput
    slots?: ServiceSlotUncheckedCreateNestedManyWithoutServiceDayInput
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutServiceDayInput
  }

  export type ServiceDayUpdateInput = {
    menuDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    orderingCutoffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menus?: MenuUpdateManyWithoutServiceDayNestedInput
    slots?: ServiceSlotUpdateManyWithoutServiceDayNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutServiceDayNestedInput
  }

  export type ServiceDayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    orderingCutoffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menus?: MenuUncheckedUpdateManyWithoutServiceDayNestedInput
    slots?: ServiceSlotUncheckedUpdateManyWithoutServiceDayNestedInput
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutServiceDayNestedInput
  }

  export type ServiceDayCreateManyInput = {
    id?: number
    menuDate: Date | string
    serviceDate: Date | string
    label?: string | null
    isPublished?: boolean
    isClosed?: boolean
    closedReason?: string | null
    orderingCutoffAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceDayUpdateManyMutationInput = {
    menuDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    orderingCutoffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceDayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    orderingCutoffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuCreateInput = {
    menuType?: $Enums.MenuType
    title?: string | null
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceDay: ServiceDayCreateNestedOneWithoutMenusInput
    offerings?: MenuOfferingCreateNestedManyWithoutMenuInput
  }

  export type MenuUncheckedCreateInput = {
    id?: number
    serviceDayId: number
    menuType?: $Enums.MenuType
    title?: string | null
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offerings?: MenuOfferingUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuUpdateInput = {
    menuType?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDay?: ServiceDayUpdateOneRequiredWithoutMenusNestedInput
    offerings?: MenuOfferingUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    menuType?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: MenuOfferingUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type MenuCreateManyInput = {
    id?: number
    serviceDayId: number
    menuType?: $Enums.MenuType
    title?: string | null
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateManyMutationInput = {
    menuType?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    menuType?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuOfferingCreateInput = {
    priceOverrideCents?: number | null
    capacityOverride?: number | null
    isAvailable?: boolean
    maxPerOrder?: number | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    menu: MenuCreateNestedOneWithoutOfferingsInput
    variant: MenuVariantCreateNestedOneWithoutOfferingsInput
    holds?: CapacityHoldCreateNestedManyWithoutOfferingInput
  }

  export type MenuOfferingUncheckedCreateInput = {
    id?: number
    menuId: number
    menuVariantId: number
    priceOverrideCents?: number | null
    capacityOverride?: number | null
    isAvailable?: boolean
    maxPerOrder?: number | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holds?: CapacityHoldUncheckedCreateNestedManyWithoutOfferingInput
  }

  export type MenuOfferingUpdateInput = {
    priceOverrideCents?: NullableIntFieldUpdateOperationsInput | number | null
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxPerOrder?: NullableIntFieldUpdateOperationsInput | number | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: MenuUpdateOneRequiredWithoutOfferingsNestedInput
    variant?: MenuVariantUpdateOneRequiredWithoutOfferingsNestedInput
    holds?: CapacityHoldUpdateManyWithoutOfferingNestedInput
  }

  export type MenuOfferingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    menuVariantId?: IntFieldUpdateOperationsInput | number
    priceOverrideCents?: NullableIntFieldUpdateOperationsInput | number | null
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxPerOrder?: NullableIntFieldUpdateOperationsInput | number | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holds?: CapacityHoldUncheckedUpdateManyWithoutOfferingNestedInput
  }

  export type MenuOfferingCreateManyInput = {
    id?: number
    menuId: number
    menuVariantId: number
    priceOverrideCents?: number | null
    capacityOverride?: number | null
    isAvailable?: boolean
    maxPerOrder?: number | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuOfferingUpdateManyMutationInput = {
    priceOverrideCents?: NullableIntFieldUpdateOperationsInput | number | null
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxPerOrder?: NullableIntFieldUpdateOperationsInput | number | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuOfferingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    menuVariantId?: IntFieldUpdateOperationsInput | number
    priceOverrideCents?: NullableIntFieldUpdateOperationsInput | number | null
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxPerOrder?: NullableIntFieldUpdateOperationsInput | number | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PickupLocationCreateInput = {
    name: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    timezone?: string | null
    instructions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceSlots?: ServiceSlotCreateNestedManyWithoutPickupLocationInput
    orders?: OrderCreateNestedManyWithoutPickupLocationInput
  }

  export type PickupLocationUncheckedCreateInput = {
    id?: number
    name: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    timezone?: string | null
    instructions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceSlots?: ServiceSlotUncheckedCreateNestedManyWithoutPickupLocationInput
    orders?: OrderUncheckedCreateNestedManyWithoutPickupLocationInput
  }

  export type PickupLocationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceSlots?: ServiceSlotUpdateManyWithoutPickupLocationNestedInput
    orders?: OrderUpdateManyWithoutPickupLocationNestedInput
  }

  export type PickupLocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceSlots?: ServiceSlotUncheckedUpdateManyWithoutPickupLocationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutPickupLocationNestedInput
  }

  export type PickupLocationCreateManyInput = {
    id?: number
    name: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    timezone?: string | null
    instructions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PickupLocationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PickupLocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    lat?: number | null
    lng?: number | null
    isDefault?: boolean
    isSnapshot?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAddressesInput
    deliveryOrders?: OrderCreateNestedManyWithoutDeliveryAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: number
    userId?: number | null
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    lat?: number | null
    lng?: number | null
    isDefault?: boolean
    isSnapshot?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryOrders?: OrderUncheckedCreateNestedManyWithoutDeliveryAddressInput
  }

  export type AddressUpdateInput = {
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isSnapshot?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAddressesNestedInput
    deliveryOrders?: OrderUpdateManyWithoutDeliveryAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isSnapshot?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryOrders?: OrderUncheckedUpdateManyWithoutDeliveryAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: number
    userId?: number | null
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    lat?: number | null
    lng?: number | null
    isDefault?: boolean
    isSnapshot?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isSnapshot?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isSnapshot?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlotTemplateCreateInput = {
    label: string
    startMin: number
    endMin: number
    defaultCapacity?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceSlots?: ServiceSlotCreateNestedManyWithoutTemplateInput
  }

  export type SlotTemplateUncheckedCreateInput = {
    id?: number
    label: string
    startMin: number
    endMin: number
    defaultCapacity?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceSlots?: ServiceSlotUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type SlotTemplateUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    startMin?: IntFieldUpdateOperationsInput | number
    endMin?: IntFieldUpdateOperationsInput | number
    defaultCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceSlots?: ServiceSlotUpdateManyWithoutTemplateNestedInput
  }

  export type SlotTemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    startMin?: IntFieldUpdateOperationsInput | number
    endMin?: IntFieldUpdateOperationsInput | number
    defaultCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceSlots?: ServiceSlotUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type SlotTemplateCreateManyInput = {
    id?: number
    label: string
    startMin: number
    endMin: number
    defaultCapacity?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlotTemplateUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    startMin?: IntFieldUpdateOperationsInput | number
    endMin?: IntFieldUpdateOperationsInput | number
    defaultCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlotTemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    startMin?: IntFieldUpdateOperationsInput | number
    endMin?: IntFieldUpdateOperationsInput | number
    defaultCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceSlotCreateInput = {
    fulfillmentType: $Enums.FulfillmentType
    slotKey: string
    capacityOverride?: number | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceDay: ServiceDayCreateNestedOneWithoutSlotsInput
    template: SlotTemplateCreateNestedOneWithoutServiceSlotsInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutServiceSlotsInput
    groups?: FulfillmentGroupCreateNestedManyWithoutServiceSlotInput
  }

  export type ServiceSlotUncheckedCreateInput = {
    id?: number
    serviceDayId: number
    slotTemplateId: number
    fulfillmentType: $Enums.FulfillmentType
    pickupLocationId?: number | null
    slotKey: string
    capacityOverride?: number | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutServiceSlotInput
  }

  export type ServiceSlotUpdateInput = {
    fulfillmentType?: EnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType
    slotKey?: StringFieldUpdateOperationsInput | string
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDay?: ServiceDayUpdateOneRequiredWithoutSlotsNestedInput
    template?: SlotTemplateUpdateOneRequiredWithoutServiceSlotsNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutServiceSlotsNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutServiceSlotNestedInput
  }

  export type ServiceSlotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    slotTemplateId?: IntFieldUpdateOperationsInput | number
    fulfillmentType?: EnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    slotKey?: StringFieldUpdateOperationsInput | string
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutServiceSlotNestedInput
  }

  export type ServiceSlotCreateManyInput = {
    id?: number
    serviceDayId: number
    slotTemplateId: number
    fulfillmentType: $Enums.FulfillmentType
    pickupLocationId?: number | null
    slotKey: string
    capacityOverride?: number | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceSlotUpdateManyMutationInput = {
    fulfillmentType?: EnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType
    slotKey?: StringFieldUpdateOperationsInput | string
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceSlotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    slotTemplateId?: IntFieldUpdateOperationsInput | number
    fulfillmentType?: EnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    slotKey?: StringFieldUpdateOperationsInput | string
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliverySettingsCreateInput = {
    id?: number
    originAddress: string
    originLat?: number | null
    originLng?: number | null
    maxRadiusMiles?: number
    feeTiers: JsonNullValueInput | InputJsonValue
    bundlePolicy?: NullableJsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.DeliveryPricingMode
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliverySettingsUncheckedCreateInput = {
    id?: number
    originAddress: string
    originLat?: number | null
    originLng?: number | null
    maxRadiusMiles?: number
    feeTiers: JsonNullValueInput | InputJsonValue
    bundlePolicy?: NullableJsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.DeliveryPricingMode
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliverySettingsUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    originAddress?: StringFieldUpdateOperationsInput | string
    originLat?: NullableFloatFieldUpdateOperationsInput | number | null
    originLng?: NullableFloatFieldUpdateOperationsInput | number | null
    maxRadiusMiles?: FloatFieldUpdateOperationsInput | number
    feeTiers?: JsonNullValueInput | InputJsonValue
    bundlePolicy?: NullableJsonNullValueInput | InputJsonValue
    pricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliverySettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    originAddress?: StringFieldUpdateOperationsInput | string
    originLat?: NullableFloatFieldUpdateOperationsInput | number | null
    originLng?: NullableFloatFieldUpdateOperationsInput | number | null
    maxRadiusMiles?: FloatFieldUpdateOperationsInput | number
    feeTiers?: JsonNullValueInput | InputJsonValue
    bundlePolicy?: NullableJsonNullValueInput | InputJsonValue
    pricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliverySettingsCreateManyInput = {
    id?: number
    originAddress: string
    originLat?: number | null
    originLng?: number | null
    maxRadiusMiles?: number
    feeTiers: JsonNullValueInput | InputJsonValue
    bundlePolicy?: NullableJsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.DeliveryPricingMode
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliverySettingsUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    originAddress?: StringFieldUpdateOperationsInput | string
    originLat?: NullableFloatFieldUpdateOperationsInput | number | null
    originLng?: NullableFloatFieldUpdateOperationsInput | number | null
    maxRadiusMiles?: FloatFieldUpdateOperationsInput | number
    feeTiers?: JsonNullValueInput | InputJsonValue
    bundlePolicy?: NullableJsonNullValueInput | InputJsonValue
    pricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliverySettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    originAddress?: StringFieldUpdateOperationsInput | string
    originLat?: NullableFloatFieldUpdateOperationsInput | number | null
    originLng?: NullableFloatFieldUpdateOperationsInput | number | null
    maxRadiusMiles?: FloatFieldUpdateOperationsInput | number
    feeTiers?: JsonNullValueInput | InputJsonValue
    bundlePolicy?: NullableJsonNullValueInput | InputJsonValue
    pricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    createdBy?: UserCreateNestedOneWithoutCreatedOrdersInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutDeliveryOrdersInput
    groups?: FulfillmentGroupCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    events?: OrderEventCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    events?: OrderEventUncheckedCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldUncheckedCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    createdBy?: UserUpdateOneWithoutCreatedOrdersNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutDeliveryOrdersNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    events?: OrderEventUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUncheckedUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FulfillmentGroupCreateInput = {
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutGroupsInput
    serviceDay: ServiceDayCreateNestedOneWithoutGroupsInput
    serviceSlot?: ServiceSlotCreateNestedOneWithoutGroupsInput
    items?: OrderItemCreateNestedManyWithoutGroupInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutGroupInput
    events?: OrderEventCreateNestedManyWithoutGroupInput
  }

  export type FulfillmentGroupUncheckedCreateInput = {
    id?: number
    orderId: number
    serviceDayId: number
    serviceSlotId?: number | null
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutGroupInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutGroupInput
    events?: OrderEventUncheckedCreateNestedManyWithoutGroupInput
  }

  export type FulfillmentGroupUpdateInput = {
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutGroupsNestedInput
    serviceDay?: ServiceDayUpdateOneRequiredWithoutGroupsNestedInput
    serviceSlot?: ServiceSlotUpdateOneWithoutGroupsNestedInput
    items?: OrderItemUpdateManyWithoutGroupNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutGroupNestedInput
    events?: OrderEventUpdateManyWithoutGroupNestedInput
  }

  export type FulfillmentGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    serviceSlotId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutGroupNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutGroupNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type FulfillmentGroupCreateManyInput = {
    id?: number
    orderId: number
    serviceDayId: number
    serviceSlotId?: number | null
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FulfillmentGroupUpdateManyMutationInput = {
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FulfillmentGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    serviceSlotId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    variantLabelSnapshot: string
    imageUrlSnapshot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    group: FulfillmentGroupCreateNestedOneWithoutItemsInput
    variant: MenuVariantCreateNestedOneWithoutOrderItemsInput
    addOns?: OrderItemAddOnCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: number
    orderId: number
    fulfillmentGroupId: number
    menuVariantId: number
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    variantLabelSnapshot: string
    imageUrlSnapshot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addOns?: OrderItemAddOnUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    variantLabelSnapshot?: StringFieldUpdateOperationsInput | string
    imageUrlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    group?: FulfillmentGroupUpdateOneRequiredWithoutItemsNestedInput
    variant?: MenuVariantUpdateOneRequiredWithoutOrderItemsNestedInput
    addOns?: OrderItemAddOnUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    fulfillmentGroupId?: IntFieldUpdateOperationsInput | number
    menuVariantId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    variantLabelSnapshot?: StringFieldUpdateOperationsInput | string
    imageUrlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addOns?: OrderItemAddOnUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemCreateManyInput = {
    id?: number
    orderId: number
    fulfillmentGroupId: number
    menuVariantId: number
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    variantLabelSnapshot: string
    imageUrlSnapshot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    variantLabelSnapshot?: StringFieldUpdateOperationsInput | string
    imageUrlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    fulfillmentGroupId?: IntFieldUpdateOperationsInput | number
    menuVariantId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    variantLabelSnapshot?: StringFieldUpdateOperationsInput | string
    imageUrlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemAddOnCreateInput = {
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    orderItem: OrderItemCreateNestedOneWithoutAddOnsInput
    addOn?: AddOnCreateNestedOneWithoutOrderLinksInput
  }

  export type OrderItemAddOnUncheckedCreateInput = {
    id?: number
    orderItemId: number
    addOnId?: number | null
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
  }

  export type OrderItemAddOnUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    orderItem?: OrderItemUpdateOneRequiredWithoutAddOnsNestedInput
    addOn?: AddOnUpdateOneWithoutOrderLinksNestedInput
  }

  export type OrderItemAddOnUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderItemId?: IntFieldUpdateOperationsInput | number
    addOnId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemAddOnCreateManyInput = {
    id?: number
    orderItemId: number
    addOnId?: number | null
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
  }

  export type OrderItemAddOnUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemAddOnUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderItemId?: IntFieldUpdateOperationsInput | number
    addOnId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
  }

  export type OrderAdjustmentCreateInput = {
    type: $Enums.AdjustmentType
    label?: string | null
    amountCents: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutAdjustmentsInput
    group?: FulfillmentGroupCreateNestedOneWithoutAdjustmentsInput
  }

  export type OrderAdjustmentUncheckedCreateInput = {
    id?: number
    orderId: number
    fulfillmentGroupId?: number | null
    type: $Enums.AdjustmentType
    label?: string | null
    amountCents: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderAdjustmentUpdateInput = {
    type?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutAdjustmentsNestedInput
    group?: FulfillmentGroupUpdateOneWithoutAdjustmentsNestedInput
  }

  export type OrderAdjustmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    fulfillmentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAdjustmentCreateManyInput = {
    id?: number
    orderId: number
    fulfillmentGroupId?: number | null
    type: $Enums.AdjustmentType
    label?: string | null
    amountCents: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderAdjustmentUpdateManyMutationInput = {
    type?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAdjustmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    fulfillmentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    provider?: $Enums.PaymentProvider
    method: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    amountCents: number
    providerRef?: string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPaymentsInput
    receivedBy?: UserCreateNestedOneWithoutPaymentsReceivedInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    orderId: number
    provider?: $Enums.PaymentProvider
    method: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    amountCents: number
    providerRef?: string | null
    receivedByUserId?: number | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amountCents?: IntFieldUpdateOperationsInput | number
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
    receivedBy?: UserUpdateOneWithoutPaymentsReceivedNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amountCents?: IntFieldUpdateOperationsInput | number
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    orderId: number
    provider?: $Enums.PaymentProvider
    method: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    amountCents: number
    providerRef?: string | null
    receivedByUserId?: number | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amountCents?: IntFieldUpdateOperationsInput | number
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amountCents?: IntFieldUpdateOperationsInput | number
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderEventCreateInput = {
    type: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutEventsInput
    group?: FulfillmentGroupCreateNestedOneWithoutEventsInput
  }

  export type OrderEventUncheckedCreateInput = {
    id?: number
    orderId: number
    fulfillmentGroupId?: number | null
    type: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderEventUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutEventsNestedInput
    group?: FulfillmentGroupUpdateOneWithoutEventsNestedInput
  }

  export type OrderEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    fulfillmentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderEventCreateManyInput = {
    id?: number
    orderId: number
    fulfillmentGroupId?: number | null
    type: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderEventUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    fulfillmentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapacityHoldCreateInput = {
    quantity: number
    status?: $Enums.HoldStatus
    expiresAt: Date | string
    createdAt?: Date | string
    offering: MenuOfferingCreateNestedOneWithoutHoldsInput
    order?: OrderCreateNestedOneWithoutCapacityHoldsInput
  }

  export type CapacityHoldUncheckedCreateInput = {
    id?: number
    menuOfferingId: number
    orderId?: number | null
    quantity: number
    status?: $Enums.HoldStatus
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type CapacityHoldUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumHoldStatusFieldUpdateOperationsInput | $Enums.HoldStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offering?: MenuOfferingUpdateOneRequiredWithoutHoldsNestedInput
    order?: OrderUpdateOneWithoutCapacityHoldsNestedInput
  }

  export type CapacityHoldUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuOfferingId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumHoldStatusFieldUpdateOperationsInput | $Enums.HoldStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapacityHoldCreateManyInput = {
    id?: number
    menuOfferingId: number
    orderId?: number | null
    quantity: number
    status?: $Enums.HoldStatus
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type CapacityHoldUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumHoldStatusFieldUpdateOperationsInput | $Enums.HoldStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapacityHoldUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuOfferingId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumHoldStatusFieldUpdateOperationsInput | $Enums.HoldStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionCreateInput = {
    code: string
    description?: string | null
    type: $Enums.PromotionType
    amountCents?: number | null
    percentBps?: number | null
    minSubtotalCents?: number | null
    maxRedemptions?: number | null
    perUserLimit?: number | null
    startsAt: Date | string
    endsAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    redemptions?: PromotionRedemptionCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateInput = {
    id?: number
    code: string
    description?: string | null
    type: $Enums.PromotionType
    amountCents?: number | null
    percentBps?: number | null
    minSubtotalCents?: number | null
    maxRedemptions?: number | null
    perUserLimit?: number | null
    startsAt: Date | string
    endsAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    redemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromotionTypeFieldUpdateOperationsInput | $Enums.PromotionType
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    percentBps?: NullableIntFieldUpdateOperationsInput | number | null
    minSubtotalCents?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    perUserLimit?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: PromotionRedemptionUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromotionTypeFieldUpdateOperationsInput | $Enums.PromotionType
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    percentBps?: NullableIntFieldUpdateOperationsInput | number | null
    minSubtotalCents?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    perUserLimit?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: PromotionRedemptionUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionCreateManyInput = {
    id?: number
    code: string
    description?: string | null
    type: $Enums.PromotionType
    amountCents?: number | null
    percentBps?: number | null
    minSubtotalCents?: number | null
    maxRedemptions?: number | null
    perUserLimit?: number | null
    startsAt: Date | string
    endsAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromotionTypeFieldUpdateOperationsInput | $Enums.PromotionType
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    percentBps?: NullableIntFieldUpdateOperationsInput | number | null
    minSubtotalCents?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    perUserLimit?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromotionTypeFieldUpdateOperationsInput | $Enums.PromotionType
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    percentBps?: NullableIntFieldUpdateOperationsInput | number | null
    minSubtotalCents?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    perUserLimit?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionCreateInput = {
    discountCentsApplied: number
    createdAt?: Date | string
    promotion: PromotionCreateNestedOneWithoutRedemptionsInput
    order: OrderCreateNestedOneWithoutPromoRedemptionsInput
    user?: UserCreateNestedOneWithoutPromotionRedemptionsInput
  }

  export type PromotionRedemptionUncheckedCreateInput = {
    id?: number
    promotionId: number
    orderId: number
    userId?: number | null
    discountCentsApplied: number
    createdAt?: Date | string
  }

  export type PromotionRedemptionUpdateInput = {
    discountCentsApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promotion?: PromotionUpdateOneRequiredWithoutRedemptionsNestedInput
    order?: OrderUpdateOneRequiredWithoutPromoRedemptionsNestedInput
    user?: UserUpdateOneWithoutPromotionRedemptionsNestedInput
  }

  export type PromotionRedemptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    discountCentsApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionCreateManyInput = {
    id?: number
    promotionId: number
    orderId: number
    userId?: number | null
    discountCentsApplied: number
    createdAt?: Date | string
  }

  export type PromotionRedemptionUpdateManyMutationInput = {
    discountCentsApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    discountCentsApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardAccountCreateInput = {
    balancePoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRewardAccountInput
    txns?: RewardTransactionCreateNestedManyWithoutAccountInput
  }

  export type RewardAccountUncheckedCreateInput = {
    id?: number
    userId: number
    balancePoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    txns?: RewardTransactionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type RewardAccountUpdateInput = {
    balancePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRewardAccountNestedInput
    txns?: RewardTransactionUpdateManyWithoutAccountNestedInput
  }

  export type RewardAccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    balancePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    txns?: RewardTransactionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type RewardAccountCreateManyInput = {
    id?: number
    userId: number
    balancePoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardAccountUpdateManyMutationInput = {
    balancePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardAccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    balancePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardTransactionCreateInput = {
    type: $Enums.RewardTxnType
    amountPoints: number
    note?: string | null
    createdAt?: Date | string
    account: RewardAccountCreateNestedOneWithoutTxnsInput
    order?: OrderCreateNestedOneWithoutRewardTransactionsInput
  }

  export type RewardTransactionUncheckedCreateInput = {
    id?: number
    rewardAccountId: number
    type: $Enums.RewardTxnType
    amountPoints: number
    orderId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type RewardTransactionUpdateInput = {
    type?: EnumRewardTxnTypeFieldUpdateOperationsInput | $Enums.RewardTxnType
    amountPoints?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: RewardAccountUpdateOneRequiredWithoutTxnsNestedInput
    order?: OrderUpdateOneWithoutRewardTransactionsNestedInput
  }

  export type RewardTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rewardAccountId?: IntFieldUpdateOperationsInput | number
    type?: EnumRewardTxnTypeFieldUpdateOperationsInput | $Enums.RewardTxnType
    amountPoints?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardTransactionCreateManyInput = {
    id?: number
    rewardAccountId: number
    type: $Enums.RewardTxnType
    amountPoints: number
    orderId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type RewardTransactionUpdateManyMutationInput = {
    type?: EnumRewardTxnTypeFieldUpdateOperationsInput | $Enums.RewardTxnType
    amountPoints?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rewardAccountId?: IntFieldUpdateOperationsInput | number
    type?: EnumRewardTxnTypeFieldUpdateOperationsInput | $Enums.RewardTxnType
    amountPoints?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CateringOrderCreateInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    status?: $Enums.CateringStatus
    eventDate: Date | string
    guestCount: number
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    notes?: string | null
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCateringOrdersInput
    createdBy?: UserCreateNestedOneWithoutCreatedCateringOrdersInput
    items?: CateringItemCreateNestedManyWithoutCateringOrderInput
  }

  export type CateringOrderUncheckedCreateInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    status?: $Enums.CateringStatus
    eventDate: Date | string
    guestCount: number
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    notes?: string | null
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CateringItemUncheckedCreateNestedManyWithoutCateringOrderInput
  }

  export type CateringOrderUpdateInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCateringStatusFieldUpdateOperationsInput | $Enums.CateringStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guestCount?: IntFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCateringOrdersNestedInput
    createdBy?: UserUpdateOneWithoutCreatedCateringOrdersNestedInput
    items?: CateringItemUpdateManyWithoutCateringOrderNestedInput
  }

  export type CateringOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCateringStatusFieldUpdateOperationsInput | $Enums.CateringStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guestCount?: IntFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CateringItemUncheckedUpdateManyWithoutCateringOrderNestedInput
  }

  export type CateringOrderCreateManyInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    status?: $Enums.CateringStatus
    eventDate: Date | string
    guestCount: number
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    notes?: string | null
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CateringOrderUpdateManyMutationInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCateringStatusFieldUpdateOperationsInput | $Enums.CateringStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guestCount?: IntFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CateringOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCateringStatusFieldUpdateOperationsInput | $Enums.CateringStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guestCount?: IntFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CateringItemCreateInput = {
    nameSnapshot: string
    quantity: number
    unitPriceCents: number
    cateringOrder: CateringOrderCreateNestedOneWithoutItemsInput
    menuItem?: MenuItemCreateNestedOneWithoutCateringItemsInput
  }

  export type CateringItemUncheckedCreateInput = {
    id?: number
    cateringOrderId: number
    menuItemId?: number | null
    nameSnapshot: string
    quantity: number
    unitPriceCents: number
  }

  export type CateringItemUpdateInput = {
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    cateringOrder?: CateringOrderUpdateOneRequiredWithoutItemsNestedInput
    menuItem?: MenuItemUpdateOneWithoutCateringItemsNestedInput
  }

  export type CateringItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cateringOrderId?: IntFieldUpdateOperationsInput | number
    menuItemId?: NullableIntFieldUpdateOperationsInput | number | null
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
  }

  export type CateringItemCreateManyInput = {
    id?: number
    cateringOrderId: number
    menuItemId?: number | null
    nameSnapshot: string
    quantity: number
    unitPriceCents: number
  }

  export type CateringItemUpdateManyMutationInput = {
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
  }

  export type CateringItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cateringOrderId?: IntFieldUpdateOperationsInput | number
    menuItemId?: NullableIntFieldUpdateOperationsInput | number | null
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewCreateInput = {
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    order?: OrderCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: number
    userId: number
    orderId?: number | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    order?: OrderUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: number
    userId: number
    orderId?: number | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type CateringOrderListRelationFilter = {
    every?: CateringOrderWhereInput
    some?: CateringOrderWhereInput
    none?: CateringOrderWhereInput
  }

  export type RewardAccountNullableScalarRelationFilter = {
    is?: RewardAccountWhereInput | null
    isNot?: RewardAccountWhereInput | null
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type PromotionRedemptionListRelationFilter = {
    every?: PromotionRedemptionWhereInput
    some?: PromotionRedemptionWhereInput
    none?: PromotionRedemptionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CateringOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromotionRedemptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    googleId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    googleId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    googleId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type MenuItemListRelationFilter = {
    every?: MenuItemWhereInput
    some?: MenuItemWhereInput
    none?: MenuItemWhereInput
  }

  export type MenuItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type MenuVariantListRelationFilter = {
    every?: MenuVariantWhereInput
    some?: MenuVariantWhereInput
    none?: MenuVariantWhereInput
  }

  export type MenuItemAddOnListRelationFilter = {
    every?: MenuItemAddOnWhereInput
    some?: MenuItemAddOnWhereInput
    none?: MenuItemAddOnWhereInput
  }

  export type CateringItemListRelationFilter = {
    every?: CateringItemWhereInput
    some?: CateringItemWhereInput
    none?: CateringItemWhereInput
  }

  export type MenuVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuItemAddOnOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CateringItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuItemCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    nutrition?: SortOrder
    allergens?: SortOrder
    isActive?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuItemAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
  }

  export type MenuItemMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuItemMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuItemSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type MenuItemScalarRelationFilter = {
    is?: MenuItemWhereInput
    isNot?: MenuItemWhereInput
  }

  export type MenuOfferingListRelationFilter = {
    every?: MenuOfferingWhereInput
    some?: MenuOfferingWhereInput
    none?: MenuOfferingWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type MenuOfferingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuVariantCountOrderByAggregateInput = {
    id?: SortOrder
    menuItemId?: SortOrder
    label?: SortOrder
    basePriceCents?: SortOrder
    baseCapacity?: SortOrder
    isActive?: SortOrder
    prepMinutes?: SortOrder
    packagingCostCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuVariantAvgOrderByAggregateInput = {
    id?: SortOrder
    menuItemId?: SortOrder
    basePriceCents?: SortOrder
    baseCapacity?: SortOrder
    prepMinutes?: SortOrder
    packagingCostCents?: SortOrder
  }

  export type MenuVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    menuItemId?: SortOrder
    label?: SortOrder
    basePriceCents?: SortOrder
    baseCapacity?: SortOrder
    isActive?: SortOrder
    prepMinutes?: SortOrder
    packagingCostCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuVariantMinOrderByAggregateInput = {
    id?: SortOrder
    menuItemId?: SortOrder
    label?: SortOrder
    basePriceCents?: SortOrder
    baseCapacity?: SortOrder
    isActive?: SortOrder
    prepMinutes?: SortOrder
    packagingCostCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuVariantSumOrderByAggregateInput = {
    id?: SortOrder
    menuItemId?: SortOrder
    basePriceCents?: SortOrder
    baseCapacity?: SortOrder
    prepMinutes?: SortOrder
    packagingCostCents?: SortOrder
  }

  export type OrderItemAddOnListRelationFilter = {
    every?: OrderItemAddOnWhereInput
    some?: OrderItemAddOnWhereInput
    none?: OrderItemAddOnWhereInput
  }

  export type OrderItemAddOnOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddOnCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    priceCents?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddOnAvgOrderByAggregateInput = {
    id?: SortOrder
    priceCents?: SortOrder
  }

  export type AddOnMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    priceCents?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddOnMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    priceCents?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddOnSumOrderByAggregateInput = {
    id?: SortOrder
    priceCents?: SortOrder
  }

  export type AddOnScalarRelationFilter = {
    is?: AddOnWhereInput
    isNot?: AddOnWhereInput
  }

  export type MenuItemAddOnMenuItemIdAddOnIdCompoundUniqueInput = {
    menuItemId: number
    addOnId: number
  }

  export type MenuItemAddOnCountOrderByAggregateInput = {
    menuItemId?: SortOrder
    addOnId?: SortOrder
    maxQtyPerItem?: SortOrder
  }

  export type MenuItemAddOnAvgOrderByAggregateInput = {
    menuItemId?: SortOrder
    addOnId?: SortOrder
    maxQtyPerItem?: SortOrder
  }

  export type MenuItemAddOnMaxOrderByAggregateInput = {
    menuItemId?: SortOrder
    addOnId?: SortOrder
    maxQtyPerItem?: SortOrder
  }

  export type MenuItemAddOnMinOrderByAggregateInput = {
    menuItemId?: SortOrder
    addOnId?: SortOrder
    maxQtyPerItem?: SortOrder
  }

  export type MenuItemAddOnSumOrderByAggregateInput = {
    menuItemId?: SortOrder
    addOnId?: SortOrder
    maxQtyPerItem?: SortOrder
  }

  export type MenuListRelationFilter = {
    every?: MenuWhereInput
    some?: MenuWhereInput
    none?: MenuWhereInput
  }

  export type ServiceSlotListRelationFilter = {
    every?: ServiceSlotWhereInput
    some?: ServiceSlotWhereInput
    none?: ServiceSlotWhereInput
  }

  export type FulfillmentGroupListRelationFilter = {
    every?: FulfillmentGroupWhereInput
    some?: FulfillmentGroupWhereInput
    none?: FulfillmentGroupWhereInput
  }

  export type MenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FulfillmentGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceDayCountOrderByAggregateInput = {
    id?: SortOrder
    menuDate?: SortOrder
    serviceDate?: SortOrder
    label?: SortOrder
    isPublished?: SortOrder
    isClosed?: SortOrder
    closedReason?: SortOrder
    orderingCutoffAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceDayAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceDayMaxOrderByAggregateInput = {
    id?: SortOrder
    menuDate?: SortOrder
    serviceDate?: SortOrder
    label?: SortOrder
    isPublished?: SortOrder
    isClosed?: SortOrder
    closedReason?: SortOrder
    orderingCutoffAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceDayMinOrderByAggregateInput = {
    id?: SortOrder
    menuDate?: SortOrder
    serviceDate?: SortOrder
    label?: SortOrder
    isPublished?: SortOrder
    isClosed?: SortOrder
    closedReason?: SortOrder
    orderingCutoffAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceDaySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumMenuTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuType | EnumMenuTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MenuType[] | ListEnumMenuTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MenuType[] | ListEnumMenuTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMenuTypeFilter<$PrismaModel> | $Enums.MenuType
  }

  export type ServiceDayScalarRelationFilter = {
    is?: ServiceDayWhereInput
    isNot?: ServiceDayWhereInput
  }

  export type MenuServiceDayIdMenuTypeCompoundUniqueInput = {
    serviceDayId: number
    menuType: $Enums.MenuType
  }

  export type MenuCountOrderByAggregateInput = {
    id?: SortOrder
    serviceDayId?: SortOrder
    menuType?: SortOrder
    title?: SortOrder
    isPublished?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuAvgOrderByAggregateInput = {
    id?: SortOrder
    serviceDayId?: SortOrder
    displayOrder?: SortOrder
  }

  export type MenuMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceDayId?: SortOrder
    menuType?: SortOrder
    title?: SortOrder
    isPublished?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuMinOrderByAggregateInput = {
    id?: SortOrder
    serviceDayId?: SortOrder
    menuType?: SortOrder
    title?: SortOrder
    isPublished?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuSumOrderByAggregateInput = {
    id?: SortOrder
    serviceDayId?: SortOrder
    displayOrder?: SortOrder
  }

  export type EnumMenuTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuType | EnumMenuTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MenuType[] | ListEnumMenuTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MenuType[] | ListEnumMenuTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMenuTypeWithAggregatesFilter<$PrismaModel> | $Enums.MenuType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMenuTypeFilter<$PrismaModel>
    _max?: NestedEnumMenuTypeFilter<$PrismaModel>
  }

  export type MenuScalarRelationFilter = {
    is?: MenuWhereInput
    isNot?: MenuWhereInput
  }

  export type MenuVariantScalarRelationFilter = {
    is?: MenuVariantWhereInput
    isNot?: MenuVariantWhereInput
  }

  export type CapacityHoldListRelationFilter = {
    every?: CapacityHoldWhereInput
    some?: CapacityHoldWhereInput
    none?: CapacityHoldWhereInput
  }

  export type CapacityHoldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuOfferingMenuIdMenuVariantIdCompoundUniqueInput = {
    menuId: number
    menuVariantId: number
  }

  export type MenuOfferingCountOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    menuVariantId?: SortOrder
    priceOverrideCents?: SortOrder
    capacityOverride?: SortOrder
    isAvailable?: SortOrder
    maxPerOrder?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuOfferingAvgOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    menuVariantId?: SortOrder
    priceOverrideCents?: SortOrder
    capacityOverride?: SortOrder
    maxPerOrder?: SortOrder
    position?: SortOrder
  }

  export type MenuOfferingMaxOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    menuVariantId?: SortOrder
    priceOverrideCents?: SortOrder
    capacityOverride?: SortOrder
    isAvailable?: SortOrder
    maxPerOrder?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuOfferingMinOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    menuVariantId?: SortOrder
    priceOverrideCents?: SortOrder
    capacityOverride?: SortOrder
    isAvailable?: SortOrder
    maxPerOrder?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuOfferingSumOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    menuVariantId?: SortOrder
    priceOverrideCents?: SortOrder
    capacityOverride?: SortOrder
    maxPerOrder?: SortOrder
    position?: SortOrder
  }

  export type PickupLocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    timezone?: SortOrder
    instructions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PickupLocationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PickupLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    timezone?: SortOrder
    instructions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PickupLocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    timezone?: SortOrder
    instructions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PickupLocationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    isDefault?: SortOrder
    isSnapshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    isDefault?: SortOrder
    isSnapshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    isDefault?: SortOrder
    isSnapshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SlotTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    startMin?: SortOrder
    endMin?: SortOrder
    defaultCapacity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlotTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
    startMin?: SortOrder
    endMin?: SortOrder
    defaultCapacity?: SortOrder
  }

  export type SlotTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    startMin?: SortOrder
    endMin?: SortOrder
    defaultCapacity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlotTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    startMin?: SortOrder
    endMin?: SortOrder
    defaultCapacity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlotTemplateSumOrderByAggregateInput = {
    id?: SortOrder
    startMin?: SortOrder
    endMin?: SortOrder
    defaultCapacity?: SortOrder
  }

  export type EnumFulfillmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FulfillmentType | EnumFulfillmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FulfillmentType[] | ListEnumFulfillmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FulfillmentType[] | ListEnumFulfillmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFulfillmentTypeFilter<$PrismaModel> | $Enums.FulfillmentType
  }

  export type SlotTemplateScalarRelationFilter = {
    is?: SlotTemplateWhereInput
    isNot?: SlotTemplateWhereInput
  }

  export type PickupLocationNullableScalarRelationFilter = {
    is?: PickupLocationWhereInput | null
    isNot?: PickupLocationWhereInput | null
  }

  export type ServiceSlotCountOrderByAggregateInput = {
    id?: SortOrder
    serviceDayId?: SortOrder
    slotTemplateId?: SortOrder
    fulfillmentType?: SortOrder
    pickupLocationId?: SortOrder
    slotKey?: SortOrder
    capacityOverride?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSlotAvgOrderByAggregateInput = {
    id?: SortOrder
    serviceDayId?: SortOrder
    slotTemplateId?: SortOrder
    pickupLocationId?: SortOrder
    capacityOverride?: SortOrder
  }

  export type ServiceSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceDayId?: SortOrder
    slotTemplateId?: SortOrder
    fulfillmentType?: SortOrder
    pickupLocationId?: SortOrder
    slotKey?: SortOrder
    capacityOverride?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSlotMinOrderByAggregateInput = {
    id?: SortOrder
    serviceDayId?: SortOrder
    slotTemplateId?: SortOrder
    fulfillmentType?: SortOrder
    pickupLocationId?: SortOrder
    slotKey?: SortOrder
    capacityOverride?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSlotSumOrderByAggregateInput = {
    id?: SortOrder
    serviceDayId?: SortOrder
    slotTemplateId?: SortOrder
    pickupLocationId?: SortOrder
    capacityOverride?: SortOrder
  }

  export type EnumFulfillmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FulfillmentType | EnumFulfillmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FulfillmentType[] | ListEnumFulfillmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FulfillmentType[] | ListEnumFulfillmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFulfillmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.FulfillmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFulfillmentTypeFilter<$PrismaModel>
    _max?: NestedEnumFulfillmentTypeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumDeliveryPricingModeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryPricingMode | EnumDeliveryPricingModeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryPricingMode[] | ListEnumDeliveryPricingModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryPricingMode[] | ListEnumDeliveryPricingModeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryPricingModeFilter<$PrismaModel> | $Enums.DeliveryPricingMode
  }

  export type DeliverySettingsCountOrderByAggregateInput = {
    id?: SortOrder
    originAddress?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    maxRadiusMiles?: SortOrder
    feeTiers?: SortOrder
    bundlePolicy?: SortOrder
    pricingMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliverySettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    maxRadiusMiles?: SortOrder
  }

  export type DeliverySettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    originAddress?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    maxRadiusMiles?: SortOrder
    pricingMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliverySettingsMinOrderByAggregateInput = {
    id?: SortOrder
    originAddress?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    maxRadiusMiles?: SortOrder
    pricingMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliverySettingsSumOrderByAggregateInput = {
    id?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    maxRadiusMiles?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumDeliveryPricingModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryPricingMode | EnumDeliveryPricingModeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryPricingMode[] | ListEnumDeliveryPricingModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryPricingMode[] | ListEnumDeliveryPricingModeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryPricingModeWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryPricingMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryPricingModeFilter<$PrismaModel>
    _max?: NestedEnumDeliveryPricingModeFilter<$PrismaModel>
  }

  export type EnumOrderSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderSource | EnumOrderSourceFieldRefInput<$PrismaModel>
    in?: $Enums.OrderSource[] | ListEnumOrderSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderSource[] | ListEnumOrderSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderSourceFilter<$PrismaModel> | $Enums.OrderSource
  }

  export type EnumOrderCheckoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderCheckoutStatus | EnumOrderCheckoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderCheckoutStatus[] | ListEnumOrderCheckoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderCheckoutStatus[] | ListEnumOrderCheckoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderCheckoutStatusFilter<$PrismaModel> | $Enums.OrderCheckoutStatus
  }

  export type EnumFulfillmentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FulfillmentType | EnumFulfillmentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FulfillmentType[] | ListEnumFulfillmentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FulfillmentType[] | ListEnumFulfillmentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFulfillmentTypeNullableFilter<$PrismaModel> | $Enums.FulfillmentType | null
  }

  export type AddressNullableScalarRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type OrderAdjustmentListRelationFilter = {
    every?: OrderAdjustmentWhereInput
    some?: OrderAdjustmentWhereInput
    none?: OrderAdjustmentWhereInput
  }

  export type OrderEventListRelationFilter = {
    every?: OrderEventWhereInput
    some?: OrderEventWhereInput
    none?: OrderEventWhereInput
  }

  export type RewardTransactionListRelationFilter = {
    every?: RewardTransactionWhereInput
    some?: RewardTransactionWhereInput
    none?: RewardTransactionWhereInput
  }

  export type OrderAdjustmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RewardTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdByUserId?: SortOrder
    source?: SortOrder
    sourceRef?: SortOrder
    currency?: SortOrder
    checkoutStatus?: SortOrder
    deliveryPricingMode?: SortOrder
    fulfillmentType?: SortOrder
    pickupLocationId?: SortOrder
    deliveryAddressId?: SortOrder
    deliveryDistanceMiles?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhone?: SortOrder
    customerNotes?: SortOrder
    internalNotes?: SortOrder
    subtotalCents?: SortOrder
    adjustmentsCents?: SortOrder
    totalCents?: SortOrder
    refundedCents?: SortOrder
    placedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdByUserId?: SortOrder
    pickupLocationId?: SortOrder
    deliveryAddressId?: SortOrder
    deliveryDistanceMiles?: SortOrder
    subtotalCents?: SortOrder
    adjustmentsCents?: SortOrder
    totalCents?: SortOrder
    refundedCents?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdByUserId?: SortOrder
    source?: SortOrder
    sourceRef?: SortOrder
    currency?: SortOrder
    checkoutStatus?: SortOrder
    deliveryPricingMode?: SortOrder
    fulfillmentType?: SortOrder
    pickupLocationId?: SortOrder
    deliveryAddressId?: SortOrder
    deliveryDistanceMiles?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhone?: SortOrder
    customerNotes?: SortOrder
    internalNotes?: SortOrder
    subtotalCents?: SortOrder
    adjustmentsCents?: SortOrder
    totalCents?: SortOrder
    refundedCents?: SortOrder
    placedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdByUserId?: SortOrder
    source?: SortOrder
    sourceRef?: SortOrder
    currency?: SortOrder
    checkoutStatus?: SortOrder
    deliveryPricingMode?: SortOrder
    fulfillmentType?: SortOrder
    pickupLocationId?: SortOrder
    deliveryAddressId?: SortOrder
    deliveryDistanceMiles?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhone?: SortOrder
    customerNotes?: SortOrder
    internalNotes?: SortOrder
    subtotalCents?: SortOrder
    adjustmentsCents?: SortOrder
    totalCents?: SortOrder
    refundedCents?: SortOrder
    placedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdByUserId?: SortOrder
    pickupLocationId?: SortOrder
    deliveryAddressId?: SortOrder
    deliveryDistanceMiles?: SortOrder
    subtotalCents?: SortOrder
    adjustmentsCents?: SortOrder
    totalCents?: SortOrder
    refundedCents?: SortOrder
  }

  export type EnumOrderSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderSource | EnumOrderSourceFieldRefInput<$PrismaModel>
    in?: $Enums.OrderSource[] | ListEnumOrderSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderSource[] | ListEnumOrderSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderSourceWithAggregatesFilter<$PrismaModel> | $Enums.OrderSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderSourceFilter<$PrismaModel>
    _max?: NestedEnumOrderSourceFilter<$PrismaModel>
  }

  export type EnumOrderCheckoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderCheckoutStatus | EnumOrderCheckoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderCheckoutStatus[] | ListEnumOrderCheckoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderCheckoutStatus[] | ListEnumOrderCheckoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderCheckoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderCheckoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderCheckoutStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderCheckoutStatusFilter<$PrismaModel>
  }

  export type EnumFulfillmentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FulfillmentType | EnumFulfillmentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FulfillmentType[] | ListEnumFulfillmentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FulfillmentType[] | ListEnumFulfillmentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFulfillmentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FulfillmentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFulfillmentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFulfillmentTypeNullableFilter<$PrismaModel>
  }

  export type EnumFulfillmentGroupStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FulfillmentGroupStatus | EnumFulfillmentGroupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FulfillmentGroupStatus[] | ListEnumFulfillmentGroupStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FulfillmentGroupStatus[] | ListEnumFulfillmentGroupStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFulfillmentGroupStatusFilter<$PrismaModel> | $Enums.FulfillmentGroupStatus
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type ServiceSlotNullableScalarRelationFilter = {
    is?: ServiceSlotWhereInput | null
    isNot?: ServiceSlotWhereInput | null
  }

  export type FulfillmentGroupOrderIdServiceDayIdCompoundUniqueInput = {
    orderId: number
    serviceDayId: number
  }

  export type FulfillmentGroupCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceDayId?: SortOrder
    serviceSlotId?: SortOrder
    status?: SortOrder
    sequence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FulfillmentGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceDayId?: SortOrder
    serviceSlotId?: SortOrder
    sequence?: SortOrder
  }

  export type FulfillmentGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceDayId?: SortOrder
    serviceSlotId?: SortOrder
    status?: SortOrder
    sequence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FulfillmentGroupMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceDayId?: SortOrder
    serviceSlotId?: SortOrder
    status?: SortOrder
    sequence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FulfillmentGroupSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    serviceDayId?: SortOrder
    serviceSlotId?: SortOrder
    sequence?: SortOrder
  }

  export type EnumFulfillmentGroupStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FulfillmentGroupStatus | EnumFulfillmentGroupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FulfillmentGroupStatus[] | ListEnumFulfillmentGroupStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FulfillmentGroupStatus[] | ListEnumFulfillmentGroupStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFulfillmentGroupStatusWithAggregatesFilter<$PrismaModel> | $Enums.FulfillmentGroupStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFulfillmentGroupStatusFilter<$PrismaModel>
    _max?: NestedEnumFulfillmentGroupStatusFilter<$PrismaModel>
  }

  export type FulfillmentGroupScalarRelationFilter = {
    is?: FulfillmentGroupWhereInput
    isNot?: FulfillmentGroupWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
    menuVariantId?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    nameSnapshot?: SortOrder
    variantLabelSnapshot?: SortOrder
    imageUrlSnapshot?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
    menuVariantId?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
    menuVariantId?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    nameSnapshot?: SortOrder
    variantLabelSnapshot?: SortOrder
    imageUrlSnapshot?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
    menuVariantId?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    nameSnapshot?: SortOrder
    variantLabelSnapshot?: SortOrder
    imageUrlSnapshot?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
    menuVariantId?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
  }

  export type OrderItemScalarRelationFilter = {
    is?: OrderItemWhereInput
    isNot?: OrderItemWhereInput
  }

  export type AddOnNullableScalarRelationFilter = {
    is?: AddOnWhereInput | null
    isNot?: AddOnWhereInput | null
  }

  export type OrderItemAddOnCountOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    addOnId?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    nameSnapshot?: SortOrder
  }

  export type OrderItemAddOnAvgOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    addOnId?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
  }

  export type OrderItemAddOnMaxOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    addOnId?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    nameSnapshot?: SortOrder
  }

  export type OrderItemAddOnMinOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    addOnId?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    nameSnapshot?: SortOrder
  }

  export type OrderItemAddOnSumOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    addOnId?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
  }

  export type EnumAdjustmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdjustmentType | EnumAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdjustmentType[] | ListEnumAdjustmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdjustmentType[] | ListEnumAdjustmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdjustmentTypeFilter<$PrismaModel> | $Enums.AdjustmentType
  }

  export type FulfillmentGroupNullableScalarRelationFilter = {
    is?: FulfillmentGroupWhereInput | null
    isNot?: FulfillmentGroupWhereInput | null
  }

  export type OrderAdjustmentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    amountCents?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderAdjustmentAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
    amountCents?: SortOrder
  }

  export type OrderAdjustmentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    amountCents?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderAdjustmentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
    type?: SortOrder
    label?: SortOrder
    amountCents?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderAdjustmentSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
    amountCents?: SortOrder
  }

  export type EnumAdjustmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdjustmentType | EnumAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdjustmentType[] | ListEnumAdjustmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdjustmentType[] | ListEnumAdjustmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdjustmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdjustmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdjustmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAdjustmentTypeFilter<$PrismaModel>
  }

  export type EnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderFilter<$PrismaModel> | $Enums.PaymentProvider
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    method?: SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    providerRef?: SortOrder
    receivedByUserId?: SortOrder
    receivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    amountCents?: SortOrder
    receivedByUserId?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    method?: SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    providerRef?: SortOrder
    receivedByUserId?: SortOrder
    receivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    method?: SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    providerRef?: SortOrder
    receivedByUserId?: SortOrder
    receivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    amountCents?: SortOrder
    receivedByUserId?: SortOrder
  }

  export type EnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type OrderEventCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderEventAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
  }

  export type OrderEventMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderEventMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderEventSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fulfillmentGroupId?: SortOrder
  }

  export type EnumHoldStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HoldStatus | EnumHoldStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HoldStatus[] | ListEnumHoldStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HoldStatus[] | ListEnumHoldStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHoldStatusFilter<$PrismaModel> | $Enums.HoldStatus
  }

  export type MenuOfferingScalarRelationFilter = {
    is?: MenuOfferingWhereInput
    isNot?: MenuOfferingWhereInput
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type CapacityHoldCountOrderByAggregateInput = {
    id?: SortOrder
    menuOfferingId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CapacityHoldAvgOrderByAggregateInput = {
    id?: SortOrder
    menuOfferingId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
  }

  export type CapacityHoldMaxOrderByAggregateInput = {
    id?: SortOrder
    menuOfferingId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CapacityHoldMinOrderByAggregateInput = {
    id?: SortOrder
    menuOfferingId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CapacityHoldSumOrderByAggregateInput = {
    id?: SortOrder
    menuOfferingId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
  }

  export type EnumHoldStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HoldStatus | EnumHoldStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HoldStatus[] | ListEnumHoldStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HoldStatus[] | ListEnumHoldStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHoldStatusWithAggregatesFilter<$PrismaModel> | $Enums.HoldStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHoldStatusFilter<$PrismaModel>
    _max?: NestedEnumHoldStatusFilter<$PrismaModel>
  }

  export type EnumPromotionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PromotionType | EnumPromotionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromotionType[] | ListEnumPromotionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromotionType[] | ListEnumPromotionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromotionTypeFilter<$PrismaModel> | $Enums.PromotionType
  }

  export type PromotionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    type?: SortOrder
    amountCents?: SortOrder
    percentBps?: SortOrder
    minSubtotalCents?: SortOrder
    maxRedemptions?: SortOrder
    perUserLimit?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionAvgOrderByAggregateInput = {
    id?: SortOrder
    amountCents?: SortOrder
    percentBps?: SortOrder
    minSubtotalCents?: SortOrder
    maxRedemptions?: SortOrder
    perUserLimit?: SortOrder
  }

  export type PromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    type?: SortOrder
    amountCents?: SortOrder
    percentBps?: SortOrder
    minSubtotalCents?: SortOrder
    maxRedemptions?: SortOrder
    perUserLimit?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    type?: SortOrder
    amountCents?: SortOrder
    percentBps?: SortOrder
    minSubtotalCents?: SortOrder
    maxRedemptions?: SortOrder
    perUserLimit?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionSumOrderByAggregateInput = {
    id?: SortOrder
    amountCents?: SortOrder
    percentBps?: SortOrder
    minSubtotalCents?: SortOrder
    maxRedemptions?: SortOrder
    perUserLimit?: SortOrder
  }

  export type EnumPromotionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromotionType | EnumPromotionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromotionType[] | ListEnumPromotionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromotionType[] | ListEnumPromotionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromotionTypeWithAggregatesFilter<$PrismaModel> | $Enums.PromotionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromotionTypeFilter<$PrismaModel>
    _max?: NestedEnumPromotionTypeFilter<$PrismaModel>
  }

  export type PromotionScalarRelationFilter = {
    is?: PromotionWhereInput
    isNot?: PromotionWhereInput
  }

  export type PromotionRedemptionPromotionIdOrderIdCompoundUniqueInput = {
    promotionId: number
    orderId: number
  }

  export type PromotionRedemptionCountOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    discountCentsApplied?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionRedemptionAvgOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    discountCentsApplied?: SortOrder
  }

  export type PromotionRedemptionMaxOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    discountCentsApplied?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionRedemptionMinOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    discountCentsApplied?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionRedemptionSumOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    discountCentsApplied?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RewardAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balancePoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardAccountAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balancePoints?: SortOrder
  }

  export type RewardAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balancePoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balancePoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardAccountSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balancePoints?: SortOrder
  }

  export type EnumRewardTxnTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardTxnType | EnumRewardTxnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RewardTxnType[] | ListEnumRewardTxnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardTxnType[] | ListEnumRewardTxnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardTxnTypeFilter<$PrismaModel> | $Enums.RewardTxnType
  }

  export type RewardAccountScalarRelationFilter = {
    is?: RewardAccountWhereInput
    isNot?: RewardAccountWhereInput
  }

  export type RewardTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    rewardAccountId?: SortOrder
    type?: SortOrder
    amountPoints?: SortOrder
    orderId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type RewardTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    rewardAccountId?: SortOrder
    amountPoints?: SortOrder
    orderId?: SortOrder
  }

  export type RewardTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    rewardAccountId?: SortOrder
    type?: SortOrder
    amountPoints?: SortOrder
    orderId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type RewardTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    rewardAccountId?: SortOrder
    type?: SortOrder
    amountPoints?: SortOrder
    orderId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type RewardTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    rewardAccountId?: SortOrder
    amountPoints?: SortOrder
    orderId?: SortOrder
  }

  export type EnumRewardTxnTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardTxnType | EnumRewardTxnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RewardTxnType[] | ListEnumRewardTxnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardTxnType[] | ListEnumRewardTxnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardTxnTypeWithAggregatesFilter<$PrismaModel> | $Enums.RewardTxnType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRewardTxnTypeFilter<$PrismaModel>
    _max?: NestedEnumRewardTxnTypeFilter<$PrismaModel>
  }

  export type EnumCateringStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CateringStatus | EnumCateringStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CateringStatus[] | ListEnumCateringStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CateringStatus[] | ListEnumCateringStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCateringStatusFilter<$PrismaModel> | $Enums.CateringStatus
  }

  export type CateringOrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdByUserId?: SortOrder
    source?: SortOrder
    sourceRef?: SortOrder
    status?: SortOrder
    eventDate?: SortOrder
    guestCount?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhone?: SortOrder
    notes?: SortOrder
    totalCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CateringOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdByUserId?: SortOrder
    guestCount?: SortOrder
    totalCents?: SortOrder
  }

  export type CateringOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdByUserId?: SortOrder
    source?: SortOrder
    sourceRef?: SortOrder
    status?: SortOrder
    eventDate?: SortOrder
    guestCount?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhone?: SortOrder
    notes?: SortOrder
    totalCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CateringOrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdByUserId?: SortOrder
    source?: SortOrder
    sourceRef?: SortOrder
    status?: SortOrder
    eventDate?: SortOrder
    guestCount?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhone?: SortOrder
    notes?: SortOrder
    totalCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CateringOrderSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdByUserId?: SortOrder
    guestCount?: SortOrder
    totalCents?: SortOrder
  }

  export type EnumCateringStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CateringStatus | EnumCateringStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CateringStatus[] | ListEnumCateringStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CateringStatus[] | ListEnumCateringStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCateringStatusWithAggregatesFilter<$PrismaModel> | $Enums.CateringStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCateringStatusFilter<$PrismaModel>
    _max?: NestedEnumCateringStatusFilter<$PrismaModel>
  }

  export type CateringOrderScalarRelationFilter = {
    is?: CateringOrderWhereInput
    isNot?: CateringOrderWhereInput
  }

  export type MenuItemNullableScalarRelationFilter = {
    is?: MenuItemWhereInput | null
    isNot?: MenuItemWhereInput | null
  }

  export type CateringItemCountOrderByAggregateInput = {
    id?: SortOrder
    cateringOrderId?: SortOrder
    menuItemId?: SortOrder
    nameSnapshot?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
  }

  export type CateringItemAvgOrderByAggregateInput = {
    id?: SortOrder
    cateringOrderId?: SortOrder
    menuItemId?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
  }

  export type CateringItemMaxOrderByAggregateInput = {
    id?: SortOrder
    cateringOrderId?: SortOrder
    menuItemId?: SortOrder
    nameSnapshot?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
  }

  export type CateringItemMinOrderByAggregateInput = {
    id?: SortOrder
    cateringOrderId?: SortOrder
    menuItemId?: SortOrder
    nameSnapshot?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
  }

  export type CateringItemSumOrderByAggregateInput = {
    id?: SortOrder
    cateringOrderId?: SortOrder
    menuItemId?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    rating?: SortOrder
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput> | OrderCreateWithoutCreatedByInput[] | OrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCreatedByInput | OrderCreateOrConnectWithoutCreatedByInput[]
    createMany?: OrderCreateManyCreatedByInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type AddressCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutReceivedByInput = {
    create?: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput> | PaymentCreateWithoutReceivedByInput[] | PaymentUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceivedByInput | PaymentCreateOrConnectWithoutReceivedByInput[]
    createMany?: PaymentCreateManyReceivedByInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CateringOrderCreateNestedManyWithoutUserInput = {
    create?: XOR<CateringOrderCreateWithoutUserInput, CateringOrderUncheckedCreateWithoutUserInput> | CateringOrderCreateWithoutUserInput[] | CateringOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CateringOrderCreateOrConnectWithoutUserInput | CateringOrderCreateOrConnectWithoutUserInput[]
    createMany?: CateringOrderCreateManyUserInputEnvelope
    connect?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
  }

  export type CateringOrderCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CateringOrderCreateWithoutCreatedByInput, CateringOrderUncheckedCreateWithoutCreatedByInput> | CateringOrderCreateWithoutCreatedByInput[] | CateringOrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CateringOrderCreateOrConnectWithoutCreatedByInput | CateringOrderCreateOrConnectWithoutCreatedByInput[]
    createMany?: CateringOrderCreateManyCreatedByInputEnvelope
    connect?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
  }

  export type RewardAccountCreateNestedOneWithoutUserInput = {
    create?: XOR<RewardAccountCreateWithoutUserInput, RewardAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: RewardAccountCreateOrConnectWithoutUserInput
    connect?: RewardAccountWhereUniqueInput
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type PromotionRedemptionCreateNestedManyWithoutUserInput = {
    create?: XOR<PromotionRedemptionCreateWithoutUserInput, PromotionRedemptionUncheckedCreateWithoutUserInput> | PromotionRedemptionCreateWithoutUserInput[] | PromotionRedemptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutUserInput | PromotionRedemptionCreateOrConnectWithoutUserInput[]
    createMany?: PromotionRedemptionCreateManyUserInputEnvelope
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput> | OrderCreateWithoutCreatedByInput[] | OrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCreatedByInput | OrderCreateOrConnectWithoutCreatedByInput[]
    createMany?: OrderCreateManyCreatedByInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutReceivedByInput = {
    create?: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput> | PaymentCreateWithoutReceivedByInput[] | PaymentUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceivedByInput | PaymentCreateOrConnectWithoutReceivedByInput[]
    createMany?: PaymentCreateManyReceivedByInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CateringOrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CateringOrderCreateWithoutUserInput, CateringOrderUncheckedCreateWithoutUserInput> | CateringOrderCreateWithoutUserInput[] | CateringOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CateringOrderCreateOrConnectWithoutUserInput | CateringOrderCreateOrConnectWithoutUserInput[]
    createMany?: CateringOrderCreateManyUserInputEnvelope
    connect?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
  }

  export type CateringOrderUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CateringOrderCreateWithoutCreatedByInput, CateringOrderUncheckedCreateWithoutCreatedByInput> | CateringOrderCreateWithoutCreatedByInput[] | CateringOrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CateringOrderCreateOrConnectWithoutCreatedByInput | CateringOrderCreateOrConnectWithoutCreatedByInput[]
    createMany?: CateringOrderCreateManyCreatedByInputEnvelope
    connect?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
  }

  export type RewardAccountUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<RewardAccountCreateWithoutUserInput, RewardAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: RewardAccountCreateOrConnectWithoutUserInput
    connect?: RewardAccountWhereUniqueInput
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type PromotionRedemptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PromotionRedemptionCreateWithoutUserInput, PromotionRedemptionUncheckedCreateWithoutUserInput> | PromotionRedemptionCreateWithoutUserInput[] | PromotionRedemptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutUserInput | PromotionRedemptionCreateOrConnectWithoutUserInput[]
    createMany?: PromotionRedemptionCreateManyUserInputEnvelope
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput> | OrderCreateWithoutCreatedByInput[] | OrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCreatedByInput | OrderCreateOrConnectWithoutCreatedByInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCreatedByInput | OrderUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: OrderCreateManyCreatedByInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCreatedByInput | OrderUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCreatedByInput | OrderUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type AddressUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutUserInput | AddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutUserInput | AddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutUserInput | AddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutReceivedByNestedInput = {
    create?: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput> | PaymentCreateWithoutReceivedByInput[] | PaymentUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceivedByInput | PaymentCreateOrConnectWithoutReceivedByInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutReceivedByInput | PaymentUpsertWithWhereUniqueWithoutReceivedByInput[]
    createMany?: PaymentCreateManyReceivedByInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutReceivedByInput | PaymentUpdateWithWhereUniqueWithoutReceivedByInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutReceivedByInput | PaymentUpdateManyWithWhereWithoutReceivedByInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CateringOrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<CateringOrderCreateWithoutUserInput, CateringOrderUncheckedCreateWithoutUserInput> | CateringOrderCreateWithoutUserInput[] | CateringOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CateringOrderCreateOrConnectWithoutUserInput | CateringOrderCreateOrConnectWithoutUserInput[]
    upsert?: CateringOrderUpsertWithWhereUniqueWithoutUserInput | CateringOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CateringOrderCreateManyUserInputEnvelope
    set?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
    disconnect?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
    delete?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
    connect?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
    update?: CateringOrderUpdateWithWhereUniqueWithoutUserInput | CateringOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CateringOrderUpdateManyWithWhereWithoutUserInput | CateringOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CateringOrderScalarWhereInput | CateringOrderScalarWhereInput[]
  }

  export type CateringOrderUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CateringOrderCreateWithoutCreatedByInput, CateringOrderUncheckedCreateWithoutCreatedByInput> | CateringOrderCreateWithoutCreatedByInput[] | CateringOrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CateringOrderCreateOrConnectWithoutCreatedByInput | CateringOrderCreateOrConnectWithoutCreatedByInput[]
    upsert?: CateringOrderUpsertWithWhereUniqueWithoutCreatedByInput | CateringOrderUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CateringOrderCreateManyCreatedByInputEnvelope
    set?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
    disconnect?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
    delete?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
    connect?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
    update?: CateringOrderUpdateWithWhereUniqueWithoutCreatedByInput | CateringOrderUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CateringOrderUpdateManyWithWhereWithoutCreatedByInput | CateringOrderUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CateringOrderScalarWhereInput | CateringOrderScalarWhereInput[]
  }

  export type RewardAccountUpdateOneWithoutUserNestedInput = {
    create?: XOR<RewardAccountCreateWithoutUserInput, RewardAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: RewardAccountCreateOrConnectWithoutUserInput
    upsert?: RewardAccountUpsertWithoutUserInput
    disconnect?: RewardAccountWhereInput | boolean
    delete?: RewardAccountWhereInput | boolean
    connect?: RewardAccountWhereUniqueInput
    update?: XOR<XOR<RewardAccountUpdateToOneWithWhereWithoutUserInput, RewardAccountUpdateWithoutUserInput>, RewardAccountUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type PromotionRedemptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PromotionRedemptionCreateWithoutUserInput, PromotionRedemptionUncheckedCreateWithoutUserInput> | PromotionRedemptionCreateWithoutUserInput[] | PromotionRedemptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutUserInput | PromotionRedemptionCreateOrConnectWithoutUserInput[]
    upsert?: PromotionRedemptionUpsertWithWhereUniqueWithoutUserInput | PromotionRedemptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PromotionRedemptionCreateManyUserInputEnvelope
    set?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    disconnect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    delete?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    update?: PromotionRedemptionUpdateWithWhereUniqueWithoutUserInput | PromotionRedemptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PromotionRedemptionUpdateManyWithWhereWithoutUserInput | PromotionRedemptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput> | OrderCreateWithoutCreatedByInput[] | OrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCreatedByInput | OrderCreateOrConnectWithoutCreatedByInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCreatedByInput | OrderUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: OrderCreateManyCreatedByInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCreatedByInput | OrderUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCreatedByInput | OrderUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutUserInput | AddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutUserInput | AddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutUserInput | AddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutReceivedByNestedInput = {
    create?: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput> | PaymentCreateWithoutReceivedByInput[] | PaymentUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceivedByInput | PaymentCreateOrConnectWithoutReceivedByInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutReceivedByInput | PaymentUpsertWithWhereUniqueWithoutReceivedByInput[]
    createMany?: PaymentCreateManyReceivedByInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutReceivedByInput | PaymentUpdateWithWhereUniqueWithoutReceivedByInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutReceivedByInput | PaymentUpdateManyWithWhereWithoutReceivedByInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CateringOrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CateringOrderCreateWithoutUserInput, CateringOrderUncheckedCreateWithoutUserInput> | CateringOrderCreateWithoutUserInput[] | CateringOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CateringOrderCreateOrConnectWithoutUserInput | CateringOrderCreateOrConnectWithoutUserInput[]
    upsert?: CateringOrderUpsertWithWhereUniqueWithoutUserInput | CateringOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CateringOrderCreateManyUserInputEnvelope
    set?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
    disconnect?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
    delete?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
    connect?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
    update?: CateringOrderUpdateWithWhereUniqueWithoutUserInput | CateringOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CateringOrderUpdateManyWithWhereWithoutUserInput | CateringOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CateringOrderScalarWhereInput | CateringOrderScalarWhereInput[]
  }

  export type CateringOrderUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CateringOrderCreateWithoutCreatedByInput, CateringOrderUncheckedCreateWithoutCreatedByInput> | CateringOrderCreateWithoutCreatedByInput[] | CateringOrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CateringOrderCreateOrConnectWithoutCreatedByInput | CateringOrderCreateOrConnectWithoutCreatedByInput[]
    upsert?: CateringOrderUpsertWithWhereUniqueWithoutCreatedByInput | CateringOrderUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CateringOrderCreateManyCreatedByInputEnvelope
    set?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
    disconnect?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
    delete?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
    connect?: CateringOrderWhereUniqueInput | CateringOrderWhereUniqueInput[]
    update?: CateringOrderUpdateWithWhereUniqueWithoutCreatedByInput | CateringOrderUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CateringOrderUpdateManyWithWhereWithoutCreatedByInput | CateringOrderUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CateringOrderScalarWhereInput | CateringOrderScalarWhereInput[]
  }

  export type RewardAccountUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<RewardAccountCreateWithoutUserInput, RewardAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: RewardAccountCreateOrConnectWithoutUserInput
    upsert?: RewardAccountUpsertWithoutUserInput
    disconnect?: RewardAccountWhereInput | boolean
    delete?: RewardAccountWhereInput | boolean
    connect?: RewardAccountWhereUniqueInput
    update?: XOR<XOR<RewardAccountUpdateToOneWithWhereWithoutUserInput, RewardAccountUpdateWithoutUserInput>, RewardAccountUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type PromotionRedemptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PromotionRedemptionCreateWithoutUserInput, PromotionRedemptionUncheckedCreateWithoutUserInput> | PromotionRedemptionCreateWithoutUserInput[] | PromotionRedemptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutUserInput | PromotionRedemptionCreateOrConnectWithoutUserInput[]
    upsert?: PromotionRedemptionUpsertWithWhereUniqueWithoutUserInput | PromotionRedemptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PromotionRedemptionCreateManyUserInputEnvelope
    set?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    disconnect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    delete?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    update?: PromotionRedemptionUpdateWithWhereUniqueWithoutUserInput | PromotionRedemptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PromotionRedemptionUpdateManyWithWhereWithoutUserInput | PromotionRedemptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
  }

  export type MenuItemCreateNestedManyWithoutCategoryInput = {
    create?: XOR<MenuItemCreateWithoutCategoryInput, MenuItemUncheckedCreateWithoutCategoryInput> | MenuItemCreateWithoutCategoryInput[] | MenuItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutCategoryInput | MenuItemCreateOrConnectWithoutCategoryInput[]
    createMany?: MenuItemCreateManyCategoryInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type MenuItemUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<MenuItemCreateWithoutCategoryInput, MenuItemUncheckedCreateWithoutCategoryInput> | MenuItemCreateWithoutCategoryInput[] | MenuItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutCategoryInput | MenuItemCreateOrConnectWithoutCategoryInput[]
    createMany?: MenuItemCreateManyCategoryInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type MenuItemUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<MenuItemCreateWithoutCategoryInput, MenuItemUncheckedCreateWithoutCategoryInput> | MenuItemCreateWithoutCategoryInput[] | MenuItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutCategoryInput | MenuItemCreateOrConnectWithoutCategoryInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutCategoryInput | MenuItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: MenuItemCreateManyCategoryInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutCategoryInput | MenuItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutCategoryInput | MenuItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type MenuItemUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<MenuItemCreateWithoutCategoryInput, MenuItemUncheckedCreateWithoutCategoryInput> | MenuItemCreateWithoutCategoryInput[] | MenuItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutCategoryInput | MenuItemCreateOrConnectWithoutCategoryInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutCategoryInput | MenuItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: MenuItemCreateManyCategoryInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutCategoryInput | MenuItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutCategoryInput | MenuItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutItemsInput = {
    create?: XOR<CategoryCreateWithoutItemsInput, CategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutItemsInput
    connect?: CategoryWhereUniqueInput
  }

  export type MenuVariantCreateNestedManyWithoutMenuItemInput = {
    create?: XOR<MenuVariantCreateWithoutMenuItemInput, MenuVariantUncheckedCreateWithoutMenuItemInput> | MenuVariantCreateWithoutMenuItemInput[] | MenuVariantUncheckedCreateWithoutMenuItemInput[]
    connectOrCreate?: MenuVariantCreateOrConnectWithoutMenuItemInput | MenuVariantCreateOrConnectWithoutMenuItemInput[]
    createMany?: MenuVariantCreateManyMenuItemInputEnvelope
    connect?: MenuVariantWhereUniqueInput | MenuVariantWhereUniqueInput[]
  }

  export type MenuItemAddOnCreateNestedManyWithoutMenuItemInput = {
    create?: XOR<MenuItemAddOnCreateWithoutMenuItemInput, MenuItemAddOnUncheckedCreateWithoutMenuItemInput> | MenuItemAddOnCreateWithoutMenuItemInput[] | MenuItemAddOnUncheckedCreateWithoutMenuItemInput[]
    connectOrCreate?: MenuItemAddOnCreateOrConnectWithoutMenuItemInput | MenuItemAddOnCreateOrConnectWithoutMenuItemInput[]
    createMany?: MenuItemAddOnCreateManyMenuItemInputEnvelope
    connect?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
  }

  export type CateringItemCreateNestedManyWithoutMenuItemInput = {
    create?: XOR<CateringItemCreateWithoutMenuItemInput, CateringItemUncheckedCreateWithoutMenuItemInput> | CateringItemCreateWithoutMenuItemInput[] | CateringItemUncheckedCreateWithoutMenuItemInput[]
    connectOrCreate?: CateringItemCreateOrConnectWithoutMenuItemInput | CateringItemCreateOrConnectWithoutMenuItemInput[]
    createMany?: CateringItemCreateManyMenuItemInputEnvelope
    connect?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
  }

  export type MenuVariantUncheckedCreateNestedManyWithoutMenuItemInput = {
    create?: XOR<MenuVariantCreateWithoutMenuItemInput, MenuVariantUncheckedCreateWithoutMenuItemInput> | MenuVariantCreateWithoutMenuItemInput[] | MenuVariantUncheckedCreateWithoutMenuItemInput[]
    connectOrCreate?: MenuVariantCreateOrConnectWithoutMenuItemInput | MenuVariantCreateOrConnectWithoutMenuItemInput[]
    createMany?: MenuVariantCreateManyMenuItemInputEnvelope
    connect?: MenuVariantWhereUniqueInput | MenuVariantWhereUniqueInput[]
  }

  export type MenuItemAddOnUncheckedCreateNestedManyWithoutMenuItemInput = {
    create?: XOR<MenuItemAddOnCreateWithoutMenuItemInput, MenuItemAddOnUncheckedCreateWithoutMenuItemInput> | MenuItemAddOnCreateWithoutMenuItemInput[] | MenuItemAddOnUncheckedCreateWithoutMenuItemInput[]
    connectOrCreate?: MenuItemAddOnCreateOrConnectWithoutMenuItemInput | MenuItemAddOnCreateOrConnectWithoutMenuItemInput[]
    createMany?: MenuItemAddOnCreateManyMenuItemInputEnvelope
    connect?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
  }

  export type CateringItemUncheckedCreateNestedManyWithoutMenuItemInput = {
    create?: XOR<CateringItemCreateWithoutMenuItemInput, CateringItemUncheckedCreateWithoutMenuItemInput> | CateringItemCreateWithoutMenuItemInput[] | CateringItemUncheckedCreateWithoutMenuItemInput[]
    connectOrCreate?: CateringItemCreateOrConnectWithoutMenuItemInput | CateringItemCreateOrConnectWithoutMenuItemInput[]
    createMany?: CateringItemCreateManyMenuItemInputEnvelope
    connect?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CategoryUpdateOneWithoutItemsNestedInput = {
    create?: XOR<CategoryCreateWithoutItemsInput, CategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutItemsInput
    upsert?: CategoryUpsertWithoutItemsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutItemsInput, CategoryUpdateWithoutItemsInput>, CategoryUncheckedUpdateWithoutItemsInput>
  }

  export type MenuVariantUpdateManyWithoutMenuItemNestedInput = {
    create?: XOR<MenuVariantCreateWithoutMenuItemInput, MenuVariantUncheckedCreateWithoutMenuItemInput> | MenuVariantCreateWithoutMenuItemInput[] | MenuVariantUncheckedCreateWithoutMenuItemInput[]
    connectOrCreate?: MenuVariantCreateOrConnectWithoutMenuItemInput | MenuVariantCreateOrConnectWithoutMenuItemInput[]
    upsert?: MenuVariantUpsertWithWhereUniqueWithoutMenuItemInput | MenuVariantUpsertWithWhereUniqueWithoutMenuItemInput[]
    createMany?: MenuVariantCreateManyMenuItemInputEnvelope
    set?: MenuVariantWhereUniqueInput | MenuVariantWhereUniqueInput[]
    disconnect?: MenuVariantWhereUniqueInput | MenuVariantWhereUniqueInput[]
    delete?: MenuVariantWhereUniqueInput | MenuVariantWhereUniqueInput[]
    connect?: MenuVariantWhereUniqueInput | MenuVariantWhereUniqueInput[]
    update?: MenuVariantUpdateWithWhereUniqueWithoutMenuItemInput | MenuVariantUpdateWithWhereUniqueWithoutMenuItemInput[]
    updateMany?: MenuVariantUpdateManyWithWhereWithoutMenuItemInput | MenuVariantUpdateManyWithWhereWithoutMenuItemInput[]
    deleteMany?: MenuVariantScalarWhereInput | MenuVariantScalarWhereInput[]
  }

  export type MenuItemAddOnUpdateManyWithoutMenuItemNestedInput = {
    create?: XOR<MenuItemAddOnCreateWithoutMenuItemInput, MenuItemAddOnUncheckedCreateWithoutMenuItemInput> | MenuItemAddOnCreateWithoutMenuItemInput[] | MenuItemAddOnUncheckedCreateWithoutMenuItemInput[]
    connectOrCreate?: MenuItemAddOnCreateOrConnectWithoutMenuItemInput | MenuItemAddOnCreateOrConnectWithoutMenuItemInput[]
    upsert?: MenuItemAddOnUpsertWithWhereUniqueWithoutMenuItemInput | MenuItemAddOnUpsertWithWhereUniqueWithoutMenuItemInput[]
    createMany?: MenuItemAddOnCreateManyMenuItemInputEnvelope
    set?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
    disconnect?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
    delete?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
    connect?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
    update?: MenuItemAddOnUpdateWithWhereUniqueWithoutMenuItemInput | MenuItemAddOnUpdateWithWhereUniqueWithoutMenuItemInput[]
    updateMany?: MenuItemAddOnUpdateManyWithWhereWithoutMenuItemInput | MenuItemAddOnUpdateManyWithWhereWithoutMenuItemInput[]
    deleteMany?: MenuItemAddOnScalarWhereInput | MenuItemAddOnScalarWhereInput[]
  }

  export type CateringItemUpdateManyWithoutMenuItemNestedInput = {
    create?: XOR<CateringItemCreateWithoutMenuItemInput, CateringItemUncheckedCreateWithoutMenuItemInput> | CateringItemCreateWithoutMenuItemInput[] | CateringItemUncheckedCreateWithoutMenuItemInput[]
    connectOrCreate?: CateringItemCreateOrConnectWithoutMenuItemInput | CateringItemCreateOrConnectWithoutMenuItemInput[]
    upsert?: CateringItemUpsertWithWhereUniqueWithoutMenuItemInput | CateringItemUpsertWithWhereUniqueWithoutMenuItemInput[]
    createMany?: CateringItemCreateManyMenuItemInputEnvelope
    set?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
    disconnect?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
    delete?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
    connect?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
    update?: CateringItemUpdateWithWhereUniqueWithoutMenuItemInput | CateringItemUpdateWithWhereUniqueWithoutMenuItemInput[]
    updateMany?: CateringItemUpdateManyWithWhereWithoutMenuItemInput | CateringItemUpdateManyWithWhereWithoutMenuItemInput[]
    deleteMany?: CateringItemScalarWhereInput | CateringItemScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MenuVariantUncheckedUpdateManyWithoutMenuItemNestedInput = {
    create?: XOR<MenuVariantCreateWithoutMenuItemInput, MenuVariantUncheckedCreateWithoutMenuItemInput> | MenuVariantCreateWithoutMenuItemInput[] | MenuVariantUncheckedCreateWithoutMenuItemInput[]
    connectOrCreate?: MenuVariantCreateOrConnectWithoutMenuItemInput | MenuVariantCreateOrConnectWithoutMenuItemInput[]
    upsert?: MenuVariantUpsertWithWhereUniqueWithoutMenuItemInput | MenuVariantUpsertWithWhereUniqueWithoutMenuItemInput[]
    createMany?: MenuVariantCreateManyMenuItemInputEnvelope
    set?: MenuVariantWhereUniqueInput | MenuVariantWhereUniqueInput[]
    disconnect?: MenuVariantWhereUniqueInput | MenuVariantWhereUniqueInput[]
    delete?: MenuVariantWhereUniqueInput | MenuVariantWhereUniqueInput[]
    connect?: MenuVariantWhereUniqueInput | MenuVariantWhereUniqueInput[]
    update?: MenuVariantUpdateWithWhereUniqueWithoutMenuItemInput | MenuVariantUpdateWithWhereUniqueWithoutMenuItemInput[]
    updateMany?: MenuVariantUpdateManyWithWhereWithoutMenuItemInput | MenuVariantUpdateManyWithWhereWithoutMenuItemInput[]
    deleteMany?: MenuVariantScalarWhereInput | MenuVariantScalarWhereInput[]
  }

  export type MenuItemAddOnUncheckedUpdateManyWithoutMenuItemNestedInput = {
    create?: XOR<MenuItemAddOnCreateWithoutMenuItemInput, MenuItemAddOnUncheckedCreateWithoutMenuItemInput> | MenuItemAddOnCreateWithoutMenuItemInput[] | MenuItemAddOnUncheckedCreateWithoutMenuItemInput[]
    connectOrCreate?: MenuItemAddOnCreateOrConnectWithoutMenuItemInput | MenuItemAddOnCreateOrConnectWithoutMenuItemInput[]
    upsert?: MenuItemAddOnUpsertWithWhereUniqueWithoutMenuItemInput | MenuItemAddOnUpsertWithWhereUniqueWithoutMenuItemInput[]
    createMany?: MenuItemAddOnCreateManyMenuItemInputEnvelope
    set?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
    disconnect?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
    delete?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
    connect?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
    update?: MenuItemAddOnUpdateWithWhereUniqueWithoutMenuItemInput | MenuItemAddOnUpdateWithWhereUniqueWithoutMenuItemInput[]
    updateMany?: MenuItemAddOnUpdateManyWithWhereWithoutMenuItemInput | MenuItemAddOnUpdateManyWithWhereWithoutMenuItemInput[]
    deleteMany?: MenuItemAddOnScalarWhereInput | MenuItemAddOnScalarWhereInput[]
  }

  export type CateringItemUncheckedUpdateManyWithoutMenuItemNestedInput = {
    create?: XOR<CateringItemCreateWithoutMenuItemInput, CateringItemUncheckedCreateWithoutMenuItemInput> | CateringItemCreateWithoutMenuItemInput[] | CateringItemUncheckedCreateWithoutMenuItemInput[]
    connectOrCreate?: CateringItemCreateOrConnectWithoutMenuItemInput | CateringItemCreateOrConnectWithoutMenuItemInput[]
    upsert?: CateringItemUpsertWithWhereUniqueWithoutMenuItemInput | CateringItemUpsertWithWhereUniqueWithoutMenuItemInput[]
    createMany?: CateringItemCreateManyMenuItemInputEnvelope
    set?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
    disconnect?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
    delete?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
    connect?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
    update?: CateringItemUpdateWithWhereUniqueWithoutMenuItemInput | CateringItemUpdateWithWhereUniqueWithoutMenuItemInput[]
    updateMany?: CateringItemUpdateManyWithWhereWithoutMenuItemInput | CateringItemUpdateManyWithWhereWithoutMenuItemInput[]
    deleteMany?: CateringItemScalarWhereInput | CateringItemScalarWhereInput[]
  }

  export type MenuItemCreateNestedOneWithoutVariantsInput = {
    create?: XOR<MenuItemCreateWithoutVariantsInput, MenuItemUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: MenuItemCreateOrConnectWithoutVariantsInput
    connect?: MenuItemWhereUniqueInput
  }

  export type MenuOfferingCreateNestedManyWithoutVariantInput = {
    create?: XOR<MenuOfferingCreateWithoutVariantInput, MenuOfferingUncheckedCreateWithoutVariantInput> | MenuOfferingCreateWithoutVariantInput[] | MenuOfferingUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: MenuOfferingCreateOrConnectWithoutVariantInput | MenuOfferingCreateOrConnectWithoutVariantInput[]
    createMany?: MenuOfferingCreateManyVariantInputEnvelope
    connect?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutVariantInput = {
    create?: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput> | OrderItemCreateWithoutVariantInput[] | OrderItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutVariantInput | OrderItemCreateOrConnectWithoutVariantInput[]
    createMany?: OrderItemCreateManyVariantInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type MenuOfferingUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<MenuOfferingCreateWithoutVariantInput, MenuOfferingUncheckedCreateWithoutVariantInput> | MenuOfferingCreateWithoutVariantInput[] | MenuOfferingUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: MenuOfferingCreateOrConnectWithoutVariantInput | MenuOfferingCreateOrConnectWithoutVariantInput[]
    createMany?: MenuOfferingCreateManyVariantInputEnvelope
    connect?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput> | OrderItemCreateWithoutVariantInput[] | OrderItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutVariantInput | OrderItemCreateOrConnectWithoutVariantInput[]
    createMany?: OrderItemCreateManyVariantInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type MenuItemUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<MenuItemCreateWithoutVariantsInput, MenuItemUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: MenuItemCreateOrConnectWithoutVariantsInput
    upsert?: MenuItemUpsertWithoutVariantsInput
    connect?: MenuItemWhereUniqueInput
    update?: XOR<XOR<MenuItemUpdateToOneWithWhereWithoutVariantsInput, MenuItemUpdateWithoutVariantsInput>, MenuItemUncheckedUpdateWithoutVariantsInput>
  }

  export type MenuOfferingUpdateManyWithoutVariantNestedInput = {
    create?: XOR<MenuOfferingCreateWithoutVariantInput, MenuOfferingUncheckedCreateWithoutVariantInput> | MenuOfferingCreateWithoutVariantInput[] | MenuOfferingUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: MenuOfferingCreateOrConnectWithoutVariantInput | MenuOfferingCreateOrConnectWithoutVariantInput[]
    upsert?: MenuOfferingUpsertWithWhereUniqueWithoutVariantInput | MenuOfferingUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: MenuOfferingCreateManyVariantInputEnvelope
    set?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
    disconnect?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
    delete?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
    connect?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
    update?: MenuOfferingUpdateWithWhereUniqueWithoutVariantInput | MenuOfferingUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: MenuOfferingUpdateManyWithWhereWithoutVariantInput | MenuOfferingUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: MenuOfferingScalarWhereInput | MenuOfferingScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutVariantNestedInput = {
    create?: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput> | OrderItemCreateWithoutVariantInput[] | OrderItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutVariantInput | OrderItemCreateOrConnectWithoutVariantInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutVariantInput | OrderItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: OrderItemCreateManyVariantInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutVariantInput | OrderItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutVariantInput | OrderItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type MenuOfferingUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<MenuOfferingCreateWithoutVariantInput, MenuOfferingUncheckedCreateWithoutVariantInput> | MenuOfferingCreateWithoutVariantInput[] | MenuOfferingUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: MenuOfferingCreateOrConnectWithoutVariantInput | MenuOfferingCreateOrConnectWithoutVariantInput[]
    upsert?: MenuOfferingUpsertWithWhereUniqueWithoutVariantInput | MenuOfferingUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: MenuOfferingCreateManyVariantInputEnvelope
    set?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
    disconnect?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
    delete?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
    connect?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
    update?: MenuOfferingUpdateWithWhereUniqueWithoutVariantInput | MenuOfferingUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: MenuOfferingUpdateManyWithWhereWithoutVariantInput | MenuOfferingUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: MenuOfferingScalarWhereInput | MenuOfferingScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput> | OrderItemCreateWithoutVariantInput[] | OrderItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutVariantInput | OrderItemCreateOrConnectWithoutVariantInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutVariantInput | OrderItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: OrderItemCreateManyVariantInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutVariantInput | OrderItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutVariantInput | OrderItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type MenuItemAddOnCreateNestedManyWithoutAddOnInput = {
    create?: XOR<MenuItemAddOnCreateWithoutAddOnInput, MenuItemAddOnUncheckedCreateWithoutAddOnInput> | MenuItemAddOnCreateWithoutAddOnInput[] | MenuItemAddOnUncheckedCreateWithoutAddOnInput[]
    connectOrCreate?: MenuItemAddOnCreateOrConnectWithoutAddOnInput | MenuItemAddOnCreateOrConnectWithoutAddOnInput[]
    createMany?: MenuItemAddOnCreateManyAddOnInputEnvelope
    connect?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
  }

  export type OrderItemAddOnCreateNestedManyWithoutAddOnInput = {
    create?: XOR<OrderItemAddOnCreateWithoutAddOnInput, OrderItemAddOnUncheckedCreateWithoutAddOnInput> | OrderItemAddOnCreateWithoutAddOnInput[] | OrderItemAddOnUncheckedCreateWithoutAddOnInput[]
    connectOrCreate?: OrderItemAddOnCreateOrConnectWithoutAddOnInput | OrderItemAddOnCreateOrConnectWithoutAddOnInput[]
    createMany?: OrderItemAddOnCreateManyAddOnInputEnvelope
    connect?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
  }

  export type MenuItemAddOnUncheckedCreateNestedManyWithoutAddOnInput = {
    create?: XOR<MenuItemAddOnCreateWithoutAddOnInput, MenuItemAddOnUncheckedCreateWithoutAddOnInput> | MenuItemAddOnCreateWithoutAddOnInput[] | MenuItemAddOnUncheckedCreateWithoutAddOnInput[]
    connectOrCreate?: MenuItemAddOnCreateOrConnectWithoutAddOnInput | MenuItemAddOnCreateOrConnectWithoutAddOnInput[]
    createMany?: MenuItemAddOnCreateManyAddOnInputEnvelope
    connect?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
  }

  export type OrderItemAddOnUncheckedCreateNestedManyWithoutAddOnInput = {
    create?: XOR<OrderItemAddOnCreateWithoutAddOnInput, OrderItemAddOnUncheckedCreateWithoutAddOnInput> | OrderItemAddOnCreateWithoutAddOnInput[] | OrderItemAddOnUncheckedCreateWithoutAddOnInput[]
    connectOrCreate?: OrderItemAddOnCreateOrConnectWithoutAddOnInput | OrderItemAddOnCreateOrConnectWithoutAddOnInput[]
    createMany?: OrderItemAddOnCreateManyAddOnInputEnvelope
    connect?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
  }

  export type MenuItemAddOnUpdateManyWithoutAddOnNestedInput = {
    create?: XOR<MenuItemAddOnCreateWithoutAddOnInput, MenuItemAddOnUncheckedCreateWithoutAddOnInput> | MenuItemAddOnCreateWithoutAddOnInput[] | MenuItemAddOnUncheckedCreateWithoutAddOnInput[]
    connectOrCreate?: MenuItemAddOnCreateOrConnectWithoutAddOnInput | MenuItemAddOnCreateOrConnectWithoutAddOnInput[]
    upsert?: MenuItemAddOnUpsertWithWhereUniqueWithoutAddOnInput | MenuItemAddOnUpsertWithWhereUniqueWithoutAddOnInput[]
    createMany?: MenuItemAddOnCreateManyAddOnInputEnvelope
    set?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
    disconnect?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
    delete?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
    connect?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
    update?: MenuItemAddOnUpdateWithWhereUniqueWithoutAddOnInput | MenuItemAddOnUpdateWithWhereUniqueWithoutAddOnInput[]
    updateMany?: MenuItemAddOnUpdateManyWithWhereWithoutAddOnInput | MenuItemAddOnUpdateManyWithWhereWithoutAddOnInput[]
    deleteMany?: MenuItemAddOnScalarWhereInput | MenuItemAddOnScalarWhereInput[]
  }

  export type OrderItemAddOnUpdateManyWithoutAddOnNestedInput = {
    create?: XOR<OrderItemAddOnCreateWithoutAddOnInput, OrderItemAddOnUncheckedCreateWithoutAddOnInput> | OrderItemAddOnCreateWithoutAddOnInput[] | OrderItemAddOnUncheckedCreateWithoutAddOnInput[]
    connectOrCreate?: OrderItemAddOnCreateOrConnectWithoutAddOnInput | OrderItemAddOnCreateOrConnectWithoutAddOnInput[]
    upsert?: OrderItemAddOnUpsertWithWhereUniqueWithoutAddOnInput | OrderItemAddOnUpsertWithWhereUniqueWithoutAddOnInput[]
    createMany?: OrderItemAddOnCreateManyAddOnInputEnvelope
    set?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
    disconnect?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
    delete?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
    connect?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
    update?: OrderItemAddOnUpdateWithWhereUniqueWithoutAddOnInput | OrderItemAddOnUpdateWithWhereUniqueWithoutAddOnInput[]
    updateMany?: OrderItemAddOnUpdateManyWithWhereWithoutAddOnInput | OrderItemAddOnUpdateManyWithWhereWithoutAddOnInput[]
    deleteMany?: OrderItemAddOnScalarWhereInput | OrderItemAddOnScalarWhereInput[]
  }

  export type MenuItemAddOnUncheckedUpdateManyWithoutAddOnNestedInput = {
    create?: XOR<MenuItemAddOnCreateWithoutAddOnInput, MenuItemAddOnUncheckedCreateWithoutAddOnInput> | MenuItemAddOnCreateWithoutAddOnInput[] | MenuItemAddOnUncheckedCreateWithoutAddOnInput[]
    connectOrCreate?: MenuItemAddOnCreateOrConnectWithoutAddOnInput | MenuItemAddOnCreateOrConnectWithoutAddOnInput[]
    upsert?: MenuItemAddOnUpsertWithWhereUniqueWithoutAddOnInput | MenuItemAddOnUpsertWithWhereUniqueWithoutAddOnInput[]
    createMany?: MenuItemAddOnCreateManyAddOnInputEnvelope
    set?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
    disconnect?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
    delete?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
    connect?: MenuItemAddOnWhereUniqueInput | MenuItemAddOnWhereUniqueInput[]
    update?: MenuItemAddOnUpdateWithWhereUniqueWithoutAddOnInput | MenuItemAddOnUpdateWithWhereUniqueWithoutAddOnInput[]
    updateMany?: MenuItemAddOnUpdateManyWithWhereWithoutAddOnInput | MenuItemAddOnUpdateManyWithWhereWithoutAddOnInput[]
    deleteMany?: MenuItemAddOnScalarWhereInput | MenuItemAddOnScalarWhereInput[]
  }

  export type OrderItemAddOnUncheckedUpdateManyWithoutAddOnNestedInput = {
    create?: XOR<OrderItemAddOnCreateWithoutAddOnInput, OrderItemAddOnUncheckedCreateWithoutAddOnInput> | OrderItemAddOnCreateWithoutAddOnInput[] | OrderItemAddOnUncheckedCreateWithoutAddOnInput[]
    connectOrCreate?: OrderItemAddOnCreateOrConnectWithoutAddOnInput | OrderItemAddOnCreateOrConnectWithoutAddOnInput[]
    upsert?: OrderItemAddOnUpsertWithWhereUniqueWithoutAddOnInput | OrderItemAddOnUpsertWithWhereUniqueWithoutAddOnInput[]
    createMany?: OrderItemAddOnCreateManyAddOnInputEnvelope
    set?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
    disconnect?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
    delete?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
    connect?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
    update?: OrderItemAddOnUpdateWithWhereUniqueWithoutAddOnInput | OrderItemAddOnUpdateWithWhereUniqueWithoutAddOnInput[]
    updateMany?: OrderItemAddOnUpdateManyWithWhereWithoutAddOnInput | OrderItemAddOnUpdateManyWithWhereWithoutAddOnInput[]
    deleteMany?: OrderItemAddOnScalarWhereInput | OrderItemAddOnScalarWhereInput[]
  }

  export type MenuItemCreateNestedOneWithoutAddOnLinksInput = {
    create?: XOR<MenuItemCreateWithoutAddOnLinksInput, MenuItemUncheckedCreateWithoutAddOnLinksInput>
    connectOrCreate?: MenuItemCreateOrConnectWithoutAddOnLinksInput
    connect?: MenuItemWhereUniqueInput
  }

  export type AddOnCreateNestedOneWithoutItemLinksInput = {
    create?: XOR<AddOnCreateWithoutItemLinksInput, AddOnUncheckedCreateWithoutItemLinksInput>
    connectOrCreate?: AddOnCreateOrConnectWithoutItemLinksInput
    connect?: AddOnWhereUniqueInput
  }

  export type MenuItemUpdateOneRequiredWithoutAddOnLinksNestedInput = {
    create?: XOR<MenuItemCreateWithoutAddOnLinksInput, MenuItemUncheckedCreateWithoutAddOnLinksInput>
    connectOrCreate?: MenuItemCreateOrConnectWithoutAddOnLinksInput
    upsert?: MenuItemUpsertWithoutAddOnLinksInput
    connect?: MenuItemWhereUniqueInput
    update?: XOR<XOR<MenuItemUpdateToOneWithWhereWithoutAddOnLinksInput, MenuItemUpdateWithoutAddOnLinksInput>, MenuItemUncheckedUpdateWithoutAddOnLinksInput>
  }

  export type AddOnUpdateOneRequiredWithoutItemLinksNestedInput = {
    create?: XOR<AddOnCreateWithoutItemLinksInput, AddOnUncheckedCreateWithoutItemLinksInput>
    connectOrCreate?: AddOnCreateOrConnectWithoutItemLinksInput
    upsert?: AddOnUpsertWithoutItemLinksInput
    connect?: AddOnWhereUniqueInput
    update?: XOR<XOR<AddOnUpdateToOneWithWhereWithoutItemLinksInput, AddOnUpdateWithoutItemLinksInput>, AddOnUncheckedUpdateWithoutItemLinksInput>
  }

  export type MenuCreateNestedManyWithoutServiceDayInput = {
    create?: XOR<MenuCreateWithoutServiceDayInput, MenuUncheckedCreateWithoutServiceDayInput> | MenuCreateWithoutServiceDayInput[] | MenuUncheckedCreateWithoutServiceDayInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutServiceDayInput | MenuCreateOrConnectWithoutServiceDayInput[]
    createMany?: MenuCreateManyServiceDayInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type ServiceSlotCreateNestedManyWithoutServiceDayInput = {
    create?: XOR<ServiceSlotCreateWithoutServiceDayInput, ServiceSlotUncheckedCreateWithoutServiceDayInput> | ServiceSlotCreateWithoutServiceDayInput[] | ServiceSlotUncheckedCreateWithoutServiceDayInput[]
    connectOrCreate?: ServiceSlotCreateOrConnectWithoutServiceDayInput | ServiceSlotCreateOrConnectWithoutServiceDayInput[]
    createMany?: ServiceSlotCreateManyServiceDayInputEnvelope
    connect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
  }

  export type FulfillmentGroupCreateNestedManyWithoutServiceDayInput = {
    create?: XOR<FulfillmentGroupCreateWithoutServiceDayInput, FulfillmentGroupUncheckedCreateWithoutServiceDayInput> | FulfillmentGroupCreateWithoutServiceDayInput[] | FulfillmentGroupUncheckedCreateWithoutServiceDayInput[]
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutServiceDayInput | FulfillmentGroupCreateOrConnectWithoutServiceDayInput[]
    createMany?: FulfillmentGroupCreateManyServiceDayInputEnvelope
    connect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
  }

  export type MenuUncheckedCreateNestedManyWithoutServiceDayInput = {
    create?: XOR<MenuCreateWithoutServiceDayInput, MenuUncheckedCreateWithoutServiceDayInput> | MenuCreateWithoutServiceDayInput[] | MenuUncheckedCreateWithoutServiceDayInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutServiceDayInput | MenuCreateOrConnectWithoutServiceDayInput[]
    createMany?: MenuCreateManyServiceDayInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type ServiceSlotUncheckedCreateNestedManyWithoutServiceDayInput = {
    create?: XOR<ServiceSlotCreateWithoutServiceDayInput, ServiceSlotUncheckedCreateWithoutServiceDayInput> | ServiceSlotCreateWithoutServiceDayInput[] | ServiceSlotUncheckedCreateWithoutServiceDayInput[]
    connectOrCreate?: ServiceSlotCreateOrConnectWithoutServiceDayInput | ServiceSlotCreateOrConnectWithoutServiceDayInput[]
    createMany?: ServiceSlotCreateManyServiceDayInputEnvelope
    connect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
  }

  export type FulfillmentGroupUncheckedCreateNestedManyWithoutServiceDayInput = {
    create?: XOR<FulfillmentGroupCreateWithoutServiceDayInput, FulfillmentGroupUncheckedCreateWithoutServiceDayInput> | FulfillmentGroupCreateWithoutServiceDayInput[] | FulfillmentGroupUncheckedCreateWithoutServiceDayInput[]
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutServiceDayInput | FulfillmentGroupCreateOrConnectWithoutServiceDayInput[]
    createMany?: FulfillmentGroupCreateManyServiceDayInputEnvelope
    connect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
  }

  export type MenuUpdateManyWithoutServiceDayNestedInput = {
    create?: XOR<MenuCreateWithoutServiceDayInput, MenuUncheckedCreateWithoutServiceDayInput> | MenuCreateWithoutServiceDayInput[] | MenuUncheckedCreateWithoutServiceDayInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutServiceDayInput | MenuCreateOrConnectWithoutServiceDayInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutServiceDayInput | MenuUpsertWithWhereUniqueWithoutServiceDayInput[]
    createMany?: MenuCreateManyServiceDayInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutServiceDayInput | MenuUpdateWithWhereUniqueWithoutServiceDayInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutServiceDayInput | MenuUpdateManyWithWhereWithoutServiceDayInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type ServiceSlotUpdateManyWithoutServiceDayNestedInput = {
    create?: XOR<ServiceSlotCreateWithoutServiceDayInput, ServiceSlotUncheckedCreateWithoutServiceDayInput> | ServiceSlotCreateWithoutServiceDayInput[] | ServiceSlotUncheckedCreateWithoutServiceDayInput[]
    connectOrCreate?: ServiceSlotCreateOrConnectWithoutServiceDayInput | ServiceSlotCreateOrConnectWithoutServiceDayInput[]
    upsert?: ServiceSlotUpsertWithWhereUniqueWithoutServiceDayInput | ServiceSlotUpsertWithWhereUniqueWithoutServiceDayInput[]
    createMany?: ServiceSlotCreateManyServiceDayInputEnvelope
    set?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    disconnect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    delete?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    connect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    update?: ServiceSlotUpdateWithWhereUniqueWithoutServiceDayInput | ServiceSlotUpdateWithWhereUniqueWithoutServiceDayInput[]
    updateMany?: ServiceSlotUpdateManyWithWhereWithoutServiceDayInput | ServiceSlotUpdateManyWithWhereWithoutServiceDayInput[]
    deleteMany?: ServiceSlotScalarWhereInput | ServiceSlotScalarWhereInput[]
  }

  export type FulfillmentGroupUpdateManyWithoutServiceDayNestedInput = {
    create?: XOR<FulfillmentGroupCreateWithoutServiceDayInput, FulfillmentGroupUncheckedCreateWithoutServiceDayInput> | FulfillmentGroupCreateWithoutServiceDayInput[] | FulfillmentGroupUncheckedCreateWithoutServiceDayInput[]
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutServiceDayInput | FulfillmentGroupCreateOrConnectWithoutServiceDayInput[]
    upsert?: FulfillmentGroupUpsertWithWhereUniqueWithoutServiceDayInput | FulfillmentGroupUpsertWithWhereUniqueWithoutServiceDayInput[]
    createMany?: FulfillmentGroupCreateManyServiceDayInputEnvelope
    set?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    disconnect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    delete?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    connect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    update?: FulfillmentGroupUpdateWithWhereUniqueWithoutServiceDayInput | FulfillmentGroupUpdateWithWhereUniqueWithoutServiceDayInput[]
    updateMany?: FulfillmentGroupUpdateManyWithWhereWithoutServiceDayInput | FulfillmentGroupUpdateManyWithWhereWithoutServiceDayInput[]
    deleteMany?: FulfillmentGroupScalarWhereInput | FulfillmentGroupScalarWhereInput[]
  }

  export type MenuUncheckedUpdateManyWithoutServiceDayNestedInput = {
    create?: XOR<MenuCreateWithoutServiceDayInput, MenuUncheckedCreateWithoutServiceDayInput> | MenuCreateWithoutServiceDayInput[] | MenuUncheckedCreateWithoutServiceDayInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutServiceDayInput | MenuCreateOrConnectWithoutServiceDayInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutServiceDayInput | MenuUpsertWithWhereUniqueWithoutServiceDayInput[]
    createMany?: MenuCreateManyServiceDayInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutServiceDayInput | MenuUpdateWithWhereUniqueWithoutServiceDayInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutServiceDayInput | MenuUpdateManyWithWhereWithoutServiceDayInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type ServiceSlotUncheckedUpdateManyWithoutServiceDayNestedInput = {
    create?: XOR<ServiceSlotCreateWithoutServiceDayInput, ServiceSlotUncheckedCreateWithoutServiceDayInput> | ServiceSlotCreateWithoutServiceDayInput[] | ServiceSlotUncheckedCreateWithoutServiceDayInput[]
    connectOrCreate?: ServiceSlotCreateOrConnectWithoutServiceDayInput | ServiceSlotCreateOrConnectWithoutServiceDayInput[]
    upsert?: ServiceSlotUpsertWithWhereUniqueWithoutServiceDayInput | ServiceSlotUpsertWithWhereUniqueWithoutServiceDayInput[]
    createMany?: ServiceSlotCreateManyServiceDayInputEnvelope
    set?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    disconnect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    delete?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    connect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    update?: ServiceSlotUpdateWithWhereUniqueWithoutServiceDayInput | ServiceSlotUpdateWithWhereUniqueWithoutServiceDayInput[]
    updateMany?: ServiceSlotUpdateManyWithWhereWithoutServiceDayInput | ServiceSlotUpdateManyWithWhereWithoutServiceDayInput[]
    deleteMany?: ServiceSlotScalarWhereInput | ServiceSlotScalarWhereInput[]
  }

  export type FulfillmentGroupUncheckedUpdateManyWithoutServiceDayNestedInput = {
    create?: XOR<FulfillmentGroupCreateWithoutServiceDayInput, FulfillmentGroupUncheckedCreateWithoutServiceDayInput> | FulfillmentGroupCreateWithoutServiceDayInput[] | FulfillmentGroupUncheckedCreateWithoutServiceDayInput[]
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutServiceDayInput | FulfillmentGroupCreateOrConnectWithoutServiceDayInput[]
    upsert?: FulfillmentGroupUpsertWithWhereUniqueWithoutServiceDayInput | FulfillmentGroupUpsertWithWhereUniqueWithoutServiceDayInput[]
    createMany?: FulfillmentGroupCreateManyServiceDayInputEnvelope
    set?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    disconnect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    delete?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    connect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    update?: FulfillmentGroupUpdateWithWhereUniqueWithoutServiceDayInput | FulfillmentGroupUpdateWithWhereUniqueWithoutServiceDayInput[]
    updateMany?: FulfillmentGroupUpdateManyWithWhereWithoutServiceDayInput | FulfillmentGroupUpdateManyWithWhereWithoutServiceDayInput[]
    deleteMany?: FulfillmentGroupScalarWhereInput | FulfillmentGroupScalarWhereInput[]
  }

  export type ServiceDayCreateNestedOneWithoutMenusInput = {
    create?: XOR<ServiceDayCreateWithoutMenusInput, ServiceDayUncheckedCreateWithoutMenusInput>
    connectOrCreate?: ServiceDayCreateOrConnectWithoutMenusInput
    connect?: ServiceDayWhereUniqueInput
  }

  export type MenuOfferingCreateNestedManyWithoutMenuInput = {
    create?: XOR<MenuOfferingCreateWithoutMenuInput, MenuOfferingUncheckedCreateWithoutMenuInput> | MenuOfferingCreateWithoutMenuInput[] | MenuOfferingUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuOfferingCreateOrConnectWithoutMenuInput | MenuOfferingCreateOrConnectWithoutMenuInput[]
    createMany?: MenuOfferingCreateManyMenuInputEnvelope
    connect?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
  }

  export type MenuOfferingUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<MenuOfferingCreateWithoutMenuInput, MenuOfferingUncheckedCreateWithoutMenuInput> | MenuOfferingCreateWithoutMenuInput[] | MenuOfferingUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuOfferingCreateOrConnectWithoutMenuInput | MenuOfferingCreateOrConnectWithoutMenuInput[]
    createMany?: MenuOfferingCreateManyMenuInputEnvelope
    connect?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
  }

  export type EnumMenuTypeFieldUpdateOperationsInput = {
    set?: $Enums.MenuType
  }

  export type ServiceDayUpdateOneRequiredWithoutMenusNestedInput = {
    create?: XOR<ServiceDayCreateWithoutMenusInput, ServiceDayUncheckedCreateWithoutMenusInput>
    connectOrCreate?: ServiceDayCreateOrConnectWithoutMenusInput
    upsert?: ServiceDayUpsertWithoutMenusInput
    connect?: ServiceDayWhereUniqueInput
    update?: XOR<XOR<ServiceDayUpdateToOneWithWhereWithoutMenusInput, ServiceDayUpdateWithoutMenusInput>, ServiceDayUncheckedUpdateWithoutMenusInput>
  }

  export type MenuOfferingUpdateManyWithoutMenuNestedInput = {
    create?: XOR<MenuOfferingCreateWithoutMenuInput, MenuOfferingUncheckedCreateWithoutMenuInput> | MenuOfferingCreateWithoutMenuInput[] | MenuOfferingUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuOfferingCreateOrConnectWithoutMenuInput | MenuOfferingCreateOrConnectWithoutMenuInput[]
    upsert?: MenuOfferingUpsertWithWhereUniqueWithoutMenuInput | MenuOfferingUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: MenuOfferingCreateManyMenuInputEnvelope
    set?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
    disconnect?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
    delete?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
    connect?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
    update?: MenuOfferingUpdateWithWhereUniqueWithoutMenuInput | MenuOfferingUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: MenuOfferingUpdateManyWithWhereWithoutMenuInput | MenuOfferingUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: MenuOfferingScalarWhereInput | MenuOfferingScalarWhereInput[]
  }

  export type MenuOfferingUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<MenuOfferingCreateWithoutMenuInput, MenuOfferingUncheckedCreateWithoutMenuInput> | MenuOfferingCreateWithoutMenuInput[] | MenuOfferingUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuOfferingCreateOrConnectWithoutMenuInput | MenuOfferingCreateOrConnectWithoutMenuInput[]
    upsert?: MenuOfferingUpsertWithWhereUniqueWithoutMenuInput | MenuOfferingUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: MenuOfferingCreateManyMenuInputEnvelope
    set?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
    disconnect?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
    delete?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
    connect?: MenuOfferingWhereUniqueInput | MenuOfferingWhereUniqueInput[]
    update?: MenuOfferingUpdateWithWhereUniqueWithoutMenuInput | MenuOfferingUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: MenuOfferingUpdateManyWithWhereWithoutMenuInput | MenuOfferingUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: MenuOfferingScalarWhereInput | MenuOfferingScalarWhereInput[]
  }

  export type MenuCreateNestedOneWithoutOfferingsInput = {
    create?: XOR<MenuCreateWithoutOfferingsInput, MenuUncheckedCreateWithoutOfferingsInput>
    connectOrCreate?: MenuCreateOrConnectWithoutOfferingsInput
    connect?: MenuWhereUniqueInput
  }

  export type MenuVariantCreateNestedOneWithoutOfferingsInput = {
    create?: XOR<MenuVariantCreateWithoutOfferingsInput, MenuVariantUncheckedCreateWithoutOfferingsInput>
    connectOrCreate?: MenuVariantCreateOrConnectWithoutOfferingsInput
    connect?: MenuVariantWhereUniqueInput
  }

  export type CapacityHoldCreateNestedManyWithoutOfferingInput = {
    create?: XOR<CapacityHoldCreateWithoutOfferingInput, CapacityHoldUncheckedCreateWithoutOfferingInput> | CapacityHoldCreateWithoutOfferingInput[] | CapacityHoldUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: CapacityHoldCreateOrConnectWithoutOfferingInput | CapacityHoldCreateOrConnectWithoutOfferingInput[]
    createMany?: CapacityHoldCreateManyOfferingInputEnvelope
    connect?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
  }

  export type CapacityHoldUncheckedCreateNestedManyWithoutOfferingInput = {
    create?: XOR<CapacityHoldCreateWithoutOfferingInput, CapacityHoldUncheckedCreateWithoutOfferingInput> | CapacityHoldCreateWithoutOfferingInput[] | CapacityHoldUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: CapacityHoldCreateOrConnectWithoutOfferingInput | CapacityHoldCreateOrConnectWithoutOfferingInput[]
    createMany?: CapacityHoldCreateManyOfferingInputEnvelope
    connect?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
  }

  export type MenuUpdateOneRequiredWithoutOfferingsNestedInput = {
    create?: XOR<MenuCreateWithoutOfferingsInput, MenuUncheckedCreateWithoutOfferingsInput>
    connectOrCreate?: MenuCreateOrConnectWithoutOfferingsInput
    upsert?: MenuUpsertWithoutOfferingsInput
    connect?: MenuWhereUniqueInput
    update?: XOR<XOR<MenuUpdateToOneWithWhereWithoutOfferingsInput, MenuUpdateWithoutOfferingsInput>, MenuUncheckedUpdateWithoutOfferingsInput>
  }

  export type MenuVariantUpdateOneRequiredWithoutOfferingsNestedInput = {
    create?: XOR<MenuVariantCreateWithoutOfferingsInput, MenuVariantUncheckedCreateWithoutOfferingsInput>
    connectOrCreate?: MenuVariantCreateOrConnectWithoutOfferingsInput
    upsert?: MenuVariantUpsertWithoutOfferingsInput
    connect?: MenuVariantWhereUniqueInput
    update?: XOR<XOR<MenuVariantUpdateToOneWithWhereWithoutOfferingsInput, MenuVariantUpdateWithoutOfferingsInput>, MenuVariantUncheckedUpdateWithoutOfferingsInput>
  }

  export type CapacityHoldUpdateManyWithoutOfferingNestedInput = {
    create?: XOR<CapacityHoldCreateWithoutOfferingInput, CapacityHoldUncheckedCreateWithoutOfferingInput> | CapacityHoldCreateWithoutOfferingInput[] | CapacityHoldUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: CapacityHoldCreateOrConnectWithoutOfferingInput | CapacityHoldCreateOrConnectWithoutOfferingInput[]
    upsert?: CapacityHoldUpsertWithWhereUniqueWithoutOfferingInput | CapacityHoldUpsertWithWhereUniqueWithoutOfferingInput[]
    createMany?: CapacityHoldCreateManyOfferingInputEnvelope
    set?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
    disconnect?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
    delete?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
    connect?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
    update?: CapacityHoldUpdateWithWhereUniqueWithoutOfferingInput | CapacityHoldUpdateWithWhereUniqueWithoutOfferingInput[]
    updateMany?: CapacityHoldUpdateManyWithWhereWithoutOfferingInput | CapacityHoldUpdateManyWithWhereWithoutOfferingInput[]
    deleteMany?: CapacityHoldScalarWhereInput | CapacityHoldScalarWhereInput[]
  }

  export type CapacityHoldUncheckedUpdateManyWithoutOfferingNestedInput = {
    create?: XOR<CapacityHoldCreateWithoutOfferingInput, CapacityHoldUncheckedCreateWithoutOfferingInput> | CapacityHoldCreateWithoutOfferingInput[] | CapacityHoldUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: CapacityHoldCreateOrConnectWithoutOfferingInput | CapacityHoldCreateOrConnectWithoutOfferingInput[]
    upsert?: CapacityHoldUpsertWithWhereUniqueWithoutOfferingInput | CapacityHoldUpsertWithWhereUniqueWithoutOfferingInput[]
    createMany?: CapacityHoldCreateManyOfferingInputEnvelope
    set?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
    disconnect?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
    delete?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
    connect?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
    update?: CapacityHoldUpdateWithWhereUniqueWithoutOfferingInput | CapacityHoldUpdateWithWhereUniqueWithoutOfferingInput[]
    updateMany?: CapacityHoldUpdateManyWithWhereWithoutOfferingInput | CapacityHoldUpdateManyWithWhereWithoutOfferingInput[]
    deleteMany?: CapacityHoldScalarWhereInput | CapacityHoldScalarWhereInput[]
  }

  export type ServiceSlotCreateNestedManyWithoutPickupLocationInput = {
    create?: XOR<ServiceSlotCreateWithoutPickupLocationInput, ServiceSlotUncheckedCreateWithoutPickupLocationInput> | ServiceSlotCreateWithoutPickupLocationInput[] | ServiceSlotUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: ServiceSlotCreateOrConnectWithoutPickupLocationInput | ServiceSlotCreateOrConnectWithoutPickupLocationInput[]
    createMany?: ServiceSlotCreateManyPickupLocationInputEnvelope
    connect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutPickupLocationInput = {
    create?: XOR<OrderCreateWithoutPickupLocationInput, OrderUncheckedCreateWithoutPickupLocationInput> | OrderCreateWithoutPickupLocationInput[] | OrderUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPickupLocationInput | OrderCreateOrConnectWithoutPickupLocationInput[]
    createMany?: OrderCreateManyPickupLocationInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ServiceSlotUncheckedCreateNestedManyWithoutPickupLocationInput = {
    create?: XOR<ServiceSlotCreateWithoutPickupLocationInput, ServiceSlotUncheckedCreateWithoutPickupLocationInput> | ServiceSlotCreateWithoutPickupLocationInput[] | ServiceSlotUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: ServiceSlotCreateOrConnectWithoutPickupLocationInput | ServiceSlotCreateOrConnectWithoutPickupLocationInput[]
    createMany?: ServiceSlotCreateManyPickupLocationInputEnvelope
    connect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutPickupLocationInput = {
    create?: XOR<OrderCreateWithoutPickupLocationInput, OrderUncheckedCreateWithoutPickupLocationInput> | OrderCreateWithoutPickupLocationInput[] | OrderUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPickupLocationInput | OrderCreateOrConnectWithoutPickupLocationInput[]
    createMany?: OrderCreateManyPickupLocationInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ServiceSlotUpdateManyWithoutPickupLocationNestedInput = {
    create?: XOR<ServiceSlotCreateWithoutPickupLocationInput, ServiceSlotUncheckedCreateWithoutPickupLocationInput> | ServiceSlotCreateWithoutPickupLocationInput[] | ServiceSlotUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: ServiceSlotCreateOrConnectWithoutPickupLocationInput | ServiceSlotCreateOrConnectWithoutPickupLocationInput[]
    upsert?: ServiceSlotUpsertWithWhereUniqueWithoutPickupLocationInput | ServiceSlotUpsertWithWhereUniqueWithoutPickupLocationInput[]
    createMany?: ServiceSlotCreateManyPickupLocationInputEnvelope
    set?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    disconnect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    delete?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    connect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    update?: ServiceSlotUpdateWithWhereUniqueWithoutPickupLocationInput | ServiceSlotUpdateWithWhereUniqueWithoutPickupLocationInput[]
    updateMany?: ServiceSlotUpdateManyWithWhereWithoutPickupLocationInput | ServiceSlotUpdateManyWithWhereWithoutPickupLocationInput[]
    deleteMany?: ServiceSlotScalarWhereInput | ServiceSlotScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutPickupLocationNestedInput = {
    create?: XOR<OrderCreateWithoutPickupLocationInput, OrderUncheckedCreateWithoutPickupLocationInput> | OrderCreateWithoutPickupLocationInput[] | OrderUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPickupLocationInput | OrderCreateOrConnectWithoutPickupLocationInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutPickupLocationInput | OrderUpsertWithWhereUniqueWithoutPickupLocationInput[]
    createMany?: OrderCreateManyPickupLocationInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutPickupLocationInput | OrderUpdateWithWhereUniqueWithoutPickupLocationInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutPickupLocationInput | OrderUpdateManyWithWhereWithoutPickupLocationInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ServiceSlotUncheckedUpdateManyWithoutPickupLocationNestedInput = {
    create?: XOR<ServiceSlotCreateWithoutPickupLocationInput, ServiceSlotUncheckedCreateWithoutPickupLocationInput> | ServiceSlotCreateWithoutPickupLocationInput[] | ServiceSlotUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: ServiceSlotCreateOrConnectWithoutPickupLocationInput | ServiceSlotCreateOrConnectWithoutPickupLocationInput[]
    upsert?: ServiceSlotUpsertWithWhereUniqueWithoutPickupLocationInput | ServiceSlotUpsertWithWhereUniqueWithoutPickupLocationInput[]
    createMany?: ServiceSlotCreateManyPickupLocationInputEnvelope
    set?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    disconnect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    delete?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    connect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    update?: ServiceSlotUpdateWithWhereUniqueWithoutPickupLocationInput | ServiceSlotUpdateWithWhereUniqueWithoutPickupLocationInput[]
    updateMany?: ServiceSlotUpdateManyWithWhereWithoutPickupLocationInput | ServiceSlotUpdateManyWithWhereWithoutPickupLocationInput[]
    deleteMany?: ServiceSlotScalarWhereInput | ServiceSlotScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutPickupLocationNestedInput = {
    create?: XOR<OrderCreateWithoutPickupLocationInput, OrderUncheckedCreateWithoutPickupLocationInput> | OrderCreateWithoutPickupLocationInput[] | OrderUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPickupLocationInput | OrderCreateOrConnectWithoutPickupLocationInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutPickupLocationInput | OrderUpsertWithWhereUniqueWithoutPickupLocationInput[]
    createMany?: OrderCreateManyPickupLocationInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutPickupLocationInput | OrderUpdateWithWhereUniqueWithoutPickupLocationInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutPickupLocationInput | OrderUpdateManyWithWhereWithoutPickupLocationInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAddressesInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutDeliveryAddressInput = {
    create?: XOR<OrderCreateWithoutDeliveryAddressInput, OrderUncheckedCreateWithoutDeliveryAddressInput> | OrderCreateWithoutDeliveryAddressInput[] | OrderUncheckedCreateWithoutDeliveryAddressInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryAddressInput | OrderCreateOrConnectWithoutDeliveryAddressInput[]
    createMany?: OrderCreateManyDeliveryAddressInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutDeliveryAddressInput = {
    create?: XOR<OrderCreateWithoutDeliveryAddressInput, OrderUncheckedCreateWithoutDeliveryAddressInput> | OrderCreateWithoutDeliveryAddressInput[] | OrderUncheckedCreateWithoutDeliveryAddressInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryAddressInput | OrderCreateOrConnectWithoutDeliveryAddressInput[]
    createMany?: OrderCreateManyDeliveryAddressInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutAddressesNestedInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput
    upsert?: UserUpsertWithoutAddressesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddressesInput, UserUpdateWithoutAddressesInput>, UserUncheckedUpdateWithoutAddressesInput>
  }

  export type OrderUpdateManyWithoutDeliveryAddressNestedInput = {
    create?: XOR<OrderCreateWithoutDeliveryAddressInput, OrderUncheckedCreateWithoutDeliveryAddressInput> | OrderCreateWithoutDeliveryAddressInput[] | OrderUncheckedCreateWithoutDeliveryAddressInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryAddressInput | OrderCreateOrConnectWithoutDeliveryAddressInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutDeliveryAddressInput | OrderUpsertWithWhereUniqueWithoutDeliveryAddressInput[]
    createMany?: OrderCreateManyDeliveryAddressInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutDeliveryAddressInput | OrderUpdateWithWhereUniqueWithoutDeliveryAddressInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutDeliveryAddressInput | OrderUpdateManyWithWhereWithoutDeliveryAddressInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutDeliveryAddressNestedInput = {
    create?: XOR<OrderCreateWithoutDeliveryAddressInput, OrderUncheckedCreateWithoutDeliveryAddressInput> | OrderCreateWithoutDeliveryAddressInput[] | OrderUncheckedCreateWithoutDeliveryAddressInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryAddressInput | OrderCreateOrConnectWithoutDeliveryAddressInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutDeliveryAddressInput | OrderUpsertWithWhereUniqueWithoutDeliveryAddressInput[]
    createMany?: OrderCreateManyDeliveryAddressInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutDeliveryAddressInput | OrderUpdateWithWhereUniqueWithoutDeliveryAddressInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutDeliveryAddressInput | OrderUpdateManyWithWhereWithoutDeliveryAddressInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ServiceSlotCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ServiceSlotCreateWithoutTemplateInput, ServiceSlotUncheckedCreateWithoutTemplateInput> | ServiceSlotCreateWithoutTemplateInput[] | ServiceSlotUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ServiceSlotCreateOrConnectWithoutTemplateInput | ServiceSlotCreateOrConnectWithoutTemplateInput[]
    createMany?: ServiceSlotCreateManyTemplateInputEnvelope
    connect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
  }

  export type ServiceSlotUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ServiceSlotCreateWithoutTemplateInput, ServiceSlotUncheckedCreateWithoutTemplateInput> | ServiceSlotCreateWithoutTemplateInput[] | ServiceSlotUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ServiceSlotCreateOrConnectWithoutTemplateInput | ServiceSlotCreateOrConnectWithoutTemplateInput[]
    createMany?: ServiceSlotCreateManyTemplateInputEnvelope
    connect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
  }

  export type ServiceSlotUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ServiceSlotCreateWithoutTemplateInput, ServiceSlotUncheckedCreateWithoutTemplateInput> | ServiceSlotCreateWithoutTemplateInput[] | ServiceSlotUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ServiceSlotCreateOrConnectWithoutTemplateInput | ServiceSlotCreateOrConnectWithoutTemplateInput[]
    upsert?: ServiceSlotUpsertWithWhereUniqueWithoutTemplateInput | ServiceSlotUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ServiceSlotCreateManyTemplateInputEnvelope
    set?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    disconnect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    delete?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    connect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    update?: ServiceSlotUpdateWithWhereUniqueWithoutTemplateInput | ServiceSlotUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ServiceSlotUpdateManyWithWhereWithoutTemplateInput | ServiceSlotUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ServiceSlotScalarWhereInput | ServiceSlotScalarWhereInput[]
  }

  export type ServiceSlotUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ServiceSlotCreateWithoutTemplateInput, ServiceSlotUncheckedCreateWithoutTemplateInput> | ServiceSlotCreateWithoutTemplateInput[] | ServiceSlotUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ServiceSlotCreateOrConnectWithoutTemplateInput | ServiceSlotCreateOrConnectWithoutTemplateInput[]
    upsert?: ServiceSlotUpsertWithWhereUniqueWithoutTemplateInput | ServiceSlotUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ServiceSlotCreateManyTemplateInputEnvelope
    set?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    disconnect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    delete?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    connect?: ServiceSlotWhereUniqueInput | ServiceSlotWhereUniqueInput[]
    update?: ServiceSlotUpdateWithWhereUniqueWithoutTemplateInput | ServiceSlotUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ServiceSlotUpdateManyWithWhereWithoutTemplateInput | ServiceSlotUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ServiceSlotScalarWhereInput | ServiceSlotScalarWhereInput[]
  }

  export type ServiceDayCreateNestedOneWithoutSlotsInput = {
    create?: XOR<ServiceDayCreateWithoutSlotsInput, ServiceDayUncheckedCreateWithoutSlotsInput>
    connectOrCreate?: ServiceDayCreateOrConnectWithoutSlotsInput
    connect?: ServiceDayWhereUniqueInput
  }

  export type SlotTemplateCreateNestedOneWithoutServiceSlotsInput = {
    create?: XOR<SlotTemplateCreateWithoutServiceSlotsInput, SlotTemplateUncheckedCreateWithoutServiceSlotsInput>
    connectOrCreate?: SlotTemplateCreateOrConnectWithoutServiceSlotsInput
    connect?: SlotTemplateWhereUniqueInput
  }

  export type PickupLocationCreateNestedOneWithoutServiceSlotsInput = {
    create?: XOR<PickupLocationCreateWithoutServiceSlotsInput, PickupLocationUncheckedCreateWithoutServiceSlotsInput>
    connectOrCreate?: PickupLocationCreateOrConnectWithoutServiceSlotsInput
    connect?: PickupLocationWhereUniqueInput
  }

  export type FulfillmentGroupCreateNestedManyWithoutServiceSlotInput = {
    create?: XOR<FulfillmentGroupCreateWithoutServiceSlotInput, FulfillmentGroupUncheckedCreateWithoutServiceSlotInput> | FulfillmentGroupCreateWithoutServiceSlotInput[] | FulfillmentGroupUncheckedCreateWithoutServiceSlotInput[]
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutServiceSlotInput | FulfillmentGroupCreateOrConnectWithoutServiceSlotInput[]
    createMany?: FulfillmentGroupCreateManyServiceSlotInputEnvelope
    connect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
  }

  export type FulfillmentGroupUncheckedCreateNestedManyWithoutServiceSlotInput = {
    create?: XOR<FulfillmentGroupCreateWithoutServiceSlotInput, FulfillmentGroupUncheckedCreateWithoutServiceSlotInput> | FulfillmentGroupCreateWithoutServiceSlotInput[] | FulfillmentGroupUncheckedCreateWithoutServiceSlotInput[]
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutServiceSlotInput | FulfillmentGroupCreateOrConnectWithoutServiceSlotInput[]
    createMany?: FulfillmentGroupCreateManyServiceSlotInputEnvelope
    connect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
  }

  export type EnumFulfillmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.FulfillmentType
  }

  export type ServiceDayUpdateOneRequiredWithoutSlotsNestedInput = {
    create?: XOR<ServiceDayCreateWithoutSlotsInput, ServiceDayUncheckedCreateWithoutSlotsInput>
    connectOrCreate?: ServiceDayCreateOrConnectWithoutSlotsInput
    upsert?: ServiceDayUpsertWithoutSlotsInput
    connect?: ServiceDayWhereUniqueInput
    update?: XOR<XOR<ServiceDayUpdateToOneWithWhereWithoutSlotsInput, ServiceDayUpdateWithoutSlotsInput>, ServiceDayUncheckedUpdateWithoutSlotsInput>
  }

  export type SlotTemplateUpdateOneRequiredWithoutServiceSlotsNestedInput = {
    create?: XOR<SlotTemplateCreateWithoutServiceSlotsInput, SlotTemplateUncheckedCreateWithoutServiceSlotsInput>
    connectOrCreate?: SlotTemplateCreateOrConnectWithoutServiceSlotsInput
    upsert?: SlotTemplateUpsertWithoutServiceSlotsInput
    connect?: SlotTemplateWhereUniqueInput
    update?: XOR<XOR<SlotTemplateUpdateToOneWithWhereWithoutServiceSlotsInput, SlotTemplateUpdateWithoutServiceSlotsInput>, SlotTemplateUncheckedUpdateWithoutServiceSlotsInput>
  }

  export type PickupLocationUpdateOneWithoutServiceSlotsNestedInput = {
    create?: XOR<PickupLocationCreateWithoutServiceSlotsInput, PickupLocationUncheckedCreateWithoutServiceSlotsInput>
    connectOrCreate?: PickupLocationCreateOrConnectWithoutServiceSlotsInput
    upsert?: PickupLocationUpsertWithoutServiceSlotsInput
    disconnect?: PickupLocationWhereInput | boolean
    delete?: PickupLocationWhereInput | boolean
    connect?: PickupLocationWhereUniqueInput
    update?: XOR<XOR<PickupLocationUpdateToOneWithWhereWithoutServiceSlotsInput, PickupLocationUpdateWithoutServiceSlotsInput>, PickupLocationUncheckedUpdateWithoutServiceSlotsInput>
  }

  export type FulfillmentGroupUpdateManyWithoutServiceSlotNestedInput = {
    create?: XOR<FulfillmentGroupCreateWithoutServiceSlotInput, FulfillmentGroupUncheckedCreateWithoutServiceSlotInput> | FulfillmentGroupCreateWithoutServiceSlotInput[] | FulfillmentGroupUncheckedCreateWithoutServiceSlotInput[]
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutServiceSlotInput | FulfillmentGroupCreateOrConnectWithoutServiceSlotInput[]
    upsert?: FulfillmentGroupUpsertWithWhereUniqueWithoutServiceSlotInput | FulfillmentGroupUpsertWithWhereUniqueWithoutServiceSlotInput[]
    createMany?: FulfillmentGroupCreateManyServiceSlotInputEnvelope
    set?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    disconnect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    delete?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    connect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    update?: FulfillmentGroupUpdateWithWhereUniqueWithoutServiceSlotInput | FulfillmentGroupUpdateWithWhereUniqueWithoutServiceSlotInput[]
    updateMany?: FulfillmentGroupUpdateManyWithWhereWithoutServiceSlotInput | FulfillmentGroupUpdateManyWithWhereWithoutServiceSlotInput[]
    deleteMany?: FulfillmentGroupScalarWhereInput | FulfillmentGroupScalarWhereInput[]
  }

  export type FulfillmentGroupUncheckedUpdateManyWithoutServiceSlotNestedInput = {
    create?: XOR<FulfillmentGroupCreateWithoutServiceSlotInput, FulfillmentGroupUncheckedCreateWithoutServiceSlotInput> | FulfillmentGroupCreateWithoutServiceSlotInput[] | FulfillmentGroupUncheckedCreateWithoutServiceSlotInput[]
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutServiceSlotInput | FulfillmentGroupCreateOrConnectWithoutServiceSlotInput[]
    upsert?: FulfillmentGroupUpsertWithWhereUniqueWithoutServiceSlotInput | FulfillmentGroupUpsertWithWhereUniqueWithoutServiceSlotInput[]
    createMany?: FulfillmentGroupCreateManyServiceSlotInputEnvelope
    set?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    disconnect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    delete?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    connect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    update?: FulfillmentGroupUpdateWithWhereUniqueWithoutServiceSlotInput | FulfillmentGroupUpdateWithWhereUniqueWithoutServiceSlotInput[]
    updateMany?: FulfillmentGroupUpdateManyWithWhereWithoutServiceSlotInput | FulfillmentGroupUpdateManyWithWhereWithoutServiceSlotInput[]
    deleteMany?: FulfillmentGroupScalarWhereInput | FulfillmentGroupScalarWhereInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumDeliveryPricingModeFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryPricingMode
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedOrdersInput = {
    create?: XOR<UserCreateWithoutCreatedOrdersInput, UserUncheckedCreateWithoutCreatedOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type PickupLocationCreateNestedOneWithoutOrdersInput = {
    create?: XOR<PickupLocationCreateWithoutOrdersInput, PickupLocationUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PickupLocationCreateOrConnectWithoutOrdersInput
    connect?: PickupLocationWhereUniqueInput
  }

  export type AddressCreateNestedOneWithoutDeliveryOrdersInput = {
    create?: XOR<AddressCreateWithoutDeliveryOrdersInput, AddressUncheckedCreateWithoutDeliveryOrdersInput>
    connectOrCreate?: AddressCreateOrConnectWithoutDeliveryOrdersInput
    connect?: AddressWhereUniqueInput
  }

  export type FulfillmentGroupCreateNestedManyWithoutOrderInput = {
    create?: XOR<FulfillmentGroupCreateWithoutOrderInput, FulfillmentGroupUncheckedCreateWithoutOrderInput> | FulfillmentGroupCreateWithoutOrderInput[] | FulfillmentGroupUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutOrderInput | FulfillmentGroupCreateOrConnectWithoutOrderInput[]
    createMany?: FulfillmentGroupCreateManyOrderInputEnvelope
    connect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderAdjustmentCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderAdjustmentCreateWithoutOrderInput, OrderAdjustmentUncheckedCreateWithoutOrderInput> | OrderAdjustmentCreateWithoutOrderInput[] | OrderAdjustmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderAdjustmentCreateOrConnectWithoutOrderInput | OrderAdjustmentCreateOrConnectWithoutOrderInput[]
    createMany?: OrderAdjustmentCreateManyOrderInputEnvelope
    connect?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type OrderEventCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderEventCreateWithoutOrderInput, OrderEventUncheckedCreateWithoutOrderInput> | OrderEventCreateWithoutOrderInput[] | OrderEventUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderEventCreateOrConnectWithoutOrderInput | OrderEventCreateOrConnectWithoutOrderInput[]
    createMany?: OrderEventCreateManyOrderInputEnvelope
    connect?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
  }

  export type PromotionRedemptionCreateNestedManyWithoutOrderInput = {
    create?: XOR<PromotionRedemptionCreateWithoutOrderInput, PromotionRedemptionUncheckedCreateWithoutOrderInput> | PromotionRedemptionCreateWithoutOrderInput[] | PromotionRedemptionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutOrderInput | PromotionRedemptionCreateOrConnectWithoutOrderInput[]
    createMany?: PromotionRedemptionCreateManyOrderInputEnvelope
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
  }

  export type CapacityHoldCreateNestedManyWithoutOrderInput = {
    create?: XOR<CapacityHoldCreateWithoutOrderInput, CapacityHoldUncheckedCreateWithoutOrderInput> | CapacityHoldCreateWithoutOrderInput[] | CapacityHoldUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CapacityHoldCreateOrConnectWithoutOrderInput | CapacityHoldCreateOrConnectWithoutOrderInput[]
    createMany?: CapacityHoldCreateManyOrderInputEnvelope
    connect?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
  }

  export type RewardTransactionCreateNestedManyWithoutOrderInput = {
    create?: XOR<RewardTransactionCreateWithoutOrderInput, RewardTransactionUncheckedCreateWithoutOrderInput> | RewardTransactionCreateWithoutOrderInput[] | RewardTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RewardTransactionCreateOrConnectWithoutOrderInput | RewardTransactionCreateOrConnectWithoutOrderInput[]
    createMany?: RewardTransactionCreateManyOrderInputEnvelope
    connect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutOrderInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput> | ReviewCreateWithoutOrderInput[] | ReviewUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput | ReviewCreateOrConnectWithoutOrderInput[]
    createMany?: ReviewCreateManyOrderInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type FulfillmentGroupUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<FulfillmentGroupCreateWithoutOrderInput, FulfillmentGroupUncheckedCreateWithoutOrderInput> | FulfillmentGroupCreateWithoutOrderInput[] | FulfillmentGroupUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutOrderInput | FulfillmentGroupCreateOrConnectWithoutOrderInput[]
    createMany?: FulfillmentGroupCreateManyOrderInputEnvelope
    connect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderAdjustmentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderAdjustmentCreateWithoutOrderInput, OrderAdjustmentUncheckedCreateWithoutOrderInput> | OrderAdjustmentCreateWithoutOrderInput[] | OrderAdjustmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderAdjustmentCreateOrConnectWithoutOrderInput | OrderAdjustmentCreateOrConnectWithoutOrderInput[]
    createMany?: OrderAdjustmentCreateManyOrderInputEnvelope
    connect?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type OrderEventUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderEventCreateWithoutOrderInput, OrderEventUncheckedCreateWithoutOrderInput> | OrderEventCreateWithoutOrderInput[] | OrderEventUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderEventCreateOrConnectWithoutOrderInput | OrderEventCreateOrConnectWithoutOrderInput[]
    createMany?: OrderEventCreateManyOrderInputEnvelope
    connect?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
  }

  export type PromotionRedemptionUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PromotionRedemptionCreateWithoutOrderInput, PromotionRedemptionUncheckedCreateWithoutOrderInput> | PromotionRedemptionCreateWithoutOrderInput[] | PromotionRedemptionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutOrderInput | PromotionRedemptionCreateOrConnectWithoutOrderInput[]
    createMany?: PromotionRedemptionCreateManyOrderInputEnvelope
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
  }

  export type CapacityHoldUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<CapacityHoldCreateWithoutOrderInput, CapacityHoldUncheckedCreateWithoutOrderInput> | CapacityHoldCreateWithoutOrderInput[] | CapacityHoldUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CapacityHoldCreateOrConnectWithoutOrderInput | CapacityHoldCreateOrConnectWithoutOrderInput[]
    createMany?: CapacityHoldCreateManyOrderInputEnvelope
    connect?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
  }

  export type RewardTransactionUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<RewardTransactionCreateWithoutOrderInput, RewardTransactionUncheckedCreateWithoutOrderInput> | RewardTransactionCreateWithoutOrderInput[] | RewardTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RewardTransactionCreateOrConnectWithoutOrderInput | RewardTransactionCreateOrConnectWithoutOrderInput[]
    createMany?: RewardTransactionCreateManyOrderInputEnvelope
    connect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput> | ReviewCreateWithoutOrderInput[] | ReviewUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput | ReviewCreateOrConnectWithoutOrderInput[]
    createMany?: ReviewCreateManyOrderInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type EnumOrderSourceFieldUpdateOperationsInput = {
    set?: $Enums.OrderSource
  }

  export type EnumOrderCheckoutStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderCheckoutStatus
  }

  export type NullableEnumFulfillmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.FulfillmentType | null
  }

  export type UserUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateOneWithoutCreatedOrdersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedOrdersInput, UserUncheckedCreateWithoutCreatedOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedOrdersInput
    upsert?: UserUpsertWithoutCreatedOrdersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedOrdersInput, UserUpdateWithoutCreatedOrdersInput>, UserUncheckedUpdateWithoutCreatedOrdersInput>
  }

  export type PickupLocationUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<PickupLocationCreateWithoutOrdersInput, PickupLocationUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PickupLocationCreateOrConnectWithoutOrdersInput
    upsert?: PickupLocationUpsertWithoutOrdersInput
    disconnect?: PickupLocationWhereInput | boolean
    delete?: PickupLocationWhereInput | boolean
    connect?: PickupLocationWhereUniqueInput
    update?: XOR<XOR<PickupLocationUpdateToOneWithWhereWithoutOrdersInput, PickupLocationUpdateWithoutOrdersInput>, PickupLocationUncheckedUpdateWithoutOrdersInput>
  }

  export type AddressUpdateOneWithoutDeliveryOrdersNestedInput = {
    create?: XOR<AddressCreateWithoutDeliveryOrdersInput, AddressUncheckedCreateWithoutDeliveryOrdersInput>
    connectOrCreate?: AddressCreateOrConnectWithoutDeliveryOrdersInput
    upsert?: AddressUpsertWithoutDeliveryOrdersInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutDeliveryOrdersInput, AddressUpdateWithoutDeliveryOrdersInput>, AddressUncheckedUpdateWithoutDeliveryOrdersInput>
  }

  export type FulfillmentGroupUpdateManyWithoutOrderNestedInput = {
    create?: XOR<FulfillmentGroupCreateWithoutOrderInput, FulfillmentGroupUncheckedCreateWithoutOrderInput> | FulfillmentGroupCreateWithoutOrderInput[] | FulfillmentGroupUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutOrderInput | FulfillmentGroupCreateOrConnectWithoutOrderInput[]
    upsert?: FulfillmentGroupUpsertWithWhereUniqueWithoutOrderInput | FulfillmentGroupUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: FulfillmentGroupCreateManyOrderInputEnvelope
    set?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    disconnect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    delete?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    connect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    update?: FulfillmentGroupUpdateWithWhereUniqueWithoutOrderInput | FulfillmentGroupUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: FulfillmentGroupUpdateManyWithWhereWithoutOrderInput | FulfillmentGroupUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: FulfillmentGroupScalarWhereInput | FulfillmentGroupScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderAdjustmentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderAdjustmentCreateWithoutOrderInput, OrderAdjustmentUncheckedCreateWithoutOrderInput> | OrderAdjustmentCreateWithoutOrderInput[] | OrderAdjustmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderAdjustmentCreateOrConnectWithoutOrderInput | OrderAdjustmentCreateOrConnectWithoutOrderInput[]
    upsert?: OrderAdjustmentUpsertWithWhereUniqueWithoutOrderInput | OrderAdjustmentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderAdjustmentCreateManyOrderInputEnvelope
    set?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
    disconnect?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
    delete?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
    connect?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
    update?: OrderAdjustmentUpdateWithWhereUniqueWithoutOrderInput | OrderAdjustmentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderAdjustmentUpdateManyWithWhereWithoutOrderInput | OrderAdjustmentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderAdjustmentScalarWhereInput | OrderAdjustmentScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type OrderEventUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderEventCreateWithoutOrderInput, OrderEventUncheckedCreateWithoutOrderInput> | OrderEventCreateWithoutOrderInput[] | OrderEventUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderEventCreateOrConnectWithoutOrderInput | OrderEventCreateOrConnectWithoutOrderInput[]
    upsert?: OrderEventUpsertWithWhereUniqueWithoutOrderInput | OrderEventUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderEventCreateManyOrderInputEnvelope
    set?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
    disconnect?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
    delete?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
    connect?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
    update?: OrderEventUpdateWithWhereUniqueWithoutOrderInput | OrderEventUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderEventUpdateManyWithWhereWithoutOrderInput | OrderEventUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderEventScalarWhereInput | OrderEventScalarWhereInput[]
  }

  export type PromotionRedemptionUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PromotionRedemptionCreateWithoutOrderInput, PromotionRedemptionUncheckedCreateWithoutOrderInput> | PromotionRedemptionCreateWithoutOrderInput[] | PromotionRedemptionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutOrderInput | PromotionRedemptionCreateOrConnectWithoutOrderInput[]
    upsert?: PromotionRedemptionUpsertWithWhereUniqueWithoutOrderInput | PromotionRedemptionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PromotionRedemptionCreateManyOrderInputEnvelope
    set?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    disconnect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    delete?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    update?: PromotionRedemptionUpdateWithWhereUniqueWithoutOrderInput | PromotionRedemptionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PromotionRedemptionUpdateManyWithWhereWithoutOrderInput | PromotionRedemptionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
  }

  export type CapacityHoldUpdateManyWithoutOrderNestedInput = {
    create?: XOR<CapacityHoldCreateWithoutOrderInput, CapacityHoldUncheckedCreateWithoutOrderInput> | CapacityHoldCreateWithoutOrderInput[] | CapacityHoldUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CapacityHoldCreateOrConnectWithoutOrderInput | CapacityHoldCreateOrConnectWithoutOrderInput[]
    upsert?: CapacityHoldUpsertWithWhereUniqueWithoutOrderInput | CapacityHoldUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: CapacityHoldCreateManyOrderInputEnvelope
    set?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
    disconnect?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
    delete?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
    connect?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
    update?: CapacityHoldUpdateWithWhereUniqueWithoutOrderInput | CapacityHoldUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: CapacityHoldUpdateManyWithWhereWithoutOrderInput | CapacityHoldUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: CapacityHoldScalarWhereInput | CapacityHoldScalarWhereInput[]
  }

  export type RewardTransactionUpdateManyWithoutOrderNestedInput = {
    create?: XOR<RewardTransactionCreateWithoutOrderInput, RewardTransactionUncheckedCreateWithoutOrderInput> | RewardTransactionCreateWithoutOrderInput[] | RewardTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RewardTransactionCreateOrConnectWithoutOrderInput | RewardTransactionCreateOrConnectWithoutOrderInput[]
    upsert?: RewardTransactionUpsertWithWhereUniqueWithoutOrderInput | RewardTransactionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: RewardTransactionCreateManyOrderInputEnvelope
    set?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    disconnect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    delete?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    connect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    update?: RewardTransactionUpdateWithWhereUniqueWithoutOrderInput | RewardTransactionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: RewardTransactionUpdateManyWithWhereWithoutOrderInput | RewardTransactionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: RewardTransactionScalarWhereInput | RewardTransactionScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput> | ReviewCreateWithoutOrderInput[] | ReviewUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput | ReviewCreateOrConnectWithoutOrderInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutOrderInput | ReviewUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ReviewCreateManyOrderInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutOrderInput | ReviewUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutOrderInput | ReviewUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type FulfillmentGroupUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<FulfillmentGroupCreateWithoutOrderInput, FulfillmentGroupUncheckedCreateWithoutOrderInput> | FulfillmentGroupCreateWithoutOrderInput[] | FulfillmentGroupUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutOrderInput | FulfillmentGroupCreateOrConnectWithoutOrderInput[]
    upsert?: FulfillmentGroupUpsertWithWhereUniqueWithoutOrderInput | FulfillmentGroupUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: FulfillmentGroupCreateManyOrderInputEnvelope
    set?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    disconnect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    delete?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    connect?: FulfillmentGroupWhereUniqueInput | FulfillmentGroupWhereUniqueInput[]
    update?: FulfillmentGroupUpdateWithWhereUniqueWithoutOrderInput | FulfillmentGroupUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: FulfillmentGroupUpdateManyWithWhereWithoutOrderInput | FulfillmentGroupUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: FulfillmentGroupScalarWhereInput | FulfillmentGroupScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderAdjustmentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderAdjustmentCreateWithoutOrderInput, OrderAdjustmentUncheckedCreateWithoutOrderInput> | OrderAdjustmentCreateWithoutOrderInput[] | OrderAdjustmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderAdjustmentCreateOrConnectWithoutOrderInput | OrderAdjustmentCreateOrConnectWithoutOrderInput[]
    upsert?: OrderAdjustmentUpsertWithWhereUniqueWithoutOrderInput | OrderAdjustmentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderAdjustmentCreateManyOrderInputEnvelope
    set?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
    disconnect?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
    delete?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
    connect?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
    update?: OrderAdjustmentUpdateWithWhereUniqueWithoutOrderInput | OrderAdjustmentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderAdjustmentUpdateManyWithWhereWithoutOrderInput | OrderAdjustmentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderAdjustmentScalarWhereInput | OrderAdjustmentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type OrderEventUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderEventCreateWithoutOrderInput, OrderEventUncheckedCreateWithoutOrderInput> | OrderEventCreateWithoutOrderInput[] | OrderEventUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderEventCreateOrConnectWithoutOrderInput | OrderEventCreateOrConnectWithoutOrderInput[]
    upsert?: OrderEventUpsertWithWhereUniqueWithoutOrderInput | OrderEventUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderEventCreateManyOrderInputEnvelope
    set?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
    disconnect?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
    delete?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
    connect?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
    update?: OrderEventUpdateWithWhereUniqueWithoutOrderInput | OrderEventUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderEventUpdateManyWithWhereWithoutOrderInput | OrderEventUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderEventScalarWhereInput | OrderEventScalarWhereInput[]
  }

  export type PromotionRedemptionUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PromotionRedemptionCreateWithoutOrderInput, PromotionRedemptionUncheckedCreateWithoutOrderInput> | PromotionRedemptionCreateWithoutOrderInput[] | PromotionRedemptionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutOrderInput | PromotionRedemptionCreateOrConnectWithoutOrderInput[]
    upsert?: PromotionRedemptionUpsertWithWhereUniqueWithoutOrderInput | PromotionRedemptionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PromotionRedemptionCreateManyOrderInputEnvelope
    set?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    disconnect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    delete?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    update?: PromotionRedemptionUpdateWithWhereUniqueWithoutOrderInput | PromotionRedemptionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PromotionRedemptionUpdateManyWithWhereWithoutOrderInput | PromotionRedemptionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
  }

  export type CapacityHoldUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<CapacityHoldCreateWithoutOrderInput, CapacityHoldUncheckedCreateWithoutOrderInput> | CapacityHoldCreateWithoutOrderInput[] | CapacityHoldUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CapacityHoldCreateOrConnectWithoutOrderInput | CapacityHoldCreateOrConnectWithoutOrderInput[]
    upsert?: CapacityHoldUpsertWithWhereUniqueWithoutOrderInput | CapacityHoldUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: CapacityHoldCreateManyOrderInputEnvelope
    set?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
    disconnect?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
    delete?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
    connect?: CapacityHoldWhereUniqueInput | CapacityHoldWhereUniqueInput[]
    update?: CapacityHoldUpdateWithWhereUniqueWithoutOrderInput | CapacityHoldUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: CapacityHoldUpdateManyWithWhereWithoutOrderInput | CapacityHoldUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: CapacityHoldScalarWhereInput | CapacityHoldScalarWhereInput[]
  }

  export type RewardTransactionUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<RewardTransactionCreateWithoutOrderInput, RewardTransactionUncheckedCreateWithoutOrderInput> | RewardTransactionCreateWithoutOrderInput[] | RewardTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RewardTransactionCreateOrConnectWithoutOrderInput | RewardTransactionCreateOrConnectWithoutOrderInput[]
    upsert?: RewardTransactionUpsertWithWhereUniqueWithoutOrderInput | RewardTransactionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: RewardTransactionCreateManyOrderInputEnvelope
    set?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    disconnect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    delete?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    connect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    update?: RewardTransactionUpdateWithWhereUniqueWithoutOrderInput | RewardTransactionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: RewardTransactionUpdateManyWithWhereWithoutOrderInput | RewardTransactionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: RewardTransactionScalarWhereInput | RewardTransactionScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput> | ReviewCreateWithoutOrderInput[] | ReviewUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput | ReviewCreateOrConnectWithoutOrderInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutOrderInput | ReviewUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ReviewCreateManyOrderInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutOrderInput | ReviewUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutOrderInput | ReviewUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutGroupsInput = {
    create?: XOR<OrderCreateWithoutGroupsInput, OrderUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutGroupsInput
    connect?: OrderWhereUniqueInput
  }

  export type ServiceDayCreateNestedOneWithoutGroupsInput = {
    create?: XOR<ServiceDayCreateWithoutGroupsInput, ServiceDayUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: ServiceDayCreateOrConnectWithoutGroupsInput
    connect?: ServiceDayWhereUniqueInput
  }

  export type ServiceSlotCreateNestedOneWithoutGroupsInput = {
    create?: XOR<ServiceSlotCreateWithoutGroupsInput, ServiceSlotUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: ServiceSlotCreateOrConnectWithoutGroupsInput
    connect?: ServiceSlotWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutGroupInput = {
    create?: XOR<OrderItemCreateWithoutGroupInput, OrderItemUncheckedCreateWithoutGroupInput> | OrderItemCreateWithoutGroupInput[] | OrderItemUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutGroupInput | OrderItemCreateOrConnectWithoutGroupInput[]
    createMany?: OrderItemCreateManyGroupInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderAdjustmentCreateNestedManyWithoutGroupInput = {
    create?: XOR<OrderAdjustmentCreateWithoutGroupInput, OrderAdjustmentUncheckedCreateWithoutGroupInput> | OrderAdjustmentCreateWithoutGroupInput[] | OrderAdjustmentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: OrderAdjustmentCreateOrConnectWithoutGroupInput | OrderAdjustmentCreateOrConnectWithoutGroupInput[]
    createMany?: OrderAdjustmentCreateManyGroupInputEnvelope
    connect?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
  }

  export type OrderEventCreateNestedManyWithoutGroupInput = {
    create?: XOR<OrderEventCreateWithoutGroupInput, OrderEventUncheckedCreateWithoutGroupInput> | OrderEventCreateWithoutGroupInput[] | OrderEventUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: OrderEventCreateOrConnectWithoutGroupInput | OrderEventCreateOrConnectWithoutGroupInput[]
    createMany?: OrderEventCreateManyGroupInputEnvelope
    connect?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<OrderItemCreateWithoutGroupInput, OrderItemUncheckedCreateWithoutGroupInput> | OrderItemCreateWithoutGroupInput[] | OrderItemUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutGroupInput | OrderItemCreateOrConnectWithoutGroupInput[]
    createMany?: OrderItemCreateManyGroupInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderAdjustmentUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<OrderAdjustmentCreateWithoutGroupInput, OrderAdjustmentUncheckedCreateWithoutGroupInput> | OrderAdjustmentCreateWithoutGroupInput[] | OrderAdjustmentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: OrderAdjustmentCreateOrConnectWithoutGroupInput | OrderAdjustmentCreateOrConnectWithoutGroupInput[]
    createMany?: OrderAdjustmentCreateManyGroupInputEnvelope
    connect?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
  }

  export type OrderEventUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<OrderEventCreateWithoutGroupInput, OrderEventUncheckedCreateWithoutGroupInput> | OrderEventCreateWithoutGroupInput[] | OrderEventUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: OrderEventCreateOrConnectWithoutGroupInput | OrderEventCreateOrConnectWithoutGroupInput[]
    createMany?: OrderEventCreateManyGroupInputEnvelope
    connect?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
  }

  export type EnumFulfillmentGroupStatusFieldUpdateOperationsInput = {
    set?: $Enums.FulfillmentGroupStatus
  }

  export type OrderUpdateOneRequiredWithoutGroupsNestedInput = {
    create?: XOR<OrderCreateWithoutGroupsInput, OrderUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutGroupsInput
    upsert?: OrderUpsertWithoutGroupsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutGroupsInput, OrderUpdateWithoutGroupsInput>, OrderUncheckedUpdateWithoutGroupsInput>
  }

  export type ServiceDayUpdateOneRequiredWithoutGroupsNestedInput = {
    create?: XOR<ServiceDayCreateWithoutGroupsInput, ServiceDayUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: ServiceDayCreateOrConnectWithoutGroupsInput
    upsert?: ServiceDayUpsertWithoutGroupsInput
    connect?: ServiceDayWhereUniqueInput
    update?: XOR<XOR<ServiceDayUpdateToOneWithWhereWithoutGroupsInput, ServiceDayUpdateWithoutGroupsInput>, ServiceDayUncheckedUpdateWithoutGroupsInput>
  }

  export type ServiceSlotUpdateOneWithoutGroupsNestedInput = {
    create?: XOR<ServiceSlotCreateWithoutGroupsInput, ServiceSlotUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: ServiceSlotCreateOrConnectWithoutGroupsInput
    upsert?: ServiceSlotUpsertWithoutGroupsInput
    disconnect?: ServiceSlotWhereInput | boolean
    delete?: ServiceSlotWhereInput | boolean
    connect?: ServiceSlotWhereUniqueInput
    update?: XOR<XOR<ServiceSlotUpdateToOneWithWhereWithoutGroupsInput, ServiceSlotUpdateWithoutGroupsInput>, ServiceSlotUncheckedUpdateWithoutGroupsInput>
  }

  export type OrderItemUpdateManyWithoutGroupNestedInput = {
    create?: XOR<OrderItemCreateWithoutGroupInput, OrderItemUncheckedCreateWithoutGroupInput> | OrderItemCreateWithoutGroupInput[] | OrderItemUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutGroupInput | OrderItemCreateOrConnectWithoutGroupInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutGroupInput | OrderItemUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: OrderItemCreateManyGroupInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutGroupInput | OrderItemUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutGroupInput | OrderItemUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderAdjustmentUpdateManyWithoutGroupNestedInput = {
    create?: XOR<OrderAdjustmentCreateWithoutGroupInput, OrderAdjustmentUncheckedCreateWithoutGroupInput> | OrderAdjustmentCreateWithoutGroupInput[] | OrderAdjustmentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: OrderAdjustmentCreateOrConnectWithoutGroupInput | OrderAdjustmentCreateOrConnectWithoutGroupInput[]
    upsert?: OrderAdjustmentUpsertWithWhereUniqueWithoutGroupInput | OrderAdjustmentUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: OrderAdjustmentCreateManyGroupInputEnvelope
    set?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
    disconnect?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
    delete?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
    connect?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
    update?: OrderAdjustmentUpdateWithWhereUniqueWithoutGroupInput | OrderAdjustmentUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: OrderAdjustmentUpdateManyWithWhereWithoutGroupInput | OrderAdjustmentUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: OrderAdjustmentScalarWhereInput | OrderAdjustmentScalarWhereInput[]
  }

  export type OrderEventUpdateManyWithoutGroupNestedInput = {
    create?: XOR<OrderEventCreateWithoutGroupInput, OrderEventUncheckedCreateWithoutGroupInput> | OrderEventCreateWithoutGroupInput[] | OrderEventUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: OrderEventCreateOrConnectWithoutGroupInput | OrderEventCreateOrConnectWithoutGroupInput[]
    upsert?: OrderEventUpsertWithWhereUniqueWithoutGroupInput | OrderEventUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: OrderEventCreateManyGroupInputEnvelope
    set?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
    disconnect?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
    delete?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
    connect?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
    update?: OrderEventUpdateWithWhereUniqueWithoutGroupInput | OrderEventUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: OrderEventUpdateManyWithWhereWithoutGroupInput | OrderEventUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: OrderEventScalarWhereInput | OrderEventScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<OrderItemCreateWithoutGroupInput, OrderItemUncheckedCreateWithoutGroupInput> | OrderItemCreateWithoutGroupInput[] | OrderItemUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutGroupInput | OrderItemCreateOrConnectWithoutGroupInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutGroupInput | OrderItemUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: OrderItemCreateManyGroupInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutGroupInput | OrderItemUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutGroupInput | OrderItemUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderAdjustmentUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<OrderAdjustmentCreateWithoutGroupInput, OrderAdjustmentUncheckedCreateWithoutGroupInput> | OrderAdjustmentCreateWithoutGroupInput[] | OrderAdjustmentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: OrderAdjustmentCreateOrConnectWithoutGroupInput | OrderAdjustmentCreateOrConnectWithoutGroupInput[]
    upsert?: OrderAdjustmentUpsertWithWhereUniqueWithoutGroupInput | OrderAdjustmentUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: OrderAdjustmentCreateManyGroupInputEnvelope
    set?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
    disconnect?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
    delete?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
    connect?: OrderAdjustmentWhereUniqueInput | OrderAdjustmentWhereUniqueInput[]
    update?: OrderAdjustmentUpdateWithWhereUniqueWithoutGroupInput | OrderAdjustmentUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: OrderAdjustmentUpdateManyWithWhereWithoutGroupInput | OrderAdjustmentUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: OrderAdjustmentScalarWhereInput | OrderAdjustmentScalarWhereInput[]
  }

  export type OrderEventUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<OrderEventCreateWithoutGroupInput, OrderEventUncheckedCreateWithoutGroupInput> | OrderEventCreateWithoutGroupInput[] | OrderEventUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: OrderEventCreateOrConnectWithoutGroupInput | OrderEventCreateOrConnectWithoutGroupInput[]
    upsert?: OrderEventUpsertWithWhereUniqueWithoutGroupInput | OrderEventUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: OrderEventCreateManyGroupInputEnvelope
    set?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
    disconnect?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
    delete?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
    connect?: OrderEventWhereUniqueInput | OrderEventWhereUniqueInput[]
    update?: OrderEventUpdateWithWhereUniqueWithoutGroupInput | OrderEventUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: OrderEventUpdateManyWithWhereWithoutGroupInput | OrderEventUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: OrderEventScalarWhereInput | OrderEventScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type FulfillmentGroupCreateNestedOneWithoutItemsInput = {
    create?: XOR<FulfillmentGroupCreateWithoutItemsInput, FulfillmentGroupUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutItemsInput
    connect?: FulfillmentGroupWhereUniqueInput
  }

  export type MenuVariantCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<MenuVariantCreateWithoutOrderItemsInput, MenuVariantUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: MenuVariantCreateOrConnectWithoutOrderItemsInput
    connect?: MenuVariantWhereUniqueInput
  }

  export type OrderItemAddOnCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<OrderItemAddOnCreateWithoutOrderItemInput, OrderItemAddOnUncheckedCreateWithoutOrderItemInput> | OrderItemAddOnCreateWithoutOrderItemInput[] | OrderItemAddOnUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: OrderItemAddOnCreateOrConnectWithoutOrderItemInput | OrderItemAddOnCreateOrConnectWithoutOrderItemInput[]
    createMany?: OrderItemAddOnCreateManyOrderItemInputEnvelope
    connect?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
  }

  export type OrderItemAddOnUncheckedCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<OrderItemAddOnCreateWithoutOrderItemInput, OrderItemAddOnUncheckedCreateWithoutOrderItemInput> | OrderItemAddOnCreateWithoutOrderItemInput[] | OrderItemAddOnUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: OrderItemAddOnCreateOrConnectWithoutOrderItemInput | OrderItemAddOnCreateOrConnectWithoutOrderItemInput[]
    createMany?: OrderItemAddOnCreateManyOrderItemInputEnvelope
    connect?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type FulfillmentGroupUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<FulfillmentGroupCreateWithoutItemsInput, FulfillmentGroupUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutItemsInput
    upsert?: FulfillmentGroupUpsertWithoutItemsInput
    connect?: FulfillmentGroupWhereUniqueInput
    update?: XOR<XOR<FulfillmentGroupUpdateToOneWithWhereWithoutItemsInput, FulfillmentGroupUpdateWithoutItemsInput>, FulfillmentGroupUncheckedUpdateWithoutItemsInput>
  }

  export type MenuVariantUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<MenuVariantCreateWithoutOrderItemsInput, MenuVariantUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: MenuVariantCreateOrConnectWithoutOrderItemsInput
    upsert?: MenuVariantUpsertWithoutOrderItemsInput
    connect?: MenuVariantWhereUniqueInput
    update?: XOR<XOR<MenuVariantUpdateToOneWithWhereWithoutOrderItemsInput, MenuVariantUpdateWithoutOrderItemsInput>, MenuVariantUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderItemAddOnUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<OrderItemAddOnCreateWithoutOrderItemInput, OrderItemAddOnUncheckedCreateWithoutOrderItemInput> | OrderItemAddOnCreateWithoutOrderItemInput[] | OrderItemAddOnUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: OrderItemAddOnCreateOrConnectWithoutOrderItemInput | OrderItemAddOnCreateOrConnectWithoutOrderItemInput[]
    upsert?: OrderItemAddOnUpsertWithWhereUniqueWithoutOrderItemInput | OrderItemAddOnUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: OrderItemAddOnCreateManyOrderItemInputEnvelope
    set?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
    disconnect?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
    delete?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
    connect?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
    update?: OrderItemAddOnUpdateWithWhereUniqueWithoutOrderItemInput | OrderItemAddOnUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: OrderItemAddOnUpdateManyWithWhereWithoutOrderItemInput | OrderItemAddOnUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: OrderItemAddOnScalarWhereInput | OrderItemAddOnScalarWhereInput[]
  }

  export type OrderItemAddOnUncheckedUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<OrderItemAddOnCreateWithoutOrderItemInput, OrderItemAddOnUncheckedCreateWithoutOrderItemInput> | OrderItemAddOnCreateWithoutOrderItemInput[] | OrderItemAddOnUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: OrderItemAddOnCreateOrConnectWithoutOrderItemInput | OrderItemAddOnCreateOrConnectWithoutOrderItemInput[]
    upsert?: OrderItemAddOnUpsertWithWhereUniqueWithoutOrderItemInput | OrderItemAddOnUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: OrderItemAddOnCreateManyOrderItemInputEnvelope
    set?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
    disconnect?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
    delete?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
    connect?: OrderItemAddOnWhereUniqueInput | OrderItemAddOnWhereUniqueInput[]
    update?: OrderItemAddOnUpdateWithWhereUniqueWithoutOrderItemInput | OrderItemAddOnUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: OrderItemAddOnUpdateManyWithWhereWithoutOrderItemInput | OrderItemAddOnUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: OrderItemAddOnScalarWhereInput | OrderItemAddOnScalarWhereInput[]
  }

  export type OrderItemCreateNestedOneWithoutAddOnsInput = {
    create?: XOR<OrderItemCreateWithoutAddOnsInput, OrderItemUncheckedCreateWithoutAddOnsInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutAddOnsInput
    connect?: OrderItemWhereUniqueInput
  }

  export type AddOnCreateNestedOneWithoutOrderLinksInput = {
    create?: XOR<AddOnCreateWithoutOrderLinksInput, AddOnUncheckedCreateWithoutOrderLinksInput>
    connectOrCreate?: AddOnCreateOrConnectWithoutOrderLinksInput
    connect?: AddOnWhereUniqueInput
  }

  export type OrderItemUpdateOneRequiredWithoutAddOnsNestedInput = {
    create?: XOR<OrderItemCreateWithoutAddOnsInput, OrderItemUncheckedCreateWithoutAddOnsInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutAddOnsInput
    upsert?: OrderItemUpsertWithoutAddOnsInput
    connect?: OrderItemWhereUniqueInput
    update?: XOR<XOR<OrderItemUpdateToOneWithWhereWithoutAddOnsInput, OrderItemUpdateWithoutAddOnsInput>, OrderItemUncheckedUpdateWithoutAddOnsInput>
  }

  export type AddOnUpdateOneWithoutOrderLinksNestedInput = {
    create?: XOR<AddOnCreateWithoutOrderLinksInput, AddOnUncheckedCreateWithoutOrderLinksInput>
    connectOrCreate?: AddOnCreateOrConnectWithoutOrderLinksInput
    upsert?: AddOnUpsertWithoutOrderLinksInput
    disconnect?: AddOnWhereInput | boolean
    delete?: AddOnWhereInput | boolean
    connect?: AddOnWhereUniqueInput
    update?: XOR<XOR<AddOnUpdateToOneWithWhereWithoutOrderLinksInput, AddOnUpdateWithoutOrderLinksInput>, AddOnUncheckedUpdateWithoutOrderLinksInput>
  }

  export type OrderCreateNestedOneWithoutAdjustmentsInput = {
    create?: XOR<OrderCreateWithoutAdjustmentsInput, OrderUncheckedCreateWithoutAdjustmentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutAdjustmentsInput
    connect?: OrderWhereUniqueInput
  }

  export type FulfillmentGroupCreateNestedOneWithoutAdjustmentsInput = {
    create?: XOR<FulfillmentGroupCreateWithoutAdjustmentsInput, FulfillmentGroupUncheckedCreateWithoutAdjustmentsInput>
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutAdjustmentsInput
    connect?: FulfillmentGroupWhereUniqueInput
  }

  export type EnumAdjustmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AdjustmentType
  }

  export type OrderUpdateOneRequiredWithoutAdjustmentsNestedInput = {
    create?: XOR<OrderCreateWithoutAdjustmentsInput, OrderUncheckedCreateWithoutAdjustmentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutAdjustmentsInput
    upsert?: OrderUpsertWithoutAdjustmentsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutAdjustmentsInput, OrderUpdateWithoutAdjustmentsInput>, OrderUncheckedUpdateWithoutAdjustmentsInput>
  }

  export type FulfillmentGroupUpdateOneWithoutAdjustmentsNestedInput = {
    create?: XOR<FulfillmentGroupCreateWithoutAdjustmentsInput, FulfillmentGroupUncheckedCreateWithoutAdjustmentsInput>
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutAdjustmentsInput
    upsert?: FulfillmentGroupUpsertWithoutAdjustmentsInput
    disconnect?: FulfillmentGroupWhereInput | boolean
    delete?: FulfillmentGroupWhereInput | boolean
    connect?: FulfillmentGroupWhereUniqueInput
    update?: XOR<XOR<FulfillmentGroupUpdateToOneWithWhereWithoutAdjustmentsInput, FulfillmentGroupUpdateWithoutAdjustmentsInput>, FulfillmentGroupUncheckedUpdateWithoutAdjustmentsInput>
  }

  export type OrderCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentsReceivedInput = {
    create?: XOR<UserCreateWithoutPaymentsReceivedInput, UserUncheckedCreateWithoutPaymentsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPaymentProviderFieldUpdateOperationsInput = {
    set?: $Enums.PaymentProvider
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type OrderUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    upsert?: OrderUpsertWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentsInput, OrderUpdateWithoutPaymentsInput>, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneWithoutPaymentsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsReceivedInput, UserUncheckedCreateWithoutPaymentsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsReceivedInput
    upsert?: UserUpsertWithoutPaymentsReceivedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsReceivedInput, UserUpdateWithoutPaymentsReceivedInput>, UserUncheckedUpdateWithoutPaymentsReceivedInput>
  }

  export type OrderCreateNestedOneWithoutEventsInput = {
    create?: XOR<OrderCreateWithoutEventsInput, OrderUncheckedCreateWithoutEventsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutEventsInput
    connect?: OrderWhereUniqueInput
  }

  export type FulfillmentGroupCreateNestedOneWithoutEventsInput = {
    create?: XOR<FulfillmentGroupCreateWithoutEventsInput, FulfillmentGroupUncheckedCreateWithoutEventsInput>
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutEventsInput
    connect?: FulfillmentGroupWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<OrderCreateWithoutEventsInput, OrderUncheckedCreateWithoutEventsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutEventsInput
    upsert?: OrderUpsertWithoutEventsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutEventsInput, OrderUpdateWithoutEventsInput>, OrderUncheckedUpdateWithoutEventsInput>
  }

  export type FulfillmentGroupUpdateOneWithoutEventsNestedInput = {
    create?: XOR<FulfillmentGroupCreateWithoutEventsInput, FulfillmentGroupUncheckedCreateWithoutEventsInput>
    connectOrCreate?: FulfillmentGroupCreateOrConnectWithoutEventsInput
    upsert?: FulfillmentGroupUpsertWithoutEventsInput
    disconnect?: FulfillmentGroupWhereInput | boolean
    delete?: FulfillmentGroupWhereInput | boolean
    connect?: FulfillmentGroupWhereUniqueInput
    update?: XOR<XOR<FulfillmentGroupUpdateToOneWithWhereWithoutEventsInput, FulfillmentGroupUpdateWithoutEventsInput>, FulfillmentGroupUncheckedUpdateWithoutEventsInput>
  }

  export type MenuOfferingCreateNestedOneWithoutHoldsInput = {
    create?: XOR<MenuOfferingCreateWithoutHoldsInput, MenuOfferingUncheckedCreateWithoutHoldsInput>
    connectOrCreate?: MenuOfferingCreateOrConnectWithoutHoldsInput
    connect?: MenuOfferingWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutCapacityHoldsInput = {
    create?: XOR<OrderCreateWithoutCapacityHoldsInput, OrderUncheckedCreateWithoutCapacityHoldsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCapacityHoldsInput
    connect?: OrderWhereUniqueInput
  }

  export type EnumHoldStatusFieldUpdateOperationsInput = {
    set?: $Enums.HoldStatus
  }

  export type MenuOfferingUpdateOneRequiredWithoutHoldsNestedInput = {
    create?: XOR<MenuOfferingCreateWithoutHoldsInput, MenuOfferingUncheckedCreateWithoutHoldsInput>
    connectOrCreate?: MenuOfferingCreateOrConnectWithoutHoldsInput
    upsert?: MenuOfferingUpsertWithoutHoldsInput
    connect?: MenuOfferingWhereUniqueInput
    update?: XOR<XOR<MenuOfferingUpdateToOneWithWhereWithoutHoldsInput, MenuOfferingUpdateWithoutHoldsInput>, MenuOfferingUncheckedUpdateWithoutHoldsInput>
  }

  export type OrderUpdateOneWithoutCapacityHoldsNestedInput = {
    create?: XOR<OrderCreateWithoutCapacityHoldsInput, OrderUncheckedCreateWithoutCapacityHoldsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCapacityHoldsInput
    upsert?: OrderUpsertWithoutCapacityHoldsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutCapacityHoldsInput, OrderUpdateWithoutCapacityHoldsInput>, OrderUncheckedUpdateWithoutCapacityHoldsInput>
  }

  export type PromotionRedemptionCreateNestedManyWithoutPromotionInput = {
    create?: XOR<PromotionRedemptionCreateWithoutPromotionInput, PromotionRedemptionUncheckedCreateWithoutPromotionInput> | PromotionRedemptionCreateWithoutPromotionInput[] | PromotionRedemptionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutPromotionInput | PromotionRedemptionCreateOrConnectWithoutPromotionInput[]
    createMany?: PromotionRedemptionCreateManyPromotionInputEnvelope
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
  }

  export type PromotionRedemptionUncheckedCreateNestedManyWithoutPromotionInput = {
    create?: XOR<PromotionRedemptionCreateWithoutPromotionInput, PromotionRedemptionUncheckedCreateWithoutPromotionInput> | PromotionRedemptionCreateWithoutPromotionInput[] | PromotionRedemptionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutPromotionInput | PromotionRedemptionCreateOrConnectWithoutPromotionInput[]
    createMany?: PromotionRedemptionCreateManyPromotionInputEnvelope
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
  }

  export type EnumPromotionTypeFieldUpdateOperationsInput = {
    set?: $Enums.PromotionType
  }

  export type PromotionRedemptionUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<PromotionRedemptionCreateWithoutPromotionInput, PromotionRedemptionUncheckedCreateWithoutPromotionInput> | PromotionRedemptionCreateWithoutPromotionInput[] | PromotionRedemptionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutPromotionInput | PromotionRedemptionCreateOrConnectWithoutPromotionInput[]
    upsert?: PromotionRedemptionUpsertWithWhereUniqueWithoutPromotionInput | PromotionRedemptionUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: PromotionRedemptionCreateManyPromotionInputEnvelope
    set?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    disconnect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    delete?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    update?: PromotionRedemptionUpdateWithWhereUniqueWithoutPromotionInput | PromotionRedemptionUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: PromotionRedemptionUpdateManyWithWhereWithoutPromotionInput | PromotionRedemptionUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
  }

  export type PromotionRedemptionUncheckedUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<PromotionRedemptionCreateWithoutPromotionInput, PromotionRedemptionUncheckedCreateWithoutPromotionInput> | PromotionRedemptionCreateWithoutPromotionInput[] | PromotionRedemptionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutPromotionInput | PromotionRedemptionCreateOrConnectWithoutPromotionInput[]
    upsert?: PromotionRedemptionUpsertWithWhereUniqueWithoutPromotionInput | PromotionRedemptionUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: PromotionRedemptionCreateManyPromotionInputEnvelope
    set?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    disconnect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    delete?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    update?: PromotionRedemptionUpdateWithWhereUniqueWithoutPromotionInput | PromotionRedemptionUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: PromotionRedemptionUpdateManyWithWhereWithoutPromotionInput | PromotionRedemptionUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
  }

  export type PromotionCreateNestedOneWithoutRedemptionsInput = {
    create?: XOR<PromotionCreateWithoutRedemptionsInput, PromotionUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutRedemptionsInput
    connect?: PromotionWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutPromoRedemptionsInput = {
    create?: XOR<OrderCreateWithoutPromoRedemptionsInput, OrderUncheckedCreateWithoutPromoRedemptionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPromoRedemptionsInput
    connect?: OrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPromotionRedemptionsInput = {
    create?: XOR<UserCreateWithoutPromotionRedemptionsInput, UserUncheckedCreateWithoutPromotionRedemptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPromotionRedemptionsInput
    connect?: UserWhereUniqueInput
  }

  export type PromotionUpdateOneRequiredWithoutRedemptionsNestedInput = {
    create?: XOR<PromotionCreateWithoutRedemptionsInput, PromotionUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutRedemptionsInput
    upsert?: PromotionUpsertWithoutRedemptionsInput
    connect?: PromotionWhereUniqueInput
    update?: XOR<XOR<PromotionUpdateToOneWithWhereWithoutRedemptionsInput, PromotionUpdateWithoutRedemptionsInput>, PromotionUncheckedUpdateWithoutRedemptionsInput>
  }

  export type OrderUpdateOneRequiredWithoutPromoRedemptionsNestedInput = {
    create?: XOR<OrderCreateWithoutPromoRedemptionsInput, OrderUncheckedCreateWithoutPromoRedemptionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPromoRedemptionsInput
    upsert?: OrderUpsertWithoutPromoRedemptionsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPromoRedemptionsInput, OrderUpdateWithoutPromoRedemptionsInput>, OrderUncheckedUpdateWithoutPromoRedemptionsInput>
  }

  export type UserUpdateOneWithoutPromotionRedemptionsNestedInput = {
    create?: XOR<UserCreateWithoutPromotionRedemptionsInput, UserUncheckedCreateWithoutPromotionRedemptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPromotionRedemptionsInput
    upsert?: UserUpsertWithoutPromotionRedemptionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPromotionRedemptionsInput, UserUpdateWithoutPromotionRedemptionsInput>, UserUncheckedUpdateWithoutPromotionRedemptionsInput>
  }

  export type UserCreateNestedOneWithoutRewardAccountInput = {
    create?: XOR<UserCreateWithoutRewardAccountInput, UserUncheckedCreateWithoutRewardAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardAccountInput
    connect?: UserWhereUniqueInput
  }

  export type RewardTransactionCreateNestedManyWithoutAccountInput = {
    create?: XOR<RewardTransactionCreateWithoutAccountInput, RewardTransactionUncheckedCreateWithoutAccountInput> | RewardTransactionCreateWithoutAccountInput[] | RewardTransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RewardTransactionCreateOrConnectWithoutAccountInput | RewardTransactionCreateOrConnectWithoutAccountInput[]
    createMany?: RewardTransactionCreateManyAccountInputEnvelope
    connect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
  }

  export type RewardTransactionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<RewardTransactionCreateWithoutAccountInput, RewardTransactionUncheckedCreateWithoutAccountInput> | RewardTransactionCreateWithoutAccountInput[] | RewardTransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RewardTransactionCreateOrConnectWithoutAccountInput | RewardTransactionCreateOrConnectWithoutAccountInput[]
    createMany?: RewardTransactionCreateManyAccountInputEnvelope
    connect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutRewardAccountNestedInput = {
    create?: XOR<UserCreateWithoutRewardAccountInput, UserUncheckedCreateWithoutRewardAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardAccountInput
    upsert?: UserUpsertWithoutRewardAccountInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRewardAccountInput, UserUpdateWithoutRewardAccountInput>, UserUncheckedUpdateWithoutRewardAccountInput>
  }

  export type RewardTransactionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<RewardTransactionCreateWithoutAccountInput, RewardTransactionUncheckedCreateWithoutAccountInput> | RewardTransactionCreateWithoutAccountInput[] | RewardTransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RewardTransactionCreateOrConnectWithoutAccountInput | RewardTransactionCreateOrConnectWithoutAccountInput[]
    upsert?: RewardTransactionUpsertWithWhereUniqueWithoutAccountInput | RewardTransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: RewardTransactionCreateManyAccountInputEnvelope
    set?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    disconnect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    delete?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    connect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    update?: RewardTransactionUpdateWithWhereUniqueWithoutAccountInput | RewardTransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: RewardTransactionUpdateManyWithWhereWithoutAccountInput | RewardTransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: RewardTransactionScalarWhereInput | RewardTransactionScalarWhereInput[]
  }

  export type RewardTransactionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<RewardTransactionCreateWithoutAccountInput, RewardTransactionUncheckedCreateWithoutAccountInput> | RewardTransactionCreateWithoutAccountInput[] | RewardTransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RewardTransactionCreateOrConnectWithoutAccountInput | RewardTransactionCreateOrConnectWithoutAccountInput[]
    upsert?: RewardTransactionUpsertWithWhereUniqueWithoutAccountInput | RewardTransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: RewardTransactionCreateManyAccountInputEnvelope
    set?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    disconnect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    delete?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    connect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    update?: RewardTransactionUpdateWithWhereUniqueWithoutAccountInput | RewardTransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: RewardTransactionUpdateManyWithWhereWithoutAccountInput | RewardTransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: RewardTransactionScalarWhereInput | RewardTransactionScalarWhereInput[]
  }

  export type RewardAccountCreateNestedOneWithoutTxnsInput = {
    create?: XOR<RewardAccountCreateWithoutTxnsInput, RewardAccountUncheckedCreateWithoutTxnsInput>
    connectOrCreate?: RewardAccountCreateOrConnectWithoutTxnsInput
    connect?: RewardAccountWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutRewardTransactionsInput = {
    create?: XOR<OrderCreateWithoutRewardTransactionsInput, OrderUncheckedCreateWithoutRewardTransactionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutRewardTransactionsInput
    connect?: OrderWhereUniqueInput
  }

  export type EnumRewardTxnTypeFieldUpdateOperationsInput = {
    set?: $Enums.RewardTxnType
  }

  export type RewardAccountUpdateOneRequiredWithoutTxnsNestedInput = {
    create?: XOR<RewardAccountCreateWithoutTxnsInput, RewardAccountUncheckedCreateWithoutTxnsInput>
    connectOrCreate?: RewardAccountCreateOrConnectWithoutTxnsInput
    upsert?: RewardAccountUpsertWithoutTxnsInput
    connect?: RewardAccountWhereUniqueInput
    update?: XOR<XOR<RewardAccountUpdateToOneWithWhereWithoutTxnsInput, RewardAccountUpdateWithoutTxnsInput>, RewardAccountUncheckedUpdateWithoutTxnsInput>
  }

  export type OrderUpdateOneWithoutRewardTransactionsNestedInput = {
    create?: XOR<OrderCreateWithoutRewardTransactionsInput, OrderUncheckedCreateWithoutRewardTransactionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutRewardTransactionsInput
    upsert?: OrderUpsertWithoutRewardTransactionsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutRewardTransactionsInput, OrderUpdateWithoutRewardTransactionsInput>, OrderUncheckedUpdateWithoutRewardTransactionsInput>
  }

  export type UserCreateNestedOneWithoutCateringOrdersInput = {
    create?: XOR<UserCreateWithoutCateringOrdersInput, UserUncheckedCreateWithoutCateringOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCateringOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedCateringOrdersInput = {
    create?: XOR<UserCreateWithoutCreatedCateringOrdersInput, UserUncheckedCreateWithoutCreatedCateringOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCateringOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type CateringItemCreateNestedManyWithoutCateringOrderInput = {
    create?: XOR<CateringItemCreateWithoutCateringOrderInput, CateringItemUncheckedCreateWithoutCateringOrderInput> | CateringItemCreateWithoutCateringOrderInput[] | CateringItemUncheckedCreateWithoutCateringOrderInput[]
    connectOrCreate?: CateringItemCreateOrConnectWithoutCateringOrderInput | CateringItemCreateOrConnectWithoutCateringOrderInput[]
    createMany?: CateringItemCreateManyCateringOrderInputEnvelope
    connect?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
  }

  export type CateringItemUncheckedCreateNestedManyWithoutCateringOrderInput = {
    create?: XOR<CateringItemCreateWithoutCateringOrderInput, CateringItemUncheckedCreateWithoutCateringOrderInput> | CateringItemCreateWithoutCateringOrderInput[] | CateringItemUncheckedCreateWithoutCateringOrderInput[]
    connectOrCreate?: CateringItemCreateOrConnectWithoutCateringOrderInput | CateringItemCreateOrConnectWithoutCateringOrderInput[]
    createMany?: CateringItemCreateManyCateringOrderInputEnvelope
    connect?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
  }

  export type EnumCateringStatusFieldUpdateOperationsInput = {
    set?: $Enums.CateringStatus
  }

  export type UserUpdateOneWithoutCateringOrdersNestedInput = {
    create?: XOR<UserCreateWithoutCateringOrdersInput, UserUncheckedCreateWithoutCateringOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCateringOrdersInput
    upsert?: UserUpsertWithoutCateringOrdersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCateringOrdersInput, UserUpdateWithoutCateringOrdersInput>, UserUncheckedUpdateWithoutCateringOrdersInput>
  }

  export type UserUpdateOneWithoutCreatedCateringOrdersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedCateringOrdersInput, UserUncheckedCreateWithoutCreatedCateringOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCateringOrdersInput
    upsert?: UserUpsertWithoutCreatedCateringOrdersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedCateringOrdersInput, UserUpdateWithoutCreatedCateringOrdersInput>, UserUncheckedUpdateWithoutCreatedCateringOrdersInput>
  }

  export type CateringItemUpdateManyWithoutCateringOrderNestedInput = {
    create?: XOR<CateringItemCreateWithoutCateringOrderInput, CateringItemUncheckedCreateWithoutCateringOrderInput> | CateringItemCreateWithoutCateringOrderInput[] | CateringItemUncheckedCreateWithoutCateringOrderInput[]
    connectOrCreate?: CateringItemCreateOrConnectWithoutCateringOrderInput | CateringItemCreateOrConnectWithoutCateringOrderInput[]
    upsert?: CateringItemUpsertWithWhereUniqueWithoutCateringOrderInput | CateringItemUpsertWithWhereUniqueWithoutCateringOrderInput[]
    createMany?: CateringItemCreateManyCateringOrderInputEnvelope
    set?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
    disconnect?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
    delete?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
    connect?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
    update?: CateringItemUpdateWithWhereUniqueWithoutCateringOrderInput | CateringItemUpdateWithWhereUniqueWithoutCateringOrderInput[]
    updateMany?: CateringItemUpdateManyWithWhereWithoutCateringOrderInput | CateringItemUpdateManyWithWhereWithoutCateringOrderInput[]
    deleteMany?: CateringItemScalarWhereInput | CateringItemScalarWhereInput[]
  }

  export type CateringItemUncheckedUpdateManyWithoutCateringOrderNestedInput = {
    create?: XOR<CateringItemCreateWithoutCateringOrderInput, CateringItemUncheckedCreateWithoutCateringOrderInput> | CateringItemCreateWithoutCateringOrderInput[] | CateringItemUncheckedCreateWithoutCateringOrderInput[]
    connectOrCreate?: CateringItemCreateOrConnectWithoutCateringOrderInput | CateringItemCreateOrConnectWithoutCateringOrderInput[]
    upsert?: CateringItemUpsertWithWhereUniqueWithoutCateringOrderInput | CateringItemUpsertWithWhereUniqueWithoutCateringOrderInput[]
    createMany?: CateringItemCreateManyCateringOrderInputEnvelope
    set?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
    disconnect?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
    delete?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
    connect?: CateringItemWhereUniqueInput | CateringItemWhereUniqueInput[]
    update?: CateringItemUpdateWithWhereUniqueWithoutCateringOrderInput | CateringItemUpdateWithWhereUniqueWithoutCateringOrderInput[]
    updateMany?: CateringItemUpdateManyWithWhereWithoutCateringOrderInput | CateringItemUpdateManyWithWhereWithoutCateringOrderInput[]
    deleteMany?: CateringItemScalarWhereInput | CateringItemScalarWhereInput[]
  }

  export type CateringOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<CateringOrderCreateWithoutItemsInput, CateringOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CateringOrderCreateOrConnectWithoutItemsInput
    connect?: CateringOrderWhereUniqueInput
  }

  export type MenuItemCreateNestedOneWithoutCateringItemsInput = {
    create?: XOR<MenuItemCreateWithoutCateringItemsInput, MenuItemUncheckedCreateWithoutCateringItemsInput>
    connectOrCreate?: MenuItemCreateOrConnectWithoutCateringItemsInput
    connect?: MenuItemWhereUniqueInput
  }

  export type CateringOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CateringOrderCreateWithoutItemsInput, CateringOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CateringOrderCreateOrConnectWithoutItemsInput
    upsert?: CateringOrderUpsertWithoutItemsInput
    connect?: CateringOrderWhereUniqueInput
    update?: XOR<XOR<CateringOrderUpdateToOneWithWhereWithoutItemsInput, CateringOrderUpdateWithoutItemsInput>, CateringOrderUncheckedUpdateWithoutItemsInput>
  }

  export type MenuItemUpdateOneWithoutCateringItemsNestedInput = {
    create?: XOR<MenuItemCreateWithoutCateringItemsInput, MenuItemUncheckedCreateWithoutCateringItemsInput>
    connectOrCreate?: MenuItemCreateOrConnectWithoutCateringItemsInput
    upsert?: MenuItemUpsertWithoutCateringItemsInput
    disconnect?: MenuItemWhereInput | boolean
    delete?: MenuItemWhereInput | boolean
    connect?: MenuItemWhereUniqueInput
    update?: XOR<XOR<MenuItemUpdateToOneWithWhereWithoutCateringItemsInput, MenuItemUpdateWithoutCateringItemsInput>, MenuItemUncheckedUpdateWithoutCateringItemsInput>
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutReviewsInput = {
    create?: XOR<OrderCreateWithoutReviewsInput, OrderUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReviewsInput
    connect?: OrderWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type OrderUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<OrderCreateWithoutReviewsInput, OrderUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReviewsInput
    upsert?: OrderUpsertWithoutReviewsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutReviewsInput, OrderUpdateWithoutReviewsInput>, OrderUncheckedUpdateWithoutReviewsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumMenuTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuType | EnumMenuTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MenuType[] | ListEnumMenuTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MenuType[] | ListEnumMenuTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMenuTypeFilter<$PrismaModel> | $Enums.MenuType
  }

  export type NestedEnumMenuTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuType | EnumMenuTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MenuType[] | ListEnumMenuTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MenuType[] | ListEnumMenuTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMenuTypeWithAggregatesFilter<$PrismaModel> | $Enums.MenuType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMenuTypeFilter<$PrismaModel>
    _max?: NestedEnumMenuTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumFulfillmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FulfillmentType | EnumFulfillmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FulfillmentType[] | ListEnumFulfillmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FulfillmentType[] | ListEnumFulfillmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFulfillmentTypeFilter<$PrismaModel> | $Enums.FulfillmentType
  }

  export type NestedEnumFulfillmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FulfillmentType | EnumFulfillmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FulfillmentType[] | ListEnumFulfillmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FulfillmentType[] | ListEnumFulfillmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFulfillmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.FulfillmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFulfillmentTypeFilter<$PrismaModel>
    _max?: NestedEnumFulfillmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumDeliveryPricingModeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryPricingMode | EnumDeliveryPricingModeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryPricingMode[] | ListEnumDeliveryPricingModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryPricingMode[] | ListEnumDeliveryPricingModeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryPricingModeFilter<$PrismaModel> | $Enums.DeliveryPricingMode
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumDeliveryPricingModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryPricingMode | EnumDeliveryPricingModeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryPricingMode[] | ListEnumDeliveryPricingModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryPricingMode[] | ListEnumDeliveryPricingModeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryPricingModeWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryPricingMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryPricingModeFilter<$PrismaModel>
    _max?: NestedEnumDeliveryPricingModeFilter<$PrismaModel>
  }

  export type NestedEnumOrderSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderSource | EnumOrderSourceFieldRefInput<$PrismaModel>
    in?: $Enums.OrderSource[] | ListEnumOrderSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderSource[] | ListEnumOrderSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderSourceFilter<$PrismaModel> | $Enums.OrderSource
  }

  export type NestedEnumOrderCheckoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderCheckoutStatus | EnumOrderCheckoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderCheckoutStatus[] | ListEnumOrderCheckoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderCheckoutStatus[] | ListEnumOrderCheckoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderCheckoutStatusFilter<$PrismaModel> | $Enums.OrderCheckoutStatus
  }

  export type NestedEnumFulfillmentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FulfillmentType | EnumFulfillmentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FulfillmentType[] | ListEnumFulfillmentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FulfillmentType[] | ListEnumFulfillmentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFulfillmentTypeNullableFilter<$PrismaModel> | $Enums.FulfillmentType | null
  }

  export type NestedEnumOrderSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderSource | EnumOrderSourceFieldRefInput<$PrismaModel>
    in?: $Enums.OrderSource[] | ListEnumOrderSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderSource[] | ListEnumOrderSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderSourceWithAggregatesFilter<$PrismaModel> | $Enums.OrderSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderSourceFilter<$PrismaModel>
    _max?: NestedEnumOrderSourceFilter<$PrismaModel>
  }

  export type NestedEnumOrderCheckoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderCheckoutStatus | EnumOrderCheckoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderCheckoutStatus[] | ListEnumOrderCheckoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderCheckoutStatus[] | ListEnumOrderCheckoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderCheckoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderCheckoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderCheckoutStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderCheckoutStatusFilter<$PrismaModel>
  }

  export type NestedEnumFulfillmentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FulfillmentType | EnumFulfillmentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FulfillmentType[] | ListEnumFulfillmentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FulfillmentType[] | ListEnumFulfillmentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFulfillmentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FulfillmentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFulfillmentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFulfillmentTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumFulfillmentGroupStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FulfillmentGroupStatus | EnumFulfillmentGroupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FulfillmentGroupStatus[] | ListEnumFulfillmentGroupStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FulfillmentGroupStatus[] | ListEnumFulfillmentGroupStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFulfillmentGroupStatusFilter<$PrismaModel> | $Enums.FulfillmentGroupStatus
  }

  export type NestedEnumFulfillmentGroupStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FulfillmentGroupStatus | EnumFulfillmentGroupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FulfillmentGroupStatus[] | ListEnumFulfillmentGroupStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FulfillmentGroupStatus[] | ListEnumFulfillmentGroupStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFulfillmentGroupStatusWithAggregatesFilter<$PrismaModel> | $Enums.FulfillmentGroupStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFulfillmentGroupStatusFilter<$PrismaModel>
    _max?: NestedEnumFulfillmentGroupStatusFilter<$PrismaModel>
  }

  export type NestedEnumAdjustmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdjustmentType | EnumAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdjustmentType[] | ListEnumAdjustmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdjustmentType[] | ListEnumAdjustmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdjustmentTypeFilter<$PrismaModel> | $Enums.AdjustmentType
  }

  export type NestedEnumAdjustmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdjustmentType | EnumAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdjustmentType[] | ListEnumAdjustmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdjustmentType[] | ListEnumAdjustmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdjustmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdjustmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdjustmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAdjustmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderFilter<$PrismaModel> | $Enums.PaymentProvider
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumHoldStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HoldStatus | EnumHoldStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HoldStatus[] | ListEnumHoldStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HoldStatus[] | ListEnumHoldStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHoldStatusFilter<$PrismaModel> | $Enums.HoldStatus
  }

  export type NestedEnumHoldStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HoldStatus | EnumHoldStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HoldStatus[] | ListEnumHoldStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HoldStatus[] | ListEnumHoldStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHoldStatusWithAggregatesFilter<$PrismaModel> | $Enums.HoldStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHoldStatusFilter<$PrismaModel>
    _max?: NestedEnumHoldStatusFilter<$PrismaModel>
  }

  export type NestedEnumPromotionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PromotionType | EnumPromotionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromotionType[] | ListEnumPromotionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromotionType[] | ListEnumPromotionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromotionTypeFilter<$PrismaModel> | $Enums.PromotionType
  }

  export type NestedEnumPromotionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromotionType | EnumPromotionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromotionType[] | ListEnumPromotionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromotionType[] | ListEnumPromotionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromotionTypeWithAggregatesFilter<$PrismaModel> | $Enums.PromotionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromotionTypeFilter<$PrismaModel>
    _max?: NestedEnumPromotionTypeFilter<$PrismaModel>
  }

  export type NestedEnumRewardTxnTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardTxnType | EnumRewardTxnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RewardTxnType[] | ListEnumRewardTxnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardTxnType[] | ListEnumRewardTxnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardTxnTypeFilter<$PrismaModel> | $Enums.RewardTxnType
  }

  export type NestedEnumRewardTxnTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardTxnType | EnumRewardTxnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RewardTxnType[] | ListEnumRewardTxnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RewardTxnType[] | ListEnumRewardTxnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRewardTxnTypeWithAggregatesFilter<$PrismaModel> | $Enums.RewardTxnType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRewardTxnTypeFilter<$PrismaModel>
    _max?: NestedEnumRewardTxnTypeFilter<$PrismaModel>
  }

  export type NestedEnumCateringStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CateringStatus | EnumCateringStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CateringStatus[] | ListEnumCateringStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CateringStatus[] | ListEnumCateringStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCateringStatusFilter<$PrismaModel> | $Enums.CateringStatus
  }

  export type NestedEnumCateringStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CateringStatus | EnumCateringStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CateringStatus[] | ListEnumCateringStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CateringStatus[] | ListEnumCateringStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCateringStatusWithAggregatesFilter<$PrismaModel> | $Enums.CateringStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCateringStatusFilter<$PrismaModel>
    _max?: NestedEnumCateringStatusFilter<$PrismaModel>
  }

  export type OrderCreateWithoutUserInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedOrdersInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutDeliveryOrdersInput
    groups?: FulfillmentGroupCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    events?: OrderEventCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: number
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    events?: OrderEventUncheckedCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldUncheckedCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCreatedByInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutDeliveryOrdersInput
    groups?: FulfillmentGroupCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    events?: OrderEventCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCreatedByInput = {
    id?: number
    userId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    events?: OrderEventUncheckedCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldUncheckedCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCreatedByInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput>
  }

  export type OrderCreateManyCreatedByInputEnvelope = {
    data: OrderCreateManyCreatedByInput | OrderCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutUserInput = {
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    lat?: number | null
    lng?: number | null
    isDefault?: boolean
    isSnapshot?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryOrders?: OrderCreateNestedManyWithoutDeliveryAddressInput
  }

  export type AddressUncheckedCreateWithoutUserInput = {
    id?: number
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    lat?: number | null
    lng?: number | null
    isDefault?: boolean
    isSnapshot?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryOrders?: OrderUncheckedCreateNestedManyWithoutDeliveryAddressInput
  }

  export type AddressCreateOrConnectWithoutUserInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AddressCreateManyUserInputEnvelope = {
    data: AddressCreateManyUserInput | AddressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutReceivedByInput = {
    provider?: $Enums.PaymentProvider
    method: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    amountCents: number
    providerRef?: string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutReceivedByInput = {
    id?: number
    orderId: number
    provider?: $Enums.PaymentProvider
    method: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    amountCents: number
    providerRef?: string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutReceivedByInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput>
  }

  export type PaymentCreateManyReceivedByInputEnvelope = {
    data: PaymentCreateManyReceivedByInput | PaymentCreateManyReceivedByInput[]
    skipDuplicates?: boolean
  }

  export type CateringOrderCreateWithoutUserInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    status?: $Enums.CateringStatus
    eventDate: Date | string
    guestCount: number
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    notes?: string | null
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedCateringOrdersInput
    items?: CateringItemCreateNestedManyWithoutCateringOrderInput
  }

  export type CateringOrderUncheckedCreateWithoutUserInput = {
    id?: number
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    status?: $Enums.CateringStatus
    eventDate: Date | string
    guestCount: number
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    notes?: string | null
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CateringItemUncheckedCreateNestedManyWithoutCateringOrderInput
  }

  export type CateringOrderCreateOrConnectWithoutUserInput = {
    where: CateringOrderWhereUniqueInput
    create: XOR<CateringOrderCreateWithoutUserInput, CateringOrderUncheckedCreateWithoutUserInput>
  }

  export type CateringOrderCreateManyUserInputEnvelope = {
    data: CateringOrderCreateManyUserInput | CateringOrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CateringOrderCreateWithoutCreatedByInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    status?: $Enums.CateringStatus
    eventDate: Date | string
    guestCount: number
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    notes?: string | null
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCateringOrdersInput
    items?: CateringItemCreateNestedManyWithoutCateringOrderInput
  }

  export type CateringOrderUncheckedCreateWithoutCreatedByInput = {
    id?: number
    userId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    status?: $Enums.CateringStatus
    eventDate: Date | string
    guestCount: number
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    notes?: string | null
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CateringItemUncheckedCreateNestedManyWithoutCateringOrderInput
  }

  export type CateringOrderCreateOrConnectWithoutCreatedByInput = {
    where: CateringOrderWhereUniqueInput
    create: XOR<CateringOrderCreateWithoutCreatedByInput, CateringOrderUncheckedCreateWithoutCreatedByInput>
  }

  export type CateringOrderCreateManyCreatedByInputEnvelope = {
    data: CateringOrderCreateManyCreatedByInput | CateringOrderCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type RewardAccountCreateWithoutUserInput = {
    balancePoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    txns?: RewardTransactionCreateNestedManyWithoutAccountInput
  }

  export type RewardAccountUncheckedCreateWithoutUserInput = {
    id?: number
    balancePoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    txns?: RewardTransactionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type RewardAccountCreateOrConnectWithoutUserInput = {
    where: RewardAccountWhereUniqueInput
    create: XOR<RewardAccountCreateWithoutUserInput, RewardAccountUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateWithoutUserInput = {
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: number
    orderId?: number | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PromotionRedemptionCreateWithoutUserInput = {
    discountCentsApplied: number
    createdAt?: Date | string
    promotion: PromotionCreateNestedOneWithoutRedemptionsInput
    order: OrderCreateNestedOneWithoutPromoRedemptionsInput
  }

  export type PromotionRedemptionUncheckedCreateWithoutUserInput = {
    id?: number
    promotionId: number
    orderId: number
    discountCentsApplied: number
    createdAt?: Date | string
  }

  export type PromotionRedemptionCreateOrConnectWithoutUserInput = {
    where: PromotionRedemptionWhereUniqueInput
    create: XOR<PromotionRedemptionCreateWithoutUserInput, PromotionRedemptionUncheckedCreateWithoutUserInput>
  }

  export type PromotionRedemptionCreateManyUserInputEnvelope = {
    data: PromotionRedemptionCreateManyUserInput | PromotionRedemptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: IntFilter<"Order"> | number
    userId?: IntNullableFilter<"Order"> | number | null
    createdByUserId?: IntNullableFilter<"Order"> | number | null
    source?: EnumOrderSourceFilter<"Order"> | $Enums.OrderSource
    sourceRef?: StringNullableFilter<"Order"> | string | null
    currency?: StringFilter<"Order"> | string
    checkoutStatus?: EnumOrderCheckoutStatusFilter<"Order"> | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFilter<"Order"> | $Enums.DeliveryPricingMode
    fulfillmentType?: EnumFulfillmentTypeNullableFilter<"Order"> | $Enums.FulfillmentType | null
    pickupLocationId?: IntNullableFilter<"Order"> | number | null
    deliveryAddressId?: IntNullableFilter<"Order"> | number | null
    deliveryDistanceMiles?: FloatNullableFilter<"Order"> | number | null
    customerName?: StringNullableFilter<"Order"> | string | null
    customerEmail?: StringNullableFilter<"Order"> | string | null
    customerPhone?: StringNullableFilter<"Order"> | string | null
    customerNotes?: StringNullableFilter<"Order"> | string | null
    internalNotes?: StringNullableFilter<"Order"> | string | null
    subtotalCents?: IntFilter<"Order"> | number
    adjustmentsCents?: IntFilter<"Order"> | number
    totalCents?: IntFilter<"Order"> | number
    refundedCents?: IntFilter<"Order"> | number
    placedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCreatedByInput, OrderUncheckedUpdateWithoutCreatedByInput>
    create: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCreatedByInput, OrderUncheckedUpdateWithoutCreatedByInput>
  }

  export type OrderUpdateManyWithWhereWithoutCreatedByInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AddressUpsertWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
  }

  export type AddressUpdateManyWithWhereWithoutUserInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutUserInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: IntFilter<"Address"> | number
    userId?: IntNullableFilter<"Address"> | number | null
    label?: StringNullableFilter<"Address"> | string | null
    line1?: StringFilter<"Address"> | string
    line2?: StringNullableFilter<"Address"> | string | null
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    lat?: FloatNullableFilter<"Address"> | number | null
    lng?: FloatNullableFilter<"Address"> | number | null
    isDefault?: BoolFilter<"Address"> | boolean
    isSnapshot?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutReceivedByInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutReceivedByInput, PaymentUncheckedUpdateWithoutReceivedByInput>
    create: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutReceivedByInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutReceivedByInput, PaymentUncheckedUpdateWithoutReceivedByInput>
  }

  export type PaymentUpdateManyWithWhereWithoutReceivedByInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutReceivedByInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    orderId?: IntFilter<"Payment"> | number
    provider?: EnumPaymentProviderFilter<"Payment"> | $Enums.PaymentProvider
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amountCents?: IntFilter<"Payment"> | number
    providerRef?: StringNullableFilter<"Payment"> | string | null
    receivedByUserId?: IntNullableFilter<"Payment"> | number | null
    receivedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type CateringOrderUpsertWithWhereUniqueWithoutUserInput = {
    where: CateringOrderWhereUniqueInput
    update: XOR<CateringOrderUpdateWithoutUserInput, CateringOrderUncheckedUpdateWithoutUserInput>
    create: XOR<CateringOrderCreateWithoutUserInput, CateringOrderUncheckedCreateWithoutUserInput>
  }

  export type CateringOrderUpdateWithWhereUniqueWithoutUserInput = {
    where: CateringOrderWhereUniqueInput
    data: XOR<CateringOrderUpdateWithoutUserInput, CateringOrderUncheckedUpdateWithoutUserInput>
  }

  export type CateringOrderUpdateManyWithWhereWithoutUserInput = {
    where: CateringOrderScalarWhereInput
    data: XOR<CateringOrderUpdateManyMutationInput, CateringOrderUncheckedUpdateManyWithoutUserInput>
  }

  export type CateringOrderScalarWhereInput = {
    AND?: CateringOrderScalarWhereInput | CateringOrderScalarWhereInput[]
    OR?: CateringOrderScalarWhereInput[]
    NOT?: CateringOrderScalarWhereInput | CateringOrderScalarWhereInput[]
    id?: IntFilter<"CateringOrder"> | number
    userId?: IntNullableFilter<"CateringOrder"> | number | null
    createdByUserId?: IntNullableFilter<"CateringOrder"> | number | null
    source?: EnumOrderSourceFilter<"CateringOrder"> | $Enums.OrderSource
    sourceRef?: StringNullableFilter<"CateringOrder"> | string | null
    status?: EnumCateringStatusFilter<"CateringOrder"> | $Enums.CateringStatus
    eventDate?: DateTimeFilter<"CateringOrder"> | Date | string
    guestCount?: IntFilter<"CateringOrder"> | number
    customerName?: StringNullableFilter<"CateringOrder"> | string | null
    customerEmail?: StringNullableFilter<"CateringOrder"> | string | null
    customerPhone?: StringNullableFilter<"CateringOrder"> | string | null
    notes?: StringNullableFilter<"CateringOrder"> | string | null
    totalCents?: IntFilter<"CateringOrder"> | number
    createdAt?: DateTimeFilter<"CateringOrder"> | Date | string
    updatedAt?: DateTimeFilter<"CateringOrder"> | Date | string
  }

  export type CateringOrderUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CateringOrderWhereUniqueInput
    update: XOR<CateringOrderUpdateWithoutCreatedByInput, CateringOrderUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CateringOrderCreateWithoutCreatedByInput, CateringOrderUncheckedCreateWithoutCreatedByInput>
  }

  export type CateringOrderUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CateringOrderWhereUniqueInput
    data: XOR<CateringOrderUpdateWithoutCreatedByInput, CateringOrderUncheckedUpdateWithoutCreatedByInput>
  }

  export type CateringOrderUpdateManyWithWhereWithoutCreatedByInput = {
    where: CateringOrderScalarWhereInput
    data: XOR<CateringOrderUpdateManyMutationInput, CateringOrderUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type RewardAccountUpsertWithoutUserInput = {
    update: XOR<RewardAccountUpdateWithoutUserInput, RewardAccountUncheckedUpdateWithoutUserInput>
    create: XOR<RewardAccountCreateWithoutUserInput, RewardAccountUncheckedCreateWithoutUserInput>
    where?: RewardAccountWhereInput
  }

  export type RewardAccountUpdateToOneWithWhereWithoutUserInput = {
    where?: RewardAccountWhereInput
    data: XOR<RewardAccountUpdateWithoutUserInput, RewardAccountUncheckedUpdateWithoutUserInput>
  }

  export type RewardAccountUpdateWithoutUserInput = {
    balancePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    txns?: RewardTransactionUpdateManyWithoutAccountNestedInput
  }

  export type RewardAccountUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    balancePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    txns?: RewardTransactionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: IntFilter<"Review"> | number
    userId?: IntFilter<"Review"> | number
    orderId?: IntNullableFilter<"Review"> | number | null
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type PromotionRedemptionUpsertWithWhereUniqueWithoutUserInput = {
    where: PromotionRedemptionWhereUniqueInput
    update: XOR<PromotionRedemptionUpdateWithoutUserInput, PromotionRedemptionUncheckedUpdateWithoutUserInput>
    create: XOR<PromotionRedemptionCreateWithoutUserInput, PromotionRedemptionUncheckedCreateWithoutUserInput>
  }

  export type PromotionRedemptionUpdateWithWhereUniqueWithoutUserInput = {
    where: PromotionRedemptionWhereUniqueInput
    data: XOR<PromotionRedemptionUpdateWithoutUserInput, PromotionRedemptionUncheckedUpdateWithoutUserInput>
  }

  export type PromotionRedemptionUpdateManyWithWhereWithoutUserInput = {
    where: PromotionRedemptionScalarWhereInput
    data: XOR<PromotionRedemptionUpdateManyMutationInput, PromotionRedemptionUncheckedUpdateManyWithoutUserInput>
  }

  export type PromotionRedemptionScalarWhereInput = {
    AND?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
    OR?: PromotionRedemptionScalarWhereInput[]
    NOT?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
    id?: IntFilter<"PromotionRedemption"> | number
    promotionId?: IntFilter<"PromotionRedemption"> | number
    orderId?: IntFilter<"PromotionRedemption"> | number
    userId?: IntNullableFilter<"PromotionRedemption"> | number | null
    discountCentsApplied?: IntFilter<"PromotionRedemption"> | number
    createdAt?: DateTimeFilter<"PromotionRedemption"> | Date | string
  }

  export type MenuItemCreateWithoutCategoryInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: MenuVariantCreateNestedManyWithoutMenuItemInput
    addOnLinks?: MenuItemAddOnCreateNestedManyWithoutMenuItemInput
    cateringItems?: CateringItemCreateNestedManyWithoutMenuItemInput
  }

  export type MenuItemUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: MenuVariantUncheckedCreateNestedManyWithoutMenuItemInput
    addOnLinks?: MenuItemAddOnUncheckedCreateNestedManyWithoutMenuItemInput
    cateringItems?: CateringItemUncheckedCreateNestedManyWithoutMenuItemInput
  }

  export type MenuItemCreateOrConnectWithoutCategoryInput = {
    where: MenuItemWhereUniqueInput
    create: XOR<MenuItemCreateWithoutCategoryInput, MenuItemUncheckedCreateWithoutCategoryInput>
  }

  export type MenuItemCreateManyCategoryInputEnvelope = {
    data: MenuItemCreateManyCategoryInput | MenuItemCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type MenuItemUpsertWithWhereUniqueWithoutCategoryInput = {
    where: MenuItemWhereUniqueInput
    update: XOR<MenuItemUpdateWithoutCategoryInput, MenuItemUncheckedUpdateWithoutCategoryInput>
    create: XOR<MenuItemCreateWithoutCategoryInput, MenuItemUncheckedCreateWithoutCategoryInput>
  }

  export type MenuItemUpdateWithWhereUniqueWithoutCategoryInput = {
    where: MenuItemWhereUniqueInput
    data: XOR<MenuItemUpdateWithoutCategoryInput, MenuItemUncheckedUpdateWithoutCategoryInput>
  }

  export type MenuItemUpdateManyWithWhereWithoutCategoryInput = {
    where: MenuItemScalarWhereInput
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyWithoutCategoryInput>
  }

  export type MenuItemScalarWhereInput = {
    AND?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
    OR?: MenuItemScalarWhereInput[]
    NOT?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
    id?: IntFilter<"MenuItem"> | number
    categoryId?: IntNullableFilter<"MenuItem"> | number | null
    name?: StringFilter<"MenuItem"> | string
    description?: StringNullableFilter<"MenuItem"> | string | null
    imageUrl?: StringNullableFilter<"MenuItem"> | string | null
    nutrition?: JsonNullableFilter<"MenuItem">
    allergens?: JsonNullableFilter<"MenuItem">
    isActive?: BoolFilter<"MenuItem"> | boolean
    archivedAt?: DateTimeNullableFilter<"MenuItem"> | Date | string | null
    createdAt?: DateTimeFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeFilter<"MenuItem"> | Date | string
  }

  export type CategoryCreateWithoutItemsInput = {
    name: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutItemsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutItemsInput, CategoryUncheckedCreateWithoutItemsInput>
  }

  export type MenuVariantCreateWithoutMenuItemInput = {
    label: string
    basePriceCents: number
    baseCapacity?: number | null
    isActive?: boolean
    prepMinutes?: number | null
    packagingCostCents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offerings?: MenuOfferingCreateNestedManyWithoutVariantInput
    orderItems?: OrderItemCreateNestedManyWithoutVariantInput
  }

  export type MenuVariantUncheckedCreateWithoutMenuItemInput = {
    id?: number
    label: string
    basePriceCents: number
    baseCapacity?: number | null
    isActive?: boolean
    prepMinutes?: number | null
    packagingCostCents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offerings?: MenuOfferingUncheckedCreateNestedManyWithoutVariantInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutVariantInput
  }

  export type MenuVariantCreateOrConnectWithoutMenuItemInput = {
    where: MenuVariantWhereUniqueInput
    create: XOR<MenuVariantCreateWithoutMenuItemInput, MenuVariantUncheckedCreateWithoutMenuItemInput>
  }

  export type MenuVariantCreateManyMenuItemInputEnvelope = {
    data: MenuVariantCreateManyMenuItemInput | MenuVariantCreateManyMenuItemInput[]
    skipDuplicates?: boolean
  }

  export type MenuItemAddOnCreateWithoutMenuItemInput = {
    maxQtyPerItem?: number | null
    addOn: AddOnCreateNestedOneWithoutItemLinksInput
  }

  export type MenuItemAddOnUncheckedCreateWithoutMenuItemInput = {
    addOnId: number
    maxQtyPerItem?: number | null
  }

  export type MenuItemAddOnCreateOrConnectWithoutMenuItemInput = {
    where: MenuItemAddOnWhereUniqueInput
    create: XOR<MenuItemAddOnCreateWithoutMenuItemInput, MenuItemAddOnUncheckedCreateWithoutMenuItemInput>
  }

  export type MenuItemAddOnCreateManyMenuItemInputEnvelope = {
    data: MenuItemAddOnCreateManyMenuItemInput | MenuItemAddOnCreateManyMenuItemInput[]
    skipDuplicates?: boolean
  }

  export type CateringItemCreateWithoutMenuItemInput = {
    nameSnapshot: string
    quantity: number
    unitPriceCents: number
    cateringOrder: CateringOrderCreateNestedOneWithoutItemsInput
  }

  export type CateringItemUncheckedCreateWithoutMenuItemInput = {
    id?: number
    cateringOrderId: number
    nameSnapshot: string
    quantity: number
    unitPriceCents: number
  }

  export type CateringItemCreateOrConnectWithoutMenuItemInput = {
    where: CateringItemWhereUniqueInput
    create: XOR<CateringItemCreateWithoutMenuItemInput, CateringItemUncheckedCreateWithoutMenuItemInput>
  }

  export type CateringItemCreateManyMenuItemInputEnvelope = {
    data: CateringItemCreateManyMenuItemInput | CateringItemCreateManyMenuItemInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutItemsInput = {
    update: XOR<CategoryUpdateWithoutItemsInput, CategoryUncheckedUpdateWithoutItemsInput>
    create: XOR<CategoryCreateWithoutItemsInput, CategoryUncheckedCreateWithoutItemsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutItemsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutItemsInput, CategoryUncheckedUpdateWithoutItemsInput>
  }

  export type CategoryUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuVariantUpsertWithWhereUniqueWithoutMenuItemInput = {
    where: MenuVariantWhereUniqueInput
    update: XOR<MenuVariantUpdateWithoutMenuItemInput, MenuVariantUncheckedUpdateWithoutMenuItemInput>
    create: XOR<MenuVariantCreateWithoutMenuItemInput, MenuVariantUncheckedCreateWithoutMenuItemInput>
  }

  export type MenuVariantUpdateWithWhereUniqueWithoutMenuItemInput = {
    where: MenuVariantWhereUniqueInput
    data: XOR<MenuVariantUpdateWithoutMenuItemInput, MenuVariantUncheckedUpdateWithoutMenuItemInput>
  }

  export type MenuVariantUpdateManyWithWhereWithoutMenuItemInput = {
    where: MenuVariantScalarWhereInput
    data: XOR<MenuVariantUpdateManyMutationInput, MenuVariantUncheckedUpdateManyWithoutMenuItemInput>
  }

  export type MenuVariantScalarWhereInput = {
    AND?: MenuVariantScalarWhereInput | MenuVariantScalarWhereInput[]
    OR?: MenuVariantScalarWhereInput[]
    NOT?: MenuVariantScalarWhereInput | MenuVariantScalarWhereInput[]
    id?: IntFilter<"MenuVariant"> | number
    menuItemId?: IntFilter<"MenuVariant"> | number
    label?: StringFilter<"MenuVariant"> | string
    basePriceCents?: IntFilter<"MenuVariant"> | number
    baseCapacity?: IntNullableFilter<"MenuVariant"> | number | null
    isActive?: BoolFilter<"MenuVariant"> | boolean
    prepMinutes?: IntNullableFilter<"MenuVariant"> | number | null
    packagingCostCents?: IntNullableFilter<"MenuVariant"> | number | null
    createdAt?: DateTimeFilter<"MenuVariant"> | Date | string
    updatedAt?: DateTimeFilter<"MenuVariant"> | Date | string
  }

  export type MenuItemAddOnUpsertWithWhereUniqueWithoutMenuItemInput = {
    where: MenuItemAddOnWhereUniqueInput
    update: XOR<MenuItemAddOnUpdateWithoutMenuItemInput, MenuItemAddOnUncheckedUpdateWithoutMenuItemInput>
    create: XOR<MenuItemAddOnCreateWithoutMenuItemInput, MenuItemAddOnUncheckedCreateWithoutMenuItemInput>
  }

  export type MenuItemAddOnUpdateWithWhereUniqueWithoutMenuItemInput = {
    where: MenuItemAddOnWhereUniqueInput
    data: XOR<MenuItemAddOnUpdateWithoutMenuItemInput, MenuItemAddOnUncheckedUpdateWithoutMenuItemInput>
  }

  export type MenuItemAddOnUpdateManyWithWhereWithoutMenuItemInput = {
    where: MenuItemAddOnScalarWhereInput
    data: XOR<MenuItemAddOnUpdateManyMutationInput, MenuItemAddOnUncheckedUpdateManyWithoutMenuItemInput>
  }

  export type MenuItemAddOnScalarWhereInput = {
    AND?: MenuItemAddOnScalarWhereInput | MenuItemAddOnScalarWhereInput[]
    OR?: MenuItemAddOnScalarWhereInput[]
    NOT?: MenuItemAddOnScalarWhereInput | MenuItemAddOnScalarWhereInput[]
    menuItemId?: IntFilter<"MenuItemAddOn"> | number
    addOnId?: IntFilter<"MenuItemAddOn"> | number
    maxQtyPerItem?: IntNullableFilter<"MenuItemAddOn"> | number | null
  }

  export type CateringItemUpsertWithWhereUniqueWithoutMenuItemInput = {
    where: CateringItemWhereUniqueInput
    update: XOR<CateringItemUpdateWithoutMenuItemInput, CateringItemUncheckedUpdateWithoutMenuItemInput>
    create: XOR<CateringItemCreateWithoutMenuItemInput, CateringItemUncheckedCreateWithoutMenuItemInput>
  }

  export type CateringItemUpdateWithWhereUniqueWithoutMenuItemInput = {
    where: CateringItemWhereUniqueInput
    data: XOR<CateringItemUpdateWithoutMenuItemInput, CateringItemUncheckedUpdateWithoutMenuItemInput>
  }

  export type CateringItemUpdateManyWithWhereWithoutMenuItemInput = {
    where: CateringItemScalarWhereInput
    data: XOR<CateringItemUpdateManyMutationInput, CateringItemUncheckedUpdateManyWithoutMenuItemInput>
  }

  export type CateringItemScalarWhereInput = {
    AND?: CateringItemScalarWhereInput | CateringItemScalarWhereInput[]
    OR?: CateringItemScalarWhereInput[]
    NOT?: CateringItemScalarWhereInput | CateringItemScalarWhereInput[]
    id?: IntFilter<"CateringItem"> | number
    cateringOrderId?: IntFilter<"CateringItem"> | number
    menuItemId?: IntNullableFilter<"CateringItem"> | number | null
    nameSnapshot?: StringFilter<"CateringItem"> | string
    quantity?: IntFilter<"CateringItem"> | number
    unitPriceCents?: IntFilter<"CateringItem"> | number
  }

  export type MenuItemCreateWithoutVariantsInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutItemsInput
    addOnLinks?: MenuItemAddOnCreateNestedManyWithoutMenuItemInput
    cateringItems?: CateringItemCreateNestedManyWithoutMenuItemInput
  }

  export type MenuItemUncheckedCreateWithoutVariantsInput = {
    id?: number
    categoryId?: number | null
    name: string
    description?: string | null
    imageUrl?: string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addOnLinks?: MenuItemAddOnUncheckedCreateNestedManyWithoutMenuItemInput
    cateringItems?: CateringItemUncheckedCreateNestedManyWithoutMenuItemInput
  }

  export type MenuItemCreateOrConnectWithoutVariantsInput = {
    where: MenuItemWhereUniqueInput
    create: XOR<MenuItemCreateWithoutVariantsInput, MenuItemUncheckedCreateWithoutVariantsInput>
  }

  export type MenuOfferingCreateWithoutVariantInput = {
    priceOverrideCents?: number | null
    capacityOverride?: number | null
    isAvailable?: boolean
    maxPerOrder?: number | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    menu: MenuCreateNestedOneWithoutOfferingsInput
    holds?: CapacityHoldCreateNestedManyWithoutOfferingInput
  }

  export type MenuOfferingUncheckedCreateWithoutVariantInput = {
    id?: number
    menuId: number
    priceOverrideCents?: number | null
    capacityOverride?: number | null
    isAvailable?: boolean
    maxPerOrder?: number | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holds?: CapacityHoldUncheckedCreateNestedManyWithoutOfferingInput
  }

  export type MenuOfferingCreateOrConnectWithoutVariantInput = {
    where: MenuOfferingWhereUniqueInput
    create: XOR<MenuOfferingCreateWithoutVariantInput, MenuOfferingUncheckedCreateWithoutVariantInput>
  }

  export type MenuOfferingCreateManyVariantInputEnvelope = {
    data: MenuOfferingCreateManyVariantInput | MenuOfferingCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutVariantInput = {
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    variantLabelSnapshot: string
    imageUrlSnapshot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    group: FulfillmentGroupCreateNestedOneWithoutItemsInput
    addOns?: OrderItemAddOnCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutVariantInput = {
    id?: number
    orderId: number
    fulfillmentGroupId: number
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    variantLabelSnapshot: string
    imageUrlSnapshot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addOns?: OrderItemAddOnUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutVariantInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput>
  }

  export type OrderItemCreateManyVariantInputEnvelope = {
    data: OrderItemCreateManyVariantInput | OrderItemCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type MenuItemUpsertWithoutVariantsInput = {
    update: XOR<MenuItemUpdateWithoutVariantsInput, MenuItemUncheckedUpdateWithoutVariantsInput>
    create: XOR<MenuItemCreateWithoutVariantsInput, MenuItemUncheckedCreateWithoutVariantsInput>
    where?: MenuItemWhereInput
  }

  export type MenuItemUpdateToOneWithWhereWithoutVariantsInput = {
    where?: MenuItemWhereInput
    data: XOR<MenuItemUpdateWithoutVariantsInput, MenuItemUncheckedUpdateWithoutVariantsInput>
  }

  export type MenuItemUpdateWithoutVariantsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutItemsNestedInput
    addOnLinks?: MenuItemAddOnUpdateManyWithoutMenuItemNestedInput
    cateringItems?: CateringItemUpdateManyWithoutMenuItemNestedInput
  }

  export type MenuItemUncheckedUpdateWithoutVariantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addOnLinks?: MenuItemAddOnUncheckedUpdateManyWithoutMenuItemNestedInput
    cateringItems?: CateringItemUncheckedUpdateManyWithoutMenuItemNestedInput
  }

  export type MenuOfferingUpsertWithWhereUniqueWithoutVariantInput = {
    where: MenuOfferingWhereUniqueInput
    update: XOR<MenuOfferingUpdateWithoutVariantInput, MenuOfferingUncheckedUpdateWithoutVariantInput>
    create: XOR<MenuOfferingCreateWithoutVariantInput, MenuOfferingUncheckedCreateWithoutVariantInput>
  }

  export type MenuOfferingUpdateWithWhereUniqueWithoutVariantInput = {
    where: MenuOfferingWhereUniqueInput
    data: XOR<MenuOfferingUpdateWithoutVariantInput, MenuOfferingUncheckedUpdateWithoutVariantInput>
  }

  export type MenuOfferingUpdateManyWithWhereWithoutVariantInput = {
    where: MenuOfferingScalarWhereInput
    data: XOR<MenuOfferingUpdateManyMutationInput, MenuOfferingUncheckedUpdateManyWithoutVariantInput>
  }

  export type MenuOfferingScalarWhereInput = {
    AND?: MenuOfferingScalarWhereInput | MenuOfferingScalarWhereInput[]
    OR?: MenuOfferingScalarWhereInput[]
    NOT?: MenuOfferingScalarWhereInput | MenuOfferingScalarWhereInput[]
    id?: IntFilter<"MenuOffering"> | number
    menuId?: IntFilter<"MenuOffering"> | number
    menuVariantId?: IntFilter<"MenuOffering"> | number
    priceOverrideCents?: IntNullableFilter<"MenuOffering"> | number | null
    capacityOverride?: IntNullableFilter<"MenuOffering"> | number | null
    isAvailable?: BoolFilter<"MenuOffering"> | boolean
    maxPerOrder?: IntNullableFilter<"MenuOffering"> | number | null
    position?: IntFilter<"MenuOffering"> | number
    createdAt?: DateTimeFilter<"MenuOffering"> | Date | string
    updatedAt?: DateTimeFilter<"MenuOffering"> | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutVariantInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutVariantInput, OrderItemUncheckedUpdateWithoutVariantInput>
    create: XOR<OrderItemCreateWithoutVariantInput, OrderItemUncheckedCreateWithoutVariantInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutVariantInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutVariantInput, OrderItemUncheckedUpdateWithoutVariantInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutVariantInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutVariantInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    fulfillmentGroupId?: IntFilter<"OrderItem"> | number
    menuVariantId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    unitPriceCents?: IntFilter<"OrderItem"> | number
    nameSnapshot?: StringFilter<"OrderItem"> | string
    variantLabelSnapshot?: StringFilter<"OrderItem"> | string
    imageUrlSnapshot?: StringNullableFilter<"OrderItem"> | string | null
    notes?: StringNullableFilter<"OrderItem"> | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type MenuItemAddOnCreateWithoutAddOnInput = {
    maxQtyPerItem?: number | null
    menuItem: MenuItemCreateNestedOneWithoutAddOnLinksInput
  }

  export type MenuItemAddOnUncheckedCreateWithoutAddOnInput = {
    menuItemId: number
    maxQtyPerItem?: number | null
  }

  export type MenuItemAddOnCreateOrConnectWithoutAddOnInput = {
    where: MenuItemAddOnWhereUniqueInput
    create: XOR<MenuItemAddOnCreateWithoutAddOnInput, MenuItemAddOnUncheckedCreateWithoutAddOnInput>
  }

  export type MenuItemAddOnCreateManyAddOnInputEnvelope = {
    data: MenuItemAddOnCreateManyAddOnInput | MenuItemAddOnCreateManyAddOnInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemAddOnCreateWithoutAddOnInput = {
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    orderItem: OrderItemCreateNestedOneWithoutAddOnsInput
  }

  export type OrderItemAddOnUncheckedCreateWithoutAddOnInput = {
    id?: number
    orderItemId: number
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
  }

  export type OrderItemAddOnCreateOrConnectWithoutAddOnInput = {
    where: OrderItemAddOnWhereUniqueInput
    create: XOR<OrderItemAddOnCreateWithoutAddOnInput, OrderItemAddOnUncheckedCreateWithoutAddOnInput>
  }

  export type OrderItemAddOnCreateManyAddOnInputEnvelope = {
    data: OrderItemAddOnCreateManyAddOnInput | OrderItemAddOnCreateManyAddOnInput[]
    skipDuplicates?: boolean
  }

  export type MenuItemAddOnUpsertWithWhereUniqueWithoutAddOnInput = {
    where: MenuItemAddOnWhereUniqueInput
    update: XOR<MenuItemAddOnUpdateWithoutAddOnInput, MenuItemAddOnUncheckedUpdateWithoutAddOnInput>
    create: XOR<MenuItemAddOnCreateWithoutAddOnInput, MenuItemAddOnUncheckedCreateWithoutAddOnInput>
  }

  export type MenuItemAddOnUpdateWithWhereUniqueWithoutAddOnInput = {
    where: MenuItemAddOnWhereUniqueInput
    data: XOR<MenuItemAddOnUpdateWithoutAddOnInput, MenuItemAddOnUncheckedUpdateWithoutAddOnInput>
  }

  export type MenuItemAddOnUpdateManyWithWhereWithoutAddOnInput = {
    where: MenuItemAddOnScalarWhereInput
    data: XOR<MenuItemAddOnUpdateManyMutationInput, MenuItemAddOnUncheckedUpdateManyWithoutAddOnInput>
  }

  export type OrderItemAddOnUpsertWithWhereUniqueWithoutAddOnInput = {
    where: OrderItemAddOnWhereUniqueInput
    update: XOR<OrderItemAddOnUpdateWithoutAddOnInput, OrderItemAddOnUncheckedUpdateWithoutAddOnInput>
    create: XOR<OrderItemAddOnCreateWithoutAddOnInput, OrderItemAddOnUncheckedCreateWithoutAddOnInput>
  }

  export type OrderItemAddOnUpdateWithWhereUniqueWithoutAddOnInput = {
    where: OrderItemAddOnWhereUniqueInput
    data: XOR<OrderItemAddOnUpdateWithoutAddOnInput, OrderItemAddOnUncheckedUpdateWithoutAddOnInput>
  }

  export type OrderItemAddOnUpdateManyWithWhereWithoutAddOnInput = {
    where: OrderItemAddOnScalarWhereInput
    data: XOR<OrderItemAddOnUpdateManyMutationInput, OrderItemAddOnUncheckedUpdateManyWithoutAddOnInput>
  }

  export type OrderItemAddOnScalarWhereInput = {
    AND?: OrderItemAddOnScalarWhereInput | OrderItemAddOnScalarWhereInput[]
    OR?: OrderItemAddOnScalarWhereInput[]
    NOT?: OrderItemAddOnScalarWhereInput | OrderItemAddOnScalarWhereInput[]
    id?: IntFilter<"OrderItemAddOn"> | number
    orderItemId?: IntFilter<"OrderItemAddOn"> | number
    addOnId?: IntNullableFilter<"OrderItemAddOn"> | number | null
    quantity?: IntFilter<"OrderItemAddOn"> | number
    unitPriceCents?: IntFilter<"OrderItemAddOn"> | number
    nameSnapshot?: StringFilter<"OrderItemAddOn"> | string
  }

  export type MenuItemCreateWithoutAddOnLinksInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutItemsInput
    variants?: MenuVariantCreateNestedManyWithoutMenuItemInput
    cateringItems?: CateringItemCreateNestedManyWithoutMenuItemInput
  }

  export type MenuItemUncheckedCreateWithoutAddOnLinksInput = {
    id?: number
    categoryId?: number | null
    name: string
    description?: string | null
    imageUrl?: string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: MenuVariantUncheckedCreateNestedManyWithoutMenuItemInput
    cateringItems?: CateringItemUncheckedCreateNestedManyWithoutMenuItemInput
  }

  export type MenuItemCreateOrConnectWithoutAddOnLinksInput = {
    where: MenuItemWhereUniqueInput
    create: XOR<MenuItemCreateWithoutAddOnLinksInput, MenuItemUncheckedCreateWithoutAddOnLinksInput>
  }

  export type AddOnCreateWithoutItemLinksInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    priceCents: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderLinks?: OrderItemAddOnCreateNestedManyWithoutAddOnInput
  }

  export type AddOnUncheckedCreateWithoutItemLinksInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    priceCents: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderLinks?: OrderItemAddOnUncheckedCreateNestedManyWithoutAddOnInput
  }

  export type AddOnCreateOrConnectWithoutItemLinksInput = {
    where: AddOnWhereUniqueInput
    create: XOR<AddOnCreateWithoutItemLinksInput, AddOnUncheckedCreateWithoutItemLinksInput>
  }

  export type MenuItemUpsertWithoutAddOnLinksInput = {
    update: XOR<MenuItemUpdateWithoutAddOnLinksInput, MenuItemUncheckedUpdateWithoutAddOnLinksInput>
    create: XOR<MenuItemCreateWithoutAddOnLinksInput, MenuItemUncheckedCreateWithoutAddOnLinksInput>
    where?: MenuItemWhereInput
  }

  export type MenuItemUpdateToOneWithWhereWithoutAddOnLinksInput = {
    where?: MenuItemWhereInput
    data: XOR<MenuItemUpdateWithoutAddOnLinksInput, MenuItemUncheckedUpdateWithoutAddOnLinksInput>
  }

  export type MenuItemUpdateWithoutAddOnLinksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutItemsNestedInput
    variants?: MenuVariantUpdateManyWithoutMenuItemNestedInput
    cateringItems?: CateringItemUpdateManyWithoutMenuItemNestedInput
  }

  export type MenuItemUncheckedUpdateWithoutAddOnLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: MenuVariantUncheckedUpdateManyWithoutMenuItemNestedInput
    cateringItems?: CateringItemUncheckedUpdateManyWithoutMenuItemNestedInput
  }

  export type AddOnUpsertWithoutItemLinksInput = {
    update: XOR<AddOnUpdateWithoutItemLinksInput, AddOnUncheckedUpdateWithoutItemLinksInput>
    create: XOR<AddOnCreateWithoutItemLinksInput, AddOnUncheckedCreateWithoutItemLinksInput>
    where?: AddOnWhereInput
  }

  export type AddOnUpdateToOneWithWhereWithoutItemLinksInput = {
    where?: AddOnWhereInput
    data: XOR<AddOnUpdateWithoutItemLinksInput, AddOnUncheckedUpdateWithoutItemLinksInput>
  }

  export type AddOnUpdateWithoutItemLinksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderLinks?: OrderItemAddOnUpdateManyWithoutAddOnNestedInput
  }

  export type AddOnUncheckedUpdateWithoutItemLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderLinks?: OrderItemAddOnUncheckedUpdateManyWithoutAddOnNestedInput
  }

  export type MenuCreateWithoutServiceDayInput = {
    menuType?: $Enums.MenuType
    title?: string | null
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offerings?: MenuOfferingCreateNestedManyWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutServiceDayInput = {
    id?: number
    menuType?: $Enums.MenuType
    title?: string | null
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offerings?: MenuOfferingUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuCreateOrConnectWithoutServiceDayInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutServiceDayInput, MenuUncheckedCreateWithoutServiceDayInput>
  }

  export type MenuCreateManyServiceDayInputEnvelope = {
    data: MenuCreateManyServiceDayInput | MenuCreateManyServiceDayInput[]
    skipDuplicates?: boolean
  }

  export type ServiceSlotCreateWithoutServiceDayInput = {
    fulfillmentType: $Enums.FulfillmentType
    slotKey: string
    capacityOverride?: number | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    template: SlotTemplateCreateNestedOneWithoutServiceSlotsInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutServiceSlotsInput
    groups?: FulfillmentGroupCreateNestedManyWithoutServiceSlotInput
  }

  export type ServiceSlotUncheckedCreateWithoutServiceDayInput = {
    id?: number
    slotTemplateId: number
    fulfillmentType: $Enums.FulfillmentType
    pickupLocationId?: number | null
    slotKey: string
    capacityOverride?: number | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutServiceSlotInput
  }

  export type ServiceSlotCreateOrConnectWithoutServiceDayInput = {
    where: ServiceSlotWhereUniqueInput
    create: XOR<ServiceSlotCreateWithoutServiceDayInput, ServiceSlotUncheckedCreateWithoutServiceDayInput>
  }

  export type ServiceSlotCreateManyServiceDayInputEnvelope = {
    data: ServiceSlotCreateManyServiceDayInput | ServiceSlotCreateManyServiceDayInput[]
    skipDuplicates?: boolean
  }

  export type FulfillmentGroupCreateWithoutServiceDayInput = {
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutGroupsInput
    serviceSlot?: ServiceSlotCreateNestedOneWithoutGroupsInput
    items?: OrderItemCreateNestedManyWithoutGroupInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutGroupInput
    events?: OrderEventCreateNestedManyWithoutGroupInput
  }

  export type FulfillmentGroupUncheckedCreateWithoutServiceDayInput = {
    id?: number
    orderId: number
    serviceSlotId?: number | null
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutGroupInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutGroupInput
    events?: OrderEventUncheckedCreateNestedManyWithoutGroupInput
  }

  export type FulfillmentGroupCreateOrConnectWithoutServiceDayInput = {
    where: FulfillmentGroupWhereUniqueInput
    create: XOR<FulfillmentGroupCreateWithoutServiceDayInput, FulfillmentGroupUncheckedCreateWithoutServiceDayInput>
  }

  export type FulfillmentGroupCreateManyServiceDayInputEnvelope = {
    data: FulfillmentGroupCreateManyServiceDayInput | FulfillmentGroupCreateManyServiceDayInput[]
    skipDuplicates?: boolean
  }

  export type MenuUpsertWithWhereUniqueWithoutServiceDayInput = {
    where: MenuWhereUniqueInput
    update: XOR<MenuUpdateWithoutServiceDayInput, MenuUncheckedUpdateWithoutServiceDayInput>
    create: XOR<MenuCreateWithoutServiceDayInput, MenuUncheckedCreateWithoutServiceDayInput>
  }

  export type MenuUpdateWithWhereUniqueWithoutServiceDayInput = {
    where: MenuWhereUniqueInput
    data: XOR<MenuUpdateWithoutServiceDayInput, MenuUncheckedUpdateWithoutServiceDayInput>
  }

  export type MenuUpdateManyWithWhereWithoutServiceDayInput = {
    where: MenuScalarWhereInput
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyWithoutServiceDayInput>
  }

  export type MenuScalarWhereInput = {
    AND?: MenuScalarWhereInput | MenuScalarWhereInput[]
    OR?: MenuScalarWhereInput[]
    NOT?: MenuScalarWhereInput | MenuScalarWhereInput[]
    id?: IntFilter<"Menu"> | number
    serviceDayId?: IntFilter<"Menu"> | number
    menuType?: EnumMenuTypeFilter<"Menu"> | $Enums.MenuType
    title?: StringNullableFilter<"Menu"> | string | null
    isPublished?: BoolFilter<"Menu"> | boolean
    displayOrder?: IntFilter<"Menu"> | number
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
  }

  export type ServiceSlotUpsertWithWhereUniqueWithoutServiceDayInput = {
    where: ServiceSlotWhereUniqueInput
    update: XOR<ServiceSlotUpdateWithoutServiceDayInput, ServiceSlotUncheckedUpdateWithoutServiceDayInput>
    create: XOR<ServiceSlotCreateWithoutServiceDayInput, ServiceSlotUncheckedCreateWithoutServiceDayInput>
  }

  export type ServiceSlotUpdateWithWhereUniqueWithoutServiceDayInput = {
    where: ServiceSlotWhereUniqueInput
    data: XOR<ServiceSlotUpdateWithoutServiceDayInput, ServiceSlotUncheckedUpdateWithoutServiceDayInput>
  }

  export type ServiceSlotUpdateManyWithWhereWithoutServiceDayInput = {
    where: ServiceSlotScalarWhereInput
    data: XOR<ServiceSlotUpdateManyMutationInput, ServiceSlotUncheckedUpdateManyWithoutServiceDayInput>
  }

  export type ServiceSlotScalarWhereInput = {
    AND?: ServiceSlotScalarWhereInput | ServiceSlotScalarWhereInput[]
    OR?: ServiceSlotScalarWhereInput[]
    NOT?: ServiceSlotScalarWhereInput | ServiceSlotScalarWhereInput[]
    id?: IntFilter<"ServiceSlot"> | number
    serviceDayId?: IntFilter<"ServiceSlot"> | number
    slotTemplateId?: IntFilter<"ServiceSlot"> | number
    fulfillmentType?: EnumFulfillmentTypeFilter<"ServiceSlot"> | $Enums.FulfillmentType
    pickupLocationId?: IntNullableFilter<"ServiceSlot"> | number | null
    slotKey?: StringFilter<"ServiceSlot"> | string
    capacityOverride?: IntNullableFilter<"ServiceSlot"> | number | null
    isClosed?: BoolFilter<"ServiceSlot"> | boolean
    createdAt?: DateTimeFilter<"ServiceSlot"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceSlot"> | Date | string
  }

  export type FulfillmentGroupUpsertWithWhereUniqueWithoutServiceDayInput = {
    where: FulfillmentGroupWhereUniqueInput
    update: XOR<FulfillmentGroupUpdateWithoutServiceDayInput, FulfillmentGroupUncheckedUpdateWithoutServiceDayInput>
    create: XOR<FulfillmentGroupCreateWithoutServiceDayInput, FulfillmentGroupUncheckedCreateWithoutServiceDayInput>
  }

  export type FulfillmentGroupUpdateWithWhereUniqueWithoutServiceDayInput = {
    where: FulfillmentGroupWhereUniqueInput
    data: XOR<FulfillmentGroupUpdateWithoutServiceDayInput, FulfillmentGroupUncheckedUpdateWithoutServiceDayInput>
  }

  export type FulfillmentGroupUpdateManyWithWhereWithoutServiceDayInput = {
    where: FulfillmentGroupScalarWhereInput
    data: XOR<FulfillmentGroupUpdateManyMutationInput, FulfillmentGroupUncheckedUpdateManyWithoutServiceDayInput>
  }

  export type FulfillmentGroupScalarWhereInput = {
    AND?: FulfillmentGroupScalarWhereInput | FulfillmentGroupScalarWhereInput[]
    OR?: FulfillmentGroupScalarWhereInput[]
    NOT?: FulfillmentGroupScalarWhereInput | FulfillmentGroupScalarWhereInput[]
    id?: IntFilter<"FulfillmentGroup"> | number
    orderId?: IntFilter<"FulfillmentGroup"> | number
    serviceDayId?: IntFilter<"FulfillmentGroup"> | number
    serviceSlotId?: IntNullableFilter<"FulfillmentGroup"> | number | null
    status?: EnumFulfillmentGroupStatusFilter<"FulfillmentGroup"> | $Enums.FulfillmentGroupStatus
    sequence?: IntFilter<"FulfillmentGroup"> | number
    createdAt?: DateTimeFilter<"FulfillmentGroup"> | Date | string
    updatedAt?: DateTimeFilter<"FulfillmentGroup"> | Date | string
  }

  export type ServiceDayCreateWithoutMenusInput = {
    menuDate: Date | string
    serviceDate: Date | string
    label?: string | null
    isPublished?: boolean
    isClosed?: boolean
    closedReason?: string | null
    orderingCutoffAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    slots?: ServiceSlotCreateNestedManyWithoutServiceDayInput
    groups?: FulfillmentGroupCreateNestedManyWithoutServiceDayInput
  }

  export type ServiceDayUncheckedCreateWithoutMenusInput = {
    id?: number
    menuDate: Date | string
    serviceDate: Date | string
    label?: string | null
    isPublished?: boolean
    isClosed?: boolean
    closedReason?: string | null
    orderingCutoffAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    slots?: ServiceSlotUncheckedCreateNestedManyWithoutServiceDayInput
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutServiceDayInput
  }

  export type ServiceDayCreateOrConnectWithoutMenusInput = {
    where: ServiceDayWhereUniqueInput
    create: XOR<ServiceDayCreateWithoutMenusInput, ServiceDayUncheckedCreateWithoutMenusInput>
  }

  export type MenuOfferingCreateWithoutMenuInput = {
    priceOverrideCents?: number | null
    capacityOverride?: number | null
    isAvailable?: boolean
    maxPerOrder?: number | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variant: MenuVariantCreateNestedOneWithoutOfferingsInput
    holds?: CapacityHoldCreateNestedManyWithoutOfferingInput
  }

  export type MenuOfferingUncheckedCreateWithoutMenuInput = {
    id?: number
    menuVariantId: number
    priceOverrideCents?: number | null
    capacityOverride?: number | null
    isAvailable?: boolean
    maxPerOrder?: number | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holds?: CapacityHoldUncheckedCreateNestedManyWithoutOfferingInput
  }

  export type MenuOfferingCreateOrConnectWithoutMenuInput = {
    where: MenuOfferingWhereUniqueInput
    create: XOR<MenuOfferingCreateWithoutMenuInput, MenuOfferingUncheckedCreateWithoutMenuInput>
  }

  export type MenuOfferingCreateManyMenuInputEnvelope = {
    data: MenuOfferingCreateManyMenuInput | MenuOfferingCreateManyMenuInput[]
    skipDuplicates?: boolean
  }

  export type ServiceDayUpsertWithoutMenusInput = {
    update: XOR<ServiceDayUpdateWithoutMenusInput, ServiceDayUncheckedUpdateWithoutMenusInput>
    create: XOR<ServiceDayCreateWithoutMenusInput, ServiceDayUncheckedCreateWithoutMenusInput>
    where?: ServiceDayWhereInput
  }

  export type ServiceDayUpdateToOneWithWhereWithoutMenusInput = {
    where?: ServiceDayWhereInput
    data: XOR<ServiceDayUpdateWithoutMenusInput, ServiceDayUncheckedUpdateWithoutMenusInput>
  }

  export type ServiceDayUpdateWithoutMenusInput = {
    menuDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    orderingCutoffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slots?: ServiceSlotUpdateManyWithoutServiceDayNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutServiceDayNestedInput
  }

  export type ServiceDayUncheckedUpdateWithoutMenusInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    orderingCutoffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slots?: ServiceSlotUncheckedUpdateManyWithoutServiceDayNestedInput
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutServiceDayNestedInput
  }

  export type MenuOfferingUpsertWithWhereUniqueWithoutMenuInput = {
    where: MenuOfferingWhereUniqueInput
    update: XOR<MenuOfferingUpdateWithoutMenuInput, MenuOfferingUncheckedUpdateWithoutMenuInput>
    create: XOR<MenuOfferingCreateWithoutMenuInput, MenuOfferingUncheckedCreateWithoutMenuInput>
  }

  export type MenuOfferingUpdateWithWhereUniqueWithoutMenuInput = {
    where: MenuOfferingWhereUniqueInput
    data: XOR<MenuOfferingUpdateWithoutMenuInput, MenuOfferingUncheckedUpdateWithoutMenuInput>
  }

  export type MenuOfferingUpdateManyWithWhereWithoutMenuInput = {
    where: MenuOfferingScalarWhereInput
    data: XOR<MenuOfferingUpdateManyMutationInput, MenuOfferingUncheckedUpdateManyWithoutMenuInput>
  }

  export type MenuCreateWithoutOfferingsInput = {
    menuType?: $Enums.MenuType
    title?: string | null
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceDay: ServiceDayCreateNestedOneWithoutMenusInput
  }

  export type MenuUncheckedCreateWithoutOfferingsInput = {
    id?: number
    serviceDayId: number
    menuType?: $Enums.MenuType
    title?: string | null
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuCreateOrConnectWithoutOfferingsInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutOfferingsInput, MenuUncheckedCreateWithoutOfferingsInput>
  }

  export type MenuVariantCreateWithoutOfferingsInput = {
    label: string
    basePriceCents: number
    baseCapacity?: number | null
    isActive?: boolean
    prepMinutes?: number | null
    packagingCostCents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menuItem: MenuItemCreateNestedOneWithoutVariantsInput
    orderItems?: OrderItemCreateNestedManyWithoutVariantInput
  }

  export type MenuVariantUncheckedCreateWithoutOfferingsInput = {
    id?: number
    menuItemId: number
    label: string
    basePriceCents: number
    baseCapacity?: number | null
    isActive?: boolean
    prepMinutes?: number | null
    packagingCostCents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutVariantInput
  }

  export type MenuVariantCreateOrConnectWithoutOfferingsInput = {
    where: MenuVariantWhereUniqueInput
    create: XOR<MenuVariantCreateWithoutOfferingsInput, MenuVariantUncheckedCreateWithoutOfferingsInput>
  }

  export type CapacityHoldCreateWithoutOfferingInput = {
    quantity: number
    status?: $Enums.HoldStatus
    expiresAt: Date | string
    createdAt?: Date | string
    order?: OrderCreateNestedOneWithoutCapacityHoldsInput
  }

  export type CapacityHoldUncheckedCreateWithoutOfferingInput = {
    id?: number
    orderId?: number | null
    quantity: number
    status?: $Enums.HoldStatus
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type CapacityHoldCreateOrConnectWithoutOfferingInput = {
    where: CapacityHoldWhereUniqueInput
    create: XOR<CapacityHoldCreateWithoutOfferingInput, CapacityHoldUncheckedCreateWithoutOfferingInput>
  }

  export type CapacityHoldCreateManyOfferingInputEnvelope = {
    data: CapacityHoldCreateManyOfferingInput | CapacityHoldCreateManyOfferingInput[]
    skipDuplicates?: boolean
  }

  export type MenuUpsertWithoutOfferingsInput = {
    update: XOR<MenuUpdateWithoutOfferingsInput, MenuUncheckedUpdateWithoutOfferingsInput>
    create: XOR<MenuCreateWithoutOfferingsInput, MenuUncheckedCreateWithoutOfferingsInput>
    where?: MenuWhereInput
  }

  export type MenuUpdateToOneWithWhereWithoutOfferingsInput = {
    where?: MenuWhereInput
    data: XOR<MenuUpdateWithoutOfferingsInput, MenuUncheckedUpdateWithoutOfferingsInput>
  }

  export type MenuUpdateWithoutOfferingsInput = {
    menuType?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDay?: ServiceDayUpdateOneRequiredWithoutMenusNestedInput
  }

  export type MenuUncheckedUpdateWithoutOfferingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    menuType?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuVariantUpsertWithoutOfferingsInput = {
    update: XOR<MenuVariantUpdateWithoutOfferingsInput, MenuVariantUncheckedUpdateWithoutOfferingsInput>
    create: XOR<MenuVariantCreateWithoutOfferingsInput, MenuVariantUncheckedCreateWithoutOfferingsInput>
    where?: MenuVariantWhereInput
  }

  export type MenuVariantUpdateToOneWithWhereWithoutOfferingsInput = {
    where?: MenuVariantWhereInput
    data: XOR<MenuVariantUpdateWithoutOfferingsInput, MenuVariantUncheckedUpdateWithoutOfferingsInput>
  }

  export type MenuVariantUpdateWithoutOfferingsInput = {
    label?: StringFieldUpdateOperationsInput | string
    basePriceCents?: IntFieldUpdateOperationsInput | number
    baseCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prepMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    packagingCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuItem?: MenuItemUpdateOneRequiredWithoutVariantsNestedInput
    orderItems?: OrderItemUpdateManyWithoutVariantNestedInput
  }

  export type MenuVariantUncheckedUpdateWithoutOfferingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuItemId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    basePriceCents?: IntFieldUpdateOperationsInput | number
    baseCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prepMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    packagingCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type CapacityHoldUpsertWithWhereUniqueWithoutOfferingInput = {
    where: CapacityHoldWhereUniqueInput
    update: XOR<CapacityHoldUpdateWithoutOfferingInput, CapacityHoldUncheckedUpdateWithoutOfferingInput>
    create: XOR<CapacityHoldCreateWithoutOfferingInput, CapacityHoldUncheckedCreateWithoutOfferingInput>
  }

  export type CapacityHoldUpdateWithWhereUniqueWithoutOfferingInput = {
    where: CapacityHoldWhereUniqueInput
    data: XOR<CapacityHoldUpdateWithoutOfferingInput, CapacityHoldUncheckedUpdateWithoutOfferingInput>
  }

  export type CapacityHoldUpdateManyWithWhereWithoutOfferingInput = {
    where: CapacityHoldScalarWhereInput
    data: XOR<CapacityHoldUpdateManyMutationInput, CapacityHoldUncheckedUpdateManyWithoutOfferingInput>
  }

  export type CapacityHoldScalarWhereInput = {
    AND?: CapacityHoldScalarWhereInput | CapacityHoldScalarWhereInput[]
    OR?: CapacityHoldScalarWhereInput[]
    NOT?: CapacityHoldScalarWhereInput | CapacityHoldScalarWhereInput[]
    id?: IntFilter<"CapacityHold"> | number
    menuOfferingId?: IntFilter<"CapacityHold"> | number
    orderId?: IntNullableFilter<"CapacityHold"> | number | null
    quantity?: IntFilter<"CapacityHold"> | number
    status?: EnumHoldStatusFilter<"CapacityHold"> | $Enums.HoldStatus
    expiresAt?: DateTimeFilter<"CapacityHold"> | Date | string
    createdAt?: DateTimeFilter<"CapacityHold"> | Date | string
  }

  export type ServiceSlotCreateWithoutPickupLocationInput = {
    fulfillmentType: $Enums.FulfillmentType
    slotKey: string
    capacityOverride?: number | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceDay: ServiceDayCreateNestedOneWithoutSlotsInput
    template: SlotTemplateCreateNestedOneWithoutServiceSlotsInput
    groups?: FulfillmentGroupCreateNestedManyWithoutServiceSlotInput
  }

  export type ServiceSlotUncheckedCreateWithoutPickupLocationInput = {
    id?: number
    serviceDayId: number
    slotTemplateId: number
    fulfillmentType: $Enums.FulfillmentType
    slotKey: string
    capacityOverride?: number | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutServiceSlotInput
  }

  export type ServiceSlotCreateOrConnectWithoutPickupLocationInput = {
    where: ServiceSlotWhereUniqueInput
    create: XOR<ServiceSlotCreateWithoutPickupLocationInput, ServiceSlotUncheckedCreateWithoutPickupLocationInput>
  }

  export type ServiceSlotCreateManyPickupLocationInputEnvelope = {
    data: ServiceSlotCreateManyPickupLocationInput | ServiceSlotCreateManyPickupLocationInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutPickupLocationInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    createdBy?: UserCreateNestedOneWithoutCreatedOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutDeliveryOrdersInput
    groups?: FulfillmentGroupCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    events?: OrderEventCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPickupLocationInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    events?: OrderEventUncheckedCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldUncheckedCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPickupLocationInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPickupLocationInput, OrderUncheckedCreateWithoutPickupLocationInput>
  }

  export type OrderCreateManyPickupLocationInputEnvelope = {
    data: OrderCreateManyPickupLocationInput | OrderCreateManyPickupLocationInput[]
    skipDuplicates?: boolean
  }

  export type ServiceSlotUpsertWithWhereUniqueWithoutPickupLocationInput = {
    where: ServiceSlotWhereUniqueInput
    update: XOR<ServiceSlotUpdateWithoutPickupLocationInput, ServiceSlotUncheckedUpdateWithoutPickupLocationInput>
    create: XOR<ServiceSlotCreateWithoutPickupLocationInput, ServiceSlotUncheckedCreateWithoutPickupLocationInput>
  }

  export type ServiceSlotUpdateWithWhereUniqueWithoutPickupLocationInput = {
    where: ServiceSlotWhereUniqueInput
    data: XOR<ServiceSlotUpdateWithoutPickupLocationInput, ServiceSlotUncheckedUpdateWithoutPickupLocationInput>
  }

  export type ServiceSlotUpdateManyWithWhereWithoutPickupLocationInput = {
    where: ServiceSlotScalarWhereInput
    data: XOR<ServiceSlotUpdateManyMutationInput, ServiceSlotUncheckedUpdateManyWithoutPickupLocationInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutPickupLocationInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutPickupLocationInput, OrderUncheckedUpdateWithoutPickupLocationInput>
    create: XOR<OrderCreateWithoutPickupLocationInput, OrderUncheckedCreateWithoutPickupLocationInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutPickupLocationInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutPickupLocationInput, OrderUncheckedUpdateWithoutPickupLocationInput>
  }

  export type OrderUpdateManyWithWhereWithoutPickupLocationInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutPickupLocationInput>
  }

  export type UserCreateWithoutAddressesInput = {
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    cateringOrders?: CateringOrderCreateNestedManyWithoutUserInput
    createdCateringOrders?: CateringOrderCreateNestedManyWithoutCreatedByInput
    rewardAccount?: RewardAccountCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    promotionRedemptions?: PromotionRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddressesInput = {
    id?: number
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    cateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutUserInput
    createdCateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutCreatedByInput
    rewardAccount?: RewardAccountUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    promotionRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddressesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
  }

  export type OrderCreateWithoutDeliveryAddressInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    createdBy?: UserCreateNestedOneWithoutCreatedOrdersInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutOrdersInput
    groups?: FulfillmentGroupCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    events?: OrderEventCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutDeliveryAddressInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    events?: OrderEventUncheckedCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldUncheckedCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutDeliveryAddressInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutDeliveryAddressInput, OrderUncheckedCreateWithoutDeliveryAddressInput>
  }

  export type OrderCreateManyDeliveryAddressInputEnvelope = {
    data: OrderCreateManyDeliveryAddressInput | OrderCreateManyDeliveryAddressInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAddressesInput = {
    update: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddressesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>
  }

  export type UserUpdateWithoutAddressesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    cateringOrders?: CateringOrderUpdateManyWithoutUserNestedInput
    createdCateringOrders?: CateringOrderUpdateManyWithoutCreatedByNestedInput
    rewardAccount?: RewardAccountUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    cateringOrders?: CateringOrderUncheckedUpdateManyWithoutUserNestedInput
    createdCateringOrders?: CateringOrderUncheckedUpdateManyWithoutCreatedByNestedInput
    rewardAccount?: RewardAccountUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutDeliveryAddressInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutDeliveryAddressInput, OrderUncheckedUpdateWithoutDeliveryAddressInput>
    create: XOR<OrderCreateWithoutDeliveryAddressInput, OrderUncheckedCreateWithoutDeliveryAddressInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutDeliveryAddressInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutDeliveryAddressInput, OrderUncheckedUpdateWithoutDeliveryAddressInput>
  }

  export type OrderUpdateManyWithWhereWithoutDeliveryAddressInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutDeliveryAddressInput>
  }

  export type ServiceSlotCreateWithoutTemplateInput = {
    fulfillmentType: $Enums.FulfillmentType
    slotKey: string
    capacityOverride?: number | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceDay: ServiceDayCreateNestedOneWithoutSlotsInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutServiceSlotsInput
    groups?: FulfillmentGroupCreateNestedManyWithoutServiceSlotInput
  }

  export type ServiceSlotUncheckedCreateWithoutTemplateInput = {
    id?: number
    serviceDayId: number
    fulfillmentType: $Enums.FulfillmentType
    pickupLocationId?: number | null
    slotKey: string
    capacityOverride?: number | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutServiceSlotInput
  }

  export type ServiceSlotCreateOrConnectWithoutTemplateInput = {
    where: ServiceSlotWhereUniqueInput
    create: XOR<ServiceSlotCreateWithoutTemplateInput, ServiceSlotUncheckedCreateWithoutTemplateInput>
  }

  export type ServiceSlotCreateManyTemplateInputEnvelope = {
    data: ServiceSlotCreateManyTemplateInput | ServiceSlotCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type ServiceSlotUpsertWithWhereUniqueWithoutTemplateInput = {
    where: ServiceSlotWhereUniqueInput
    update: XOR<ServiceSlotUpdateWithoutTemplateInput, ServiceSlotUncheckedUpdateWithoutTemplateInput>
    create: XOR<ServiceSlotCreateWithoutTemplateInput, ServiceSlotUncheckedCreateWithoutTemplateInput>
  }

  export type ServiceSlotUpdateWithWhereUniqueWithoutTemplateInput = {
    where: ServiceSlotWhereUniqueInput
    data: XOR<ServiceSlotUpdateWithoutTemplateInput, ServiceSlotUncheckedUpdateWithoutTemplateInput>
  }

  export type ServiceSlotUpdateManyWithWhereWithoutTemplateInput = {
    where: ServiceSlotScalarWhereInput
    data: XOR<ServiceSlotUpdateManyMutationInput, ServiceSlotUncheckedUpdateManyWithoutTemplateInput>
  }

  export type ServiceDayCreateWithoutSlotsInput = {
    menuDate: Date | string
    serviceDate: Date | string
    label?: string | null
    isPublished?: boolean
    isClosed?: boolean
    closedReason?: string | null
    orderingCutoffAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menus?: MenuCreateNestedManyWithoutServiceDayInput
    groups?: FulfillmentGroupCreateNestedManyWithoutServiceDayInput
  }

  export type ServiceDayUncheckedCreateWithoutSlotsInput = {
    id?: number
    menuDate: Date | string
    serviceDate: Date | string
    label?: string | null
    isPublished?: boolean
    isClosed?: boolean
    closedReason?: string | null
    orderingCutoffAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menus?: MenuUncheckedCreateNestedManyWithoutServiceDayInput
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutServiceDayInput
  }

  export type ServiceDayCreateOrConnectWithoutSlotsInput = {
    where: ServiceDayWhereUniqueInput
    create: XOR<ServiceDayCreateWithoutSlotsInput, ServiceDayUncheckedCreateWithoutSlotsInput>
  }

  export type SlotTemplateCreateWithoutServiceSlotsInput = {
    label: string
    startMin: number
    endMin: number
    defaultCapacity?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlotTemplateUncheckedCreateWithoutServiceSlotsInput = {
    id?: number
    label: string
    startMin: number
    endMin: number
    defaultCapacity?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlotTemplateCreateOrConnectWithoutServiceSlotsInput = {
    where: SlotTemplateWhereUniqueInput
    create: XOR<SlotTemplateCreateWithoutServiceSlotsInput, SlotTemplateUncheckedCreateWithoutServiceSlotsInput>
  }

  export type PickupLocationCreateWithoutServiceSlotsInput = {
    name: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    timezone?: string | null
    instructions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutPickupLocationInput
  }

  export type PickupLocationUncheckedCreateWithoutServiceSlotsInput = {
    id?: number
    name: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    timezone?: string | null
    instructions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutPickupLocationInput
  }

  export type PickupLocationCreateOrConnectWithoutServiceSlotsInput = {
    where: PickupLocationWhereUniqueInput
    create: XOR<PickupLocationCreateWithoutServiceSlotsInput, PickupLocationUncheckedCreateWithoutServiceSlotsInput>
  }

  export type FulfillmentGroupCreateWithoutServiceSlotInput = {
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutGroupsInput
    serviceDay: ServiceDayCreateNestedOneWithoutGroupsInput
    items?: OrderItemCreateNestedManyWithoutGroupInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutGroupInput
    events?: OrderEventCreateNestedManyWithoutGroupInput
  }

  export type FulfillmentGroupUncheckedCreateWithoutServiceSlotInput = {
    id?: number
    orderId: number
    serviceDayId: number
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutGroupInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutGroupInput
    events?: OrderEventUncheckedCreateNestedManyWithoutGroupInput
  }

  export type FulfillmentGroupCreateOrConnectWithoutServiceSlotInput = {
    where: FulfillmentGroupWhereUniqueInput
    create: XOR<FulfillmentGroupCreateWithoutServiceSlotInput, FulfillmentGroupUncheckedCreateWithoutServiceSlotInput>
  }

  export type FulfillmentGroupCreateManyServiceSlotInputEnvelope = {
    data: FulfillmentGroupCreateManyServiceSlotInput | FulfillmentGroupCreateManyServiceSlotInput[]
    skipDuplicates?: boolean
  }

  export type ServiceDayUpsertWithoutSlotsInput = {
    update: XOR<ServiceDayUpdateWithoutSlotsInput, ServiceDayUncheckedUpdateWithoutSlotsInput>
    create: XOR<ServiceDayCreateWithoutSlotsInput, ServiceDayUncheckedCreateWithoutSlotsInput>
    where?: ServiceDayWhereInput
  }

  export type ServiceDayUpdateToOneWithWhereWithoutSlotsInput = {
    where?: ServiceDayWhereInput
    data: XOR<ServiceDayUpdateWithoutSlotsInput, ServiceDayUncheckedUpdateWithoutSlotsInput>
  }

  export type ServiceDayUpdateWithoutSlotsInput = {
    menuDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    orderingCutoffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menus?: MenuUpdateManyWithoutServiceDayNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutServiceDayNestedInput
  }

  export type ServiceDayUncheckedUpdateWithoutSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    orderingCutoffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menus?: MenuUncheckedUpdateManyWithoutServiceDayNestedInput
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutServiceDayNestedInput
  }

  export type SlotTemplateUpsertWithoutServiceSlotsInput = {
    update: XOR<SlotTemplateUpdateWithoutServiceSlotsInput, SlotTemplateUncheckedUpdateWithoutServiceSlotsInput>
    create: XOR<SlotTemplateCreateWithoutServiceSlotsInput, SlotTemplateUncheckedCreateWithoutServiceSlotsInput>
    where?: SlotTemplateWhereInput
  }

  export type SlotTemplateUpdateToOneWithWhereWithoutServiceSlotsInput = {
    where?: SlotTemplateWhereInput
    data: XOR<SlotTemplateUpdateWithoutServiceSlotsInput, SlotTemplateUncheckedUpdateWithoutServiceSlotsInput>
  }

  export type SlotTemplateUpdateWithoutServiceSlotsInput = {
    label?: StringFieldUpdateOperationsInput | string
    startMin?: IntFieldUpdateOperationsInput | number
    endMin?: IntFieldUpdateOperationsInput | number
    defaultCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlotTemplateUncheckedUpdateWithoutServiceSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    startMin?: IntFieldUpdateOperationsInput | number
    endMin?: IntFieldUpdateOperationsInput | number
    defaultCapacity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PickupLocationUpsertWithoutServiceSlotsInput = {
    update: XOR<PickupLocationUpdateWithoutServiceSlotsInput, PickupLocationUncheckedUpdateWithoutServiceSlotsInput>
    create: XOR<PickupLocationCreateWithoutServiceSlotsInput, PickupLocationUncheckedCreateWithoutServiceSlotsInput>
    where?: PickupLocationWhereInput
  }

  export type PickupLocationUpdateToOneWithWhereWithoutServiceSlotsInput = {
    where?: PickupLocationWhereInput
    data: XOR<PickupLocationUpdateWithoutServiceSlotsInput, PickupLocationUncheckedUpdateWithoutServiceSlotsInput>
  }

  export type PickupLocationUpdateWithoutServiceSlotsInput = {
    name?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutPickupLocationNestedInput
  }

  export type PickupLocationUncheckedUpdateWithoutServiceSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutPickupLocationNestedInput
  }

  export type FulfillmentGroupUpsertWithWhereUniqueWithoutServiceSlotInput = {
    where: FulfillmentGroupWhereUniqueInput
    update: XOR<FulfillmentGroupUpdateWithoutServiceSlotInput, FulfillmentGroupUncheckedUpdateWithoutServiceSlotInput>
    create: XOR<FulfillmentGroupCreateWithoutServiceSlotInput, FulfillmentGroupUncheckedCreateWithoutServiceSlotInput>
  }

  export type FulfillmentGroupUpdateWithWhereUniqueWithoutServiceSlotInput = {
    where: FulfillmentGroupWhereUniqueInput
    data: XOR<FulfillmentGroupUpdateWithoutServiceSlotInput, FulfillmentGroupUncheckedUpdateWithoutServiceSlotInput>
  }

  export type FulfillmentGroupUpdateManyWithWhereWithoutServiceSlotInput = {
    where: FulfillmentGroupScalarWhereInput
    data: XOR<FulfillmentGroupUpdateManyMutationInput, FulfillmentGroupUncheckedUpdateManyWithoutServiceSlotInput>
  }

  export type UserCreateWithoutOrdersInput = {
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    cateringOrders?: CateringOrderCreateNestedManyWithoutUserInput
    createdCateringOrders?: CateringOrderCreateNestedManyWithoutCreatedByInput
    rewardAccount?: RewardAccountCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    promotionRedemptions?: PromotionRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: number
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    cateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutUserInput
    createdCateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutCreatedByInput
    rewardAccount?: RewardAccountUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    promotionRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type UserCreateWithoutCreatedOrdersInput = {
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    cateringOrders?: CateringOrderCreateNestedManyWithoutUserInput
    createdCateringOrders?: CateringOrderCreateNestedManyWithoutCreatedByInput
    rewardAccount?: RewardAccountCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    promotionRedemptions?: PromotionRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedOrdersInput = {
    id?: number
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    cateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutUserInput
    createdCateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutCreatedByInput
    rewardAccount?: RewardAccountUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    promotionRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedOrdersInput, UserUncheckedCreateWithoutCreatedOrdersInput>
  }

  export type PickupLocationCreateWithoutOrdersInput = {
    name: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    timezone?: string | null
    instructions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceSlots?: ServiceSlotCreateNestedManyWithoutPickupLocationInput
  }

  export type PickupLocationUncheckedCreateWithoutOrdersInput = {
    id?: number
    name: string
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    timezone?: string | null
    instructions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceSlots?: ServiceSlotUncheckedCreateNestedManyWithoutPickupLocationInput
  }

  export type PickupLocationCreateOrConnectWithoutOrdersInput = {
    where: PickupLocationWhereUniqueInput
    create: XOR<PickupLocationCreateWithoutOrdersInput, PickupLocationUncheckedCreateWithoutOrdersInput>
  }

  export type AddressCreateWithoutDeliveryOrdersInput = {
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    lat?: number | null
    lng?: number | null
    isDefault?: boolean
    isSnapshot?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAddressesInput
  }

  export type AddressUncheckedCreateWithoutDeliveryOrdersInput = {
    id?: number
    userId?: number | null
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    lat?: number | null
    lng?: number | null
    isDefault?: boolean
    isSnapshot?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutDeliveryOrdersInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutDeliveryOrdersInput, AddressUncheckedCreateWithoutDeliveryOrdersInput>
  }

  export type FulfillmentGroupCreateWithoutOrderInput = {
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceDay: ServiceDayCreateNestedOneWithoutGroupsInput
    serviceSlot?: ServiceSlotCreateNestedOneWithoutGroupsInput
    items?: OrderItemCreateNestedManyWithoutGroupInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutGroupInput
    events?: OrderEventCreateNestedManyWithoutGroupInput
  }

  export type FulfillmentGroupUncheckedCreateWithoutOrderInput = {
    id?: number
    serviceDayId: number
    serviceSlotId?: number | null
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutGroupInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutGroupInput
    events?: OrderEventUncheckedCreateNestedManyWithoutGroupInput
  }

  export type FulfillmentGroupCreateOrConnectWithoutOrderInput = {
    where: FulfillmentGroupWhereUniqueInput
    create: XOR<FulfillmentGroupCreateWithoutOrderInput, FulfillmentGroupUncheckedCreateWithoutOrderInput>
  }

  export type FulfillmentGroupCreateManyOrderInputEnvelope = {
    data: FulfillmentGroupCreateManyOrderInput | FulfillmentGroupCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutOrderInput = {
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    variantLabelSnapshot: string
    imageUrlSnapshot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    group: FulfillmentGroupCreateNestedOneWithoutItemsInput
    variant: MenuVariantCreateNestedOneWithoutOrderItemsInput
    addOns?: OrderItemAddOnCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    fulfillmentGroupId: number
    menuVariantId: number
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    variantLabelSnapshot: string
    imageUrlSnapshot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addOns?: OrderItemAddOnUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderAdjustmentCreateWithoutOrderInput = {
    type: $Enums.AdjustmentType
    label?: string | null
    amountCents: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    group?: FulfillmentGroupCreateNestedOneWithoutAdjustmentsInput
  }

  export type OrderAdjustmentUncheckedCreateWithoutOrderInput = {
    id?: number
    fulfillmentGroupId?: number | null
    type: $Enums.AdjustmentType
    label?: string | null
    amountCents: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderAdjustmentCreateOrConnectWithoutOrderInput = {
    where: OrderAdjustmentWhereUniqueInput
    create: XOR<OrderAdjustmentCreateWithoutOrderInput, OrderAdjustmentUncheckedCreateWithoutOrderInput>
  }

  export type OrderAdjustmentCreateManyOrderInputEnvelope = {
    data: OrderAdjustmentCreateManyOrderInput | OrderAdjustmentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutOrderInput = {
    provider?: $Enums.PaymentProvider
    method: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    amountCents: number
    providerRef?: string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    receivedBy?: UserCreateNestedOneWithoutPaymentsReceivedInput
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: number
    provider?: $Enums.PaymentProvider
    method: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    amountCents: number
    providerRef?: string | null
    receivedByUserId?: number | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentCreateManyOrderInputEnvelope = {
    data: PaymentCreateManyOrderInput | PaymentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderEventCreateWithoutOrderInput = {
    type: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    group?: FulfillmentGroupCreateNestedOneWithoutEventsInput
  }

  export type OrderEventUncheckedCreateWithoutOrderInput = {
    id?: number
    fulfillmentGroupId?: number | null
    type: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderEventCreateOrConnectWithoutOrderInput = {
    where: OrderEventWhereUniqueInput
    create: XOR<OrderEventCreateWithoutOrderInput, OrderEventUncheckedCreateWithoutOrderInput>
  }

  export type OrderEventCreateManyOrderInputEnvelope = {
    data: OrderEventCreateManyOrderInput | OrderEventCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PromotionRedemptionCreateWithoutOrderInput = {
    discountCentsApplied: number
    createdAt?: Date | string
    promotion: PromotionCreateNestedOneWithoutRedemptionsInput
    user?: UserCreateNestedOneWithoutPromotionRedemptionsInput
  }

  export type PromotionRedemptionUncheckedCreateWithoutOrderInput = {
    id?: number
    promotionId: number
    userId?: number | null
    discountCentsApplied: number
    createdAt?: Date | string
  }

  export type PromotionRedemptionCreateOrConnectWithoutOrderInput = {
    where: PromotionRedemptionWhereUniqueInput
    create: XOR<PromotionRedemptionCreateWithoutOrderInput, PromotionRedemptionUncheckedCreateWithoutOrderInput>
  }

  export type PromotionRedemptionCreateManyOrderInputEnvelope = {
    data: PromotionRedemptionCreateManyOrderInput | PromotionRedemptionCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type CapacityHoldCreateWithoutOrderInput = {
    quantity: number
    status?: $Enums.HoldStatus
    expiresAt: Date | string
    createdAt?: Date | string
    offering: MenuOfferingCreateNestedOneWithoutHoldsInput
  }

  export type CapacityHoldUncheckedCreateWithoutOrderInput = {
    id?: number
    menuOfferingId: number
    quantity: number
    status?: $Enums.HoldStatus
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type CapacityHoldCreateOrConnectWithoutOrderInput = {
    where: CapacityHoldWhereUniqueInput
    create: XOR<CapacityHoldCreateWithoutOrderInput, CapacityHoldUncheckedCreateWithoutOrderInput>
  }

  export type CapacityHoldCreateManyOrderInputEnvelope = {
    data: CapacityHoldCreateManyOrderInput | CapacityHoldCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type RewardTransactionCreateWithoutOrderInput = {
    type: $Enums.RewardTxnType
    amountPoints: number
    note?: string | null
    createdAt?: Date | string
    account: RewardAccountCreateNestedOneWithoutTxnsInput
  }

  export type RewardTransactionUncheckedCreateWithoutOrderInput = {
    id?: number
    rewardAccountId: number
    type: $Enums.RewardTxnType
    amountPoints: number
    note?: string | null
    createdAt?: Date | string
  }

  export type RewardTransactionCreateOrConnectWithoutOrderInput = {
    where: RewardTransactionWhereUniqueInput
    create: XOR<RewardTransactionCreateWithoutOrderInput, RewardTransactionUncheckedCreateWithoutOrderInput>
  }

  export type RewardTransactionCreateManyOrderInputEnvelope = {
    data: RewardTransactionCreateManyOrderInput | RewardTransactionCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutOrderInput = {
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutOrderInput = {
    id?: number
    userId: number
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutOrderInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
  }

  export type ReviewCreateManyOrderInputEnvelope = {
    data: ReviewCreateManyOrderInput | ReviewCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    cateringOrders?: CateringOrderUpdateManyWithoutUserNestedInput
    createdCateringOrders?: CateringOrderUpdateManyWithoutCreatedByNestedInput
    rewardAccount?: RewardAccountUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    cateringOrders?: CateringOrderUncheckedUpdateManyWithoutUserNestedInput
    createdCateringOrders?: CateringOrderUncheckedUpdateManyWithoutCreatedByNestedInput
    rewardAccount?: RewardAccountUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutCreatedOrdersInput = {
    update: XOR<UserUpdateWithoutCreatedOrdersInput, UserUncheckedUpdateWithoutCreatedOrdersInput>
    create: XOR<UserCreateWithoutCreatedOrdersInput, UserUncheckedCreateWithoutCreatedOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedOrdersInput, UserUncheckedUpdateWithoutCreatedOrdersInput>
  }

  export type UserUpdateWithoutCreatedOrdersInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    cateringOrders?: CateringOrderUpdateManyWithoutUserNestedInput
    createdCateringOrders?: CateringOrderUpdateManyWithoutCreatedByNestedInput
    rewardAccount?: RewardAccountUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    cateringOrders?: CateringOrderUncheckedUpdateManyWithoutUserNestedInput
    createdCateringOrders?: CateringOrderUncheckedUpdateManyWithoutCreatedByNestedInput
    rewardAccount?: RewardAccountUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PickupLocationUpsertWithoutOrdersInput = {
    update: XOR<PickupLocationUpdateWithoutOrdersInput, PickupLocationUncheckedUpdateWithoutOrdersInput>
    create: XOR<PickupLocationCreateWithoutOrdersInput, PickupLocationUncheckedCreateWithoutOrdersInput>
    where?: PickupLocationWhereInput
  }

  export type PickupLocationUpdateToOneWithWhereWithoutOrdersInput = {
    where?: PickupLocationWhereInput
    data: XOR<PickupLocationUpdateWithoutOrdersInput, PickupLocationUncheckedUpdateWithoutOrdersInput>
  }

  export type PickupLocationUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceSlots?: ServiceSlotUpdateManyWithoutPickupLocationNestedInput
  }

  export type PickupLocationUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceSlots?: ServiceSlotUncheckedUpdateManyWithoutPickupLocationNestedInput
  }

  export type AddressUpsertWithoutDeliveryOrdersInput = {
    update: XOR<AddressUpdateWithoutDeliveryOrdersInput, AddressUncheckedUpdateWithoutDeliveryOrdersInput>
    create: XOR<AddressCreateWithoutDeliveryOrdersInput, AddressUncheckedCreateWithoutDeliveryOrdersInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutDeliveryOrdersInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutDeliveryOrdersInput, AddressUncheckedUpdateWithoutDeliveryOrdersInput>
  }

  export type AddressUpdateWithoutDeliveryOrdersInput = {
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isSnapshot?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAddressesNestedInput
  }

  export type AddressUncheckedUpdateWithoutDeliveryOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isSnapshot?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FulfillmentGroupUpsertWithWhereUniqueWithoutOrderInput = {
    where: FulfillmentGroupWhereUniqueInput
    update: XOR<FulfillmentGroupUpdateWithoutOrderInput, FulfillmentGroupUncheckedUpdateWithoutOrderInput>
    create: XOR<FulfillmentGroupCreateWithoutOrderInput, FulfillmentGroupUncheckedCreateWithoutOrderInput>
  }

  export type FulfillmentGroupUpdateWithWhereUniqueWithoutOrderInput = {
    where: FulfillmentGroupWhereUniqueInput
    data: XOR<FulfillmentGroupUpdateWithoutOrderInput, FulfillmentGroupUncheckedUpdateWithoutOrderInput>
  }

  export type FulfillmentGroupUpdateManyWithWhereWithoutOrderInput = {
    where: FulfillmentGroupScalarWhereInput
    data: XOR<FulfillmentGroupUpdateManyMutationInput, FulfillmentGroupUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderAdjustmentUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderAdjustmentWhereUniqueInput
    update: XOR<OrderAdjustmentUpdateWithoutOrderInput, OrderAdjustmentUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderAdjustmentCreateWithoutOrderInput, OrderAdjustmentUncheckedCreateWithoutOrderInput>
  }

  export type OrderAdjustmentUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderAdjustmentWhereUniqueInput
    data: XOR<OrderAdjustmentUpdateWithoutOrderInput, OrderAdjustmentUncheckedUpdateWithoutOrderInput>
  }

  export type OrderAdjustmentUpdateManyWithWhereWithoutOrderInput = {
    where: OrderAdjustmentScalarWhereInput
    data: XOR<OrderAdjustmentUpdateManyMutationInput, OrderAdjustmentUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderAdjustmentScalarWhereInput = {
    AND?: OrderAdjustmentScalarWhereInput | OrderAdjustmentScalarWhereInput[]
    OR?: OrderAdjustmentScalarWhereInput[]
    NOT?: OrderAdjustmentScalarWhereInput | OrderAdjustmentScalarWhereInput[]
    id?: IntFilter<"OrderAdjustment"> | number
    orderId?: IntFilter<"OrderAdjustment"> | number
    fulfillmentGroupId?: IntNullableFilter<"OrderAdjustment"> | number | null
    type?: EnumAdjustmentTypeFilter<"OrderAdjustment"> | $Enums.AdjustmentType
    label?: StringNullableFilter<"OrderAdjustment"> | string | null
    amountCents?: IntFilter<"OrderAdjustment"> | number
    metadata?: JsonNullableFilter<"OrderAdjustment">
    createdAt?: DateTimeFilter<"OrderAdjustment"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOrderInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderEventUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderEventWhereUniqueInput
    update: XOR<OrderEventUpdateWithoutOrderInput, OrderEventUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderEventCreateWithoutOrderInput, OrderEventUncheckedCreateWithoutOrderInput>
  }

  export type OrderEventUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderEventWhereUniqueInput
    data: XOR<OrderEventUpdateWithoutOrderInput, OrderEventUncheckedUpdateWithoutOrderInput>
  }

  export type OrderEventUpdateManyWithWhereWithoutOrderInput = {
    where: OrderEventScalarWhereInput
    data: XOR<OrderEventUpdateManyMutationInput, OrderEventUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderEventScalarWhereInput = {
    AND?: OrderEventScalarWhereInput | OrderEventScalarWhereInput[]
    OR?: OrderEventScalarWhereInput[]
    NOT?: OrderEventScalarWhereInput | OrderEventScalarWhereInput[]
    id?: IntFilter<"OrderEvent"> | number
    orderId?: IntFilter<"OrderEvent"> | number
    fulfillmentGroupId?: IntNullableFilter<"OrderEvent"> | number | null
    type?: StringFilter<"OrderEvent"> | string
    payload?: JsonNullableFilter<"OrderEvent">
    createdAt?: DateTimeFilter<"OrderEvent"> | Date | string
  }

  export type PromotionRedemptionUpsertWithWhereUniqueWithoutOrderInput = {
    where: PromotionRedemptionWhereUniqueInput
    update: XOR<PromotionRedemptionUpdateWithoutOrderInput, PromotionRedemptionUncheckedUpdateWithoutOrderInput>
    create: XOR<PromotionRedemptionCreateWithoutOrderInput, PromotionRedemptionUncheckedCreateWithoutOrderInput>
  }

  export type PromotionRedemptionUpdateWithWhereUniqueWithoutOrderInput = {
    where: PromotionRedemptionWhereUniqueInput
    data: XOR<PromotionRedemptionUpdateWithoutOrderInput, PromotionRedemptionUncheckedUpdateWithoutOrderInput>
  }

  export type PromotionRedemptionUpdateManyWithWhereWithoutOrderInput = {
    where: PromotionRedemptionScalarWhereInput
    data: XOR<PromotionRedemptionUpdateManyMutationInput, PromotionRedemptionUncheckedUpdateManyWithoutOrderInput>
  }

  export type CapacityHoldUpsertWithWhereUniqueWithoutOrderInput = {
    where: CapacityHoldWhereUniqueInput
    update: XOR<CapacityHoldUpdateWithoutOrderInput, CapacityHoldUncheckedUpdateWithoutOrderInput>
    create: XOR<CapacityHoldCreateWithoutOrderInput, CapacityHoldUncheckedCreateWithoutOrderInput>
  }

  export type CapacityHoldUpdateWithWhereUniqueWithoutOrderInput = {
    where: CapacityHoldWhereUniqueInput
    data: XOR<CapacityHoldUpdateWithoutOrderInput, CapacityHoldUncheckedUpdateWithoutOrderInput>
  }

  export type CapacityHoldUpdateManyWithWhereWithoutOrderInput = {
    where: CapacityHoldScalarWhereInput
    data: XOR<CapacityHoldUpdateManyMutationInput, CapacityHoldUncheckedUpdateManyWithoutOrderInput>
  }

  export type RewardTransactionUpsertWithWhereUniqueWithoutOrderInput = {
    where: RewardTransactionWhereUniqueInput
    update: XOR<RewardTransactionUpdateWithoutOrderInput, RewardTransactionUncheckedUpdateWithoutOrderInput>
    create: XOR<RewardTransactionCreateWithoutOrderInput, RewardTransactionUncheckedCreateWithoutOrderInput>
  }

  export type RewardTransactionUpdateWithWhereUniqueWithoutOrderInput = {
    where: RewardTransactionWhereUniqueInput
    data: XOR<RewardTransactionUpdateWithoutOrderInput, RewardTransactionUncheckedUpdateWithoutOrderInput>
  }

  export type RewardTransactionUpdateManyWithWhereWithoutOrderInput = {
    where: RewardTransactionScalarWhereInput
    data: XOR<RewardTransactionUpdateManyMutationInput, RewardTransactionUncheckedUpdateManyWithoutOrderInput>
  }

  export type RewardTransactionScalarWhereInput = {
    AND?: RewardTransactionScalarWhereInput | RewardTransactionScalarWhereInput[]
    OR?: RewardTransactionScalarWhereInput[]
    NOT?: RewardTransactionScalarWhereInput | RewardTransactionScalarWhereInput[]
    id?: IntFilter<"RewardTransaction"> | number
    rewardAccountId?: IntFilter<"RewardTransaction"> | number
    type?: EnumRewardTxnTypeFilter<"RewardTransaction"> | $Enums.RewardTxnType
    amountPoints?: IntFilter<"RewardTransaction"> | number
    orderId?: IntNullableFilter<"RewardTransaction"> | number | null
    note?: StringNullableFilter<"RewardTransaction"> | string | null
    createdAt?: DateTimeFilter<"RewardTransaction"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutOrderInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutOrderInput, ReviewUncheckedUpdateWithoutOrderInput>
    create: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutOrderInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutOrderInput, ReviewUncheckedUpdateWithoutOrderInput>
  }

  export type ReviewUpdateManyWithWhereWithoutOrderInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutGroupsInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    createdBy?: UserCreateNestedOneWithoutCreatedOrdersInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutDeliveryOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    events?: OrderEventCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutGroupsInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    events?: OrderEventUncheckedCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldUncheckedCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutGroupsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutGroupsInput, OrderUncheckedCreateWithoutGroupsInput>
  }

  export type ServiceDayCreateWithoutGroupsInput = {
    menuDate: Date | string
    serviceDate: Date | string
    label?: string | null
    isPublished?: boolean
    isClosed?: boolean
    closedReason?: string | null
    orderingCutoffAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menus?: MenuCreateNestedManyWithoutServiceDayInput
    slots?: ServiceSlotCreateNestedManyWithoutServiceDayInput
  }

  export type ServiceDayUncheckedCreateWithoutGroupsInput = {
    id?: number
    menuDate: Date | string
    serviceDate: Date | string
    label?: string | null
    isPublished?: boolean
    isClosed?: boolean
    closedReason?: string | null
    orderingCutoffAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menus?: MenuUncheckedCreateNestedManyWithoutServiceDayInput
    slots?: ServiceSlotUncheckedCreateNestedManyWithoutServiceDayInput
  }

  export type ServiceDayCreateOrConnectWithoutGroupsInput = {
    where: ServiceDayWhereUniqueInput
    create: XOR<ServiceDayCreateWithoutGroupsInput, ServiceDayUncheckedCreateWithoutGroupsInput>
  }

  export type ServiceSlotCreateWithoutGroupsInput = {
    fulfillmentType: $Enums.FulfillmentType
    slotKey: string
    capacityOverride?: number | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceDay: ServiceDayCreateNestedOneWithoutSlotsInput
    template: SlotTemplateCreateNestedOneWithoutServiceSlotsInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutServiceSlotsInput
  }

  export type ServiceSlotUncheckedCreateWithoutGroupsInput = {
    id?: number
    serviceDayId: number
    slotTemplateId: number
    fulfillmentType: $Enums.FulfillmentType
    pickupLocationId?: number | null
    slotKey: string
    capacityOverride?: number | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceSlotCreateOrConnectWithoutGroupsInput = {
    where: ServiceSlotWhereUniqueInput
    create: XOR<ServiceSlotCreateWithoutGroupsInput, ServiceSlotUncheckedCreateWithoutGroupsInput>
  }

  export type OrderItemCreateWithoutGroupInput = {
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    variantLabelSnapshot: string
    imageUrlSnapshot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    variant: MenuVariantCreateNestedOneWithoutOrderItemsInput
    addOns?: OrderItemAddOnCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutGroupInput = {
    id?: number
    orderId: number
    menuVariantId: number
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    variantLabelSnapshot: string
    imageUrlSnapshot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addOns?: OrderItemAddOnUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutGroupInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutGroupInput, OrderItemUncheckedCreateWithoutGroupInput>
  }

  export type OrderItemCreateManyGroupInputEnvelope = {
    data: OrderItemCreateManyGroupInput | OrderItemCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type OrderAdjustmentCreateWithoutGroupInput = {
    type: $Enums.AdjustmentType
    label?: string | null
    amountCents: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutAdjustmentsInput
  }

  export type OrderAdjustmentUncheckedCreateWithoutGroupInput = {
    id?: number
    orderId: number
    type: $Enums.AdjustmentType
    label?: string | null
    amountCents: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderAdjustmentCreateOrConnectWithoutGroupInput = {
    where: OrderAdjustmentWhereUniqueInput
    create: XOR<OrderAdjustmentCreateWithoutGroupInput, OrderAdjustmentUncheckedCreateWithoutGroupInput>
  }

  export type OrderAdjustmentCreateManyGroupInputEnvelope = {
    data: OrderAdjustmentCreateManyGroupInput | OrderAdjustmentCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type OrderEventCreateWithoutGroupInput = {
    type: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutEventsInput
  }

  export type OrderEventUncheckedCreateWithoutGroupInput = {
    id?: number
    orderId: number
    type: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderEventCreateOrConnectWithoutGroupInput = {
    where: OrderEventWhereUniqueInput
    create: XOR<OrderEventCreateWithoutGroupInput, OrderEventUncheckedCreateWithoutGroupInput>
  }

  export type OrderEventCreateManyGroupInputEnvelope = {
    data: OrderEventCreateManyGroupInput | OrderEventCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithoutGroupsInput = {
    update: XOR<OrderUpdateWithoutGroupsInput, OrderUncheckedUpdateWithoutGroupsInput>
    create: XOR<OrderCreateWithoutGroupsInput, OrderUncheckedCreateWithoutGroupsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutGroupsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutGroupsInput, OrderUncheckedUpdateWithoutGroupsInput>
  }

  export type OrderUpdateWithoutGroupsInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    createdBy?: UserUpdateOneWithoutCreatedOrdersNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutDeliveryOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    events?: OrderEventUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUncheckedUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ServiceDayUpsertWithoutGroupsInput = {
    update: XOR<ServiceDayUpdateWithoutGroupsInput, ServiceDayUncheckedUpdateWithoutGroupsInput>
    create: XOR<ServiceDayCreateWithoutGroupsInput, ServiceDayUncheckedCreateWithoutGroupsInput>
    where?: ServiceDayWhereInput
  }

  export type ServiceDayUpdateToOneWithWhereWithoutGroupsInput = {
    where?: ServiceDayWhereInput
    data: XOR<ServiceDayUpdateWithoutGroupsInput, ServiceDayUncheckedUpdateWithoutGroupsInput>
  }

  export type ServiceDayUpdateWithoutGroupsInput = {
    menuDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    orderingCutoffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menus?: MenuUpdateManyWithoutServiceDayNestedInput
    slots?: ServiceSlotUpdateManyWithoutServiceDayNestedInput
  }

  export type ServiceDayUncheckedUpdateWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedReason?: NullableStringFieldUpdateOperationsInput | string | null
    orderingCutoffAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menus?: MenuUncheckedUpdateManyWithoutServiceDayNestedInput
    slots?: ServiceSlotUncheckedUpdateManyWithoutServiceDayNestedInput
  }

  export type ServiceSlotUpsertWithoutGroupsInput = {
    update: XOR<ServiceSlotUpdateWithoutGroupsInput, ServiceSlotUncheckedUpdateWithoutGroupsInput>
    create: XOR<ServiceSlotCreateWithoutGroupsInput, ServiceSlotUncheckedCreateWithoutGroupsInput>
    where?: ServiceSlotWhereInput
  }

  export type ServiceSlotUpdateToOneWithWhereWithoutGroupsInput = {
    where?: ServiceSlotWhereInput
    data: XOR<ServiceSlotUpdateWithoutGroupsInput, ServiceSlotUncheckedUpdateWithoutGroupsInput>
  }

  export type ServiceSlotUpdateWithoutGroupsInput = {
    fulfillmentType?: EnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType
    slotKey?: StringFieldUpdateOperationsInput | string
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDay?: ServiceDayUpdateOneRequiredWithoutSlotsNestedInput
    template?: SlotTemplateUpdateOneRequiredWithoutServiceSlotsNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutServiceSlotsNestedInput
  }

  export type ServiceSlotUncheckedUpdateWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    slotTemplateId?: IntFieldUpdateOperationsInput | number
    fulfillmentType?: EnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    slotKey?: StringFieldUpdateOperationsInput | string
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutGroupInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutGroupInput, OrderItemUncheckedUpdateWithoutGroupInput>
    create: XOR<OrderItemCreateWithoutGroupInput, OrderItemUncheckedCreateWithoutGroupInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutGroupInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutGroupInput, OrderItemUncheckedUpdateWithoutGroupInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutGroupInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutGroupInput>
  }

  export type OrderAdjustmentUpsertWithWhereUniqueWithoutGroupInput = {
    where: OrderAdjustmentWhereUniqueInput
    update: XOR<OrderAdjustmentUpdateWithoutGroupInput, OrderAdjustmentUncheckedUpdateWithoutGroupInput>
    create: XOR<OrderAdjustmentCreateWithoutGroupInput, OrderAdjustmentUncheckedCreateWithoutGroupInput>
  }

  export type OrderAdjustmentUpdateWithWhereUniqueWithoutGroupInput = {
    where: OrderAdjustmentWhereUniqueInput
    data: XOR<OrderAdjustmentUpdateWithoutGroupInput, OrderAdjustmentUncheckedUpdateWithoutGroupInput>
  }

  export type OrderAdjustmentUpdateManyWithWhereWithoutGroupInput = {
    where: OrderAdjustmentScalarWhereInput
    data: XOR<OrderAdjustmentUpdateManyMutationInput, OrderAdjustmentUncheckedUpdateManyWithoutGroupInput>
  }

  export type OrderEventUpsertWithWhereUniqueWithoutGroupInput = {
    where: OrderEventWhereUniqueInput
    update: XOR<OrderEventUpdateWithoutGroupInput, OrderEventUncheckedUpdateWithoutGroupInput>
    create: XOR<OrderEventCreateWithoutGroupInput, OrderEventUncheckedCreateWithoutGroupInput>
  }

  export type OrderEventUpdateWithWhereUniqueWithoutGroupInput = {
    where: OrderEventWhereUniqueInput
    data: XOR<OrderEventUpdateWithoutGroupInput, OrderEventUncheckedUpdateWithoutGroupInput>
  }

  export type OrderEventUpdateManyWithWhereWithoutGroupInput = {
    where: OrderEventScalarWhereInput
    data: XOR<OrderEventUpdateManyMutationInput, OrderEventUncheckedUpdateManyWithoutGroupInput>
  }

  export type OrderCreateWithoutItemsInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    createdBy?: UserCreateNestedOneWithoutCreatedOrdersInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutDeliveryOrdersInput
    groups?: FulfillmentGroupCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    events?: OrderEventCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    events?: OrderEventUncheckedCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldUncheckedCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type FulfillmentGroupCreateWithoutItemsInput = {
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutGroupsInput
    serviceDay: ServiceDayCreateNestedOneWithoutGroupsInput
    serviceSlot?: ServiceSlotCreateNestedOneWithoutGroupsInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutGroupInput
    events?: OrderEventCreateNestedManyWithoutGroupInput
  }

  export type FulfillmentGroupUncheckedCreateWithoutItemsInput = {
    id?: number
    orderId: number
    serviceDayId: number
    serviceSlotId?: number | null
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutGroupInput
    events?: OrderEventUncheckedCreateNestedManyWithoutGroupInput
  }

  export type FulfillmentGroupCreateOrConnectWithoutItemsInput = {
    where: FulfillmentGroupWhereUniqueInput
    create: XOR<FulfillmentGroupCreateWithoutItemsInput, FulfillmentGroupUncheckedCreateWithoutItemsInput>
  }

  export type MenuVariantCreateWithoutOrderItemsInput = {
    label: string
    basePriceCents: number
    baseCapacity?: number | null
    isActive?: boolean
    prepMinutes?: number | null
    packagingCostCents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menuItem: MenuItemCreateNestedOneWithoutVariantsInput
    offerings?: MenuOfferingCreateNestedManyWithoutVariantInput
  }

  export type MenuVariantUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    menuItemId: number
    label: string
    basePriceCents: number
    baseCapacity?: number | null
    isActive?: boolean
    prepMinutes?: number | null
    packagingCostCents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offerings?: MenuOfferingUncheckedCreateNestedManyWithoutVariantInput
  }

  export type MenuVariantCreateOrConnectWithoutOrderItemsInput = {
    where: MenuVariantWhereUniqueInput
    create: XOR<MenuVariantCreateWithoutOrderItemsInput, MenuVariantUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderItemAddOnCreateWithoutOrderItemInput = {
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    addOn?: AddOnCreateNestedOneWithoutOrderLinksInput
  }

  export type OrderItemAddOnUncheckedCreateWithoutOrderItemInput = {
    id?: number
    addOnId?: number | null
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
  }

  export type OrderItemAddOnCreateOrConnectWithoutOrderItemInput = {
    where: OrderItemAddOnWhereUniqueInput
    create: XOR<OrderItemAddOnCreateWithoutOrderItemInput, OrderItemAddOnUncheckedCreateWithoutOrderItemInput>
  }

  export type OrderItemAddOnCreateManyOrderItemInputEnvelope = {
    data: OrderItemAddOnCreateManyOrderItemInput | OrderItemAddOnCreateManyOrderItemInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    createdBy?: UserUpdateOneWithoutCreatedOrdersNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutDeliveryOrdersNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    events?: OrderEventUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUncheckedUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type FulfillmentGroupUpsertWithoutItemsInput = {
    update: XOR<FulfillmentGroupUpdateWithoutItemsInput, FulfillmentGroupUncheckedUpdateWithoutItemsInput>
    create: XOR<FulfillmentGroupCreateWithoutItemsInput, FulfillmentGroupUncheckedCreateWithoutItemsInput>
    where?: FulfillmentGroupWhereInput
  }

  export type FulfillmentGroupUpdateToOneWithWhereWithoutItemsInput = {
    where?: FulfillmentGroupWhereInput
    data: XOR<FulfillmentGroupUpdateWithoutItemsInput, FulfillmentGroupUncheckedUpdateWithoutItemsInput>
  }

  export type FulfillmentGroupUpdateWithoutItemsInput = {
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutGroupsNestedInput
    serviceDay?: ServiceDayUpdateOneRequiredWithoutGroupsNestedInput
    serviceSlot?: ServiceSlotUpdateOneWithoutGroupsNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutGroupNestedInput
    events?: OrderEventUpdateManyWithoutGroupNestedInput
  }

  export type FulfillmentGroupUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    serviceSlotId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutGroupNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type MenuVariantUpsertWithoutOrderItemsInput = {
    update: XOR<MenuVariantUpdateWithoutOrderItemsInput, MenuVariantUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<MenuVariantCreateWithoutOrderItemsInput, MenuVariantUncheckedCreateWithoutOrderItemsInput>
    where?: MenuVariantWhereInput
  }

  export type MenuVariantUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: MenuVariantWhereInput
    data: XOR<MenuVariantUpdateWithoutOrderItemsInput, MenuVariantUncheckedUpdateWithoutOrderItemsInput>
  }

  export type MenuVariantUpdateWithoutOrderItemsInput = {
    label?: StringFieldUpdateOperationsInput | string
    basePriceCents?: IntFieldUpdateOperationsInput | number
    baseCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prepMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    packagingCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuItem?: MenuItemUpdateOneRequiredWithoutVariantsNestedInput
    offerings?: MenuOfferingUpdateManyWithoutVariantNestedInput
  }

  export type MenuVariantUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuItemId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    basePriceCents?: IntFieldUpdateOperationsInput | number
    baseCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prepMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    packagingCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: MenuOfferingUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type OrderItemAddOnUpsertWithWhereUniqueWithoutOrderItemInput = {
    where: OrderItemAddOnWhereUniqueInput
    update: XOR<OrderItemAddOnUpdateWithoutOrderItemInput, OrderItemAddOnUncheckedUpdateWithoutOrderItemInput>
    create: XOR<OrderItemAddOnCreateWithoutOrderItemInput, OrderItemAddOnUncheckedCreateWithoutOrderItemInput>
  }

  export type OrderItemAddOnUpdateWithWhereUniqueWithoutOrderItemInput = {
    where: OrderItemAddOnWhereUniqueInput
    data: XOR<OrderItemAddOnUpdateWithoutOrderItemInput, OrderItemAddOnUncheckedUpdateWithoutOrderItemInput>
  }

  export type OrderItemAddOnUpdateManyWithWhereWithoutOrderItemInput = {
    where: OrderItemAddOnScalarWhereInput
    data: XOR<OrderItemAddOnUpdateManyMutationInput, OrderItemAddOnUncheckedUpdateManyWithoutOrderItemInput>
  }

  export type OrderItemCreateWithoutAddOnsInput = {
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    variantLabelSnapshot: string
    imageUrlSnapshot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    group: FulfillmentGroupCreateNestedOneWithoutItemsInput
    variant: MenuVariantCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutAddOnsInput = {
    id?: number
    orderId: number
    fulfillmentGroupId: number
    menuVariantId: number
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    variantLabelSnapshot: string
    imageUrlSnapshot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutAddOnsInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutAddOnsInput, OrderItemUncheckedCreateWithoutAddOnsInput>
  }

  export type AddOnCreateWithoutOrderLinksInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    priceCents: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    itemLinks?: MenuItemAddOnCreateNestedManyWithoutAddOnInput
  }

  export type AddOnUncheckedCreateWithoutOrderLinksInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    priceCents: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    itemLinks?: MenuItemAddOnUncheckedCreateNestedManyWithoutAddOnInput
  }

  export type AddOnCreateOrConnectWithoutOrderLinksInput = {
    where: AddOnWhereUniqueInput
    create: XOR<AddOnCreateWithoutOrderLinksInput, AddOnUncheckedCreateWithoutOrderLinksInput>
  }

  export type OrderItemUpsertWithoutAddOnsInput = {
    update: XOR<OrderItemUpdateWithoutAddOnsInput, OrderItemUncheckedUpdateWithoutAddOnsInput>
    create: XOR<OrderItemCreateWithoutAddOnsInput, OrderItemUncheckedCreateWithoutAddOnsInput>
    where?: OrderItemWhereInput
  }

  export type OrderItemUpdateToOneWithWhereWithoutAddOnsInput = {
    where?: OrderItemWhereInput
    data: XOR<OrderItemUpdateWithoutAddOnsInput, OrderItemUncheckedUpdateWithoutAddOnsInput>
  }

  export type OrderItemUpdateWithoutAddOnsInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    variantLabelSnapshot?: StringFieldUpdateOperationsInput | string
    imageUrlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    group?: FulfillmentGroupUpdateOneRequiredWithoutItemsNestedInput
    variant?: MenuVariantUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutAddOnsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    fulfillmentGroupId?: IntFieldUpdateOperationsInput | number
    menuVariantId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    variantLabelSnapshot?: StringFieldUpdateOperationsInput | string
    imageUrlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddOnUpsertWithoutOrderLinksInput = {
    update: XOR<AddOnUpdateWithoutOrderLinksInput, AddOnUncheckedUpdateWithoutOrderLinksInput>
    create: XOR<AddOnCreateWithoutOrderLinksInput, AddOnUncheckedCreateWithoutOrderLinksInput>
    where?: AddOnWhereInput
  }

  export type AddOnUpdateToOneWithWhereWithoutOrderLinksInput = {
    where?: AddOnWhereInput
    data: XOR<AddOnUpdateWithoutOrderLinksInput, AddOnUncheckedUpdateWithoutOrderLinksInput>
  }

  export type AddOnUpdateWithoutOrderLinksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemLinks?: MenuItemAddOnUpdateManyWithoutAddOnNestedInput
  }

  export type AddOnUncheckedUpdateWithoutOrderLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemLinks?: MenuItemAddOnUncheckedUpdateManyWithoutAddOnNestedInput
  }

  export type OrderCreateWithoutAdjustmentsInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    createdBy?: UserCreateNestedOneWithoutCreatedOrdersInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutDeliveryOrdersInput
    groups?: FulfillmentGroupCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    events?: OrderEventCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutAdjustmentsInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    events?: OrderEventUncheckedCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldUncheckedCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutAdjustmentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutAdjustmentsInput, OrderUncheckedCreateWithoutAdjustmentsInput>
  }

  export type FulfillmentGroupCreateWithoutAdjustmentsInput = {
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutGroupsInput
    serviceDay: ServiceDayCreateNestedOneWithoutGroupsInput
    serviceSlot?: ServiceSlotCreateNestedOneWithoutGroupsInput
    items?: OrderItemCreateNestedManyWithoutGroupInput
    events?: OrderEventCreateNestedManyWithoutGroupInput
  }

  export type FulfillmentGroupUncheckedCreateWithoutAdjustmentsInput = {
    id?: number
    orderId: number
    serviceDayId: number
    serviceSlotId?: number | null
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutGroupInput
    events?: OrderEventUncheckedCreateNestedManyWithoutGroupInput
  }

  export type FulfillmentGroupCreateOrConnectWithoutAdjustmentsInput = {
    where: FulfillmentGroupWhereUniqueInput
    create: XOR<FulfillmentGroupCreateWithoutAdjustmentsInput, FulfillmentGroupUncheckedCreateWithoutAdjustmentsInput>
  }

  export type OrderUpsertWithoutAdjustmentsInput = {
    update: XOR<OrderUpdateWithoutAdjustmentsInput, OrderUncheckedUpdateWithoutAdjustmentsInput>
    create: XOR<OrderCreateWithoutAdjustmentsInput, OrderUncheckedCreateWithoutAdjustmentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutAdjustmentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutAdjustmentsInput, OrderUncheckedUpdateWithoutAdjustmentsInput>
  }

  export type OrderUpdateWithoutAdjustmentsInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    createdBy?: UserUpdateOneWithoutCreatedOrdersNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutDeliveryOrdersNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    events?: OrderEventUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutAdjustmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUncheckedUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type FulfillmentGroupUpsertWithoutAdjustmentsInput = {
    update: XOR<FulfillmentGroupUpdateWithoutAdjustmentsInput, FulfillmentGroupUncheckedUpdateWithoutAdjustmentsInput>
    create: XOR<FulfillmentGroupCreateWithoutAdjustmentsInput, FulfillmentGroupUncheckedCreateWithoutAdjustmentsInput>
    where?: FulfillmentGroupWhereInput
  }

  export type FulfillmentGroupUpdateToOneWithWhereWithoutAdjustmentsInput = {
    where?: FulfillmentGroupWhereInput
    data: XOR<FulfillmentGroupUpdateWithoutAdjustmentsInput, FulfillmentGroupUncheckedUpdateWithoutAdjustmentsInput>
  }

  export type FulfillmentGroupUpdateWithoutAdjustmentsInput = {
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutGroupsNestedInput
    serviceDay?: ServiceDayUpdateOneRequiredWithoutGroupsNestedInput
    serviceSlot?: ServiceSlotUpdateOneWithoutGroupsNestedInput
    items?: OrderItemUpdateManyWithoutGroupNestedInput
    events?: OrderEventUpdateManyWithoutGroupNestedInput
  }

  export type FulfillmentGroupUncheckedUpdateWithoutAdjustmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    serviceSlotId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutGroupNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type OrderCreateWithoutPaymentsInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    createdBy?: UserCreateNestedOneWithoutCreatedOrdersInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutDeliveryOrdersInput
    groups?: FulfillmentGroupCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutOrderInput
    events?: OrderEventCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentsInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutOrderInput
    events?: OrderEventUncheckedCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldUncheckedCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutPaymentsReceivedInput = {
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    cateringOrders?: CateringOrderCreateNestedManyWithoutUserInput
    createdCateringOrders?: CateringOrderCreateNestedManyWithoutCreatedByInput
    rewardAccount?: RewardAccountCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    promotionRedemptions?: PromotionRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsReceivedInput = {
    id?: number
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    cateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutUserInput
    createdCateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutCreatedByInput
    rewardAccount?: RewardAccountUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    promotionRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsReceivedInput, UserUncheckedCreateWithoutPaymentsReceivedInput>
  }

  export type OrderUpsertWithoutPaymentsInput = {
    update: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrderUpdateWithoutPaymentsInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    createdBy?: UserUpdateOneWithoutCreatedOrdersNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutDeliveryOrdersNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutOrderNestedInput
    events?: OrderEventUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutOrderNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUncheckedUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserUpsertWithoutPaymentsReceivedInput = {
    update: XOR<UserUpdateWithoutPaymentsReceivedInput, UserUncheckedUpdateWithoutPaymentsReceivedInput>
    create: XOR<UserCreateWithoutPaymentsReceivedInput, UserUncheckedCreateWithoutPaymentsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsReceivedInput, UserUncheckedUpdateWithoutPaymentsReceivedInput>
  }

  export type UserUpdateWithoutPaymentsReceivedInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    cateringOrders?: CateringOrderUpdateManyWithoutUserNestedInput
    createdCateringOrders?: CateringOrderUpdateManyWithoutCreatedByNestedInput
    rewardAccount?: RewardAccountUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsReceivedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    cateringOrders?: CateringOrderUncheckedUpdateManyWithoutUserNestedInput
    createdCateringOrders?: CateringOrderUncheckedUpdateManyWithoutCreatedByNestedInput
    rewardAccount?: RewardAccountUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderCreateWithoutEventsInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    createdBy?: UserCreateNestedOneWithoutCreatedOrdersInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutDeliveryOrdersInput
    groups?: FulfillmentGroupCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutEventsInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldUncheckedCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutEventsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutEventsInput, OrderUncheckedCreateWithoutEventsInput>
  }

  export type FulfillmentGroupCreateWithoutEventsInput = {
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutGroupsInput
    serviceDay: ServiceDayCreateNestedOneWithoutGroupsInput
    serviceSlot?: ServiceSlotCreateNestedOneWithoutGroupsInput
    items?: OrderItemCreateNestedManyWithoutGroupInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutGroupInput
  }

  export type FulfillmentGroupUncheckedCreateWithoutEventsInput = {
    id?: number
    orderId: number
    serviceDayId: number
    serviceSlotId?: number | null
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutGroupInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type FulfillmentGroupCreateOrConnectWithoutEventsInput = {
    where: FulfillmentGroupWhereUniqueInput
    create: XOR<FulfillmentGroupCreateWithoutEventsInput, FulfillmentGroupUncheckedCreateWithoutEventsInput>
  }

  export type OrderUpsertWithoutEventsInput = {
    update: XOR<OrderUpdateWithoutEventsInput, OrderUncheckedUpdateWithoutEventsInput>
    create: XOR<OrderCreateWithoutEventsInput, OrderUncheckedCreateWithoutEventsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutEventsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutEventsInput, OrderUncheckedUpdateWithoutEventsInput>
  }

  export type OrderUpdateWithoutEventsInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    createdBy?: UserUpdateOneWithoutCreatedOrdersNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutDeliveryOrdersNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUncheckedUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type FulfillmentGroupUpsertWithoutEventsInput = {
    update: XOR<FulfillmentGroupUpdateWithoutEventsInput, FulfillmentGroupUncheckedUpdateWithoutEventsInput>
    create: XOR<FulfillmentGroupCreateWithoutEventsInput, FulfillmentGroupUncheckedCreateWithoutEventsInput>
    where?: FulfillmentGroupWhereInput
  }

  export type FulfillmentGroupUpdateToOneWithWhereWithoutEventsInput = {
    where?: FulfillmentGroupWhereInput
    data: XOR<FulfillmentGroupUpdateWithoutEventsInput, FulfillmentGroupUncheckedUpdateWithoutEventsInput>
  }

  export type FulfillmentGroupUpdateWithoutEventsInput = {
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutGroupsNestedInput
    serviceDay?: ServiceDayUpdateOneRequiredWithoutGroupsNestedInput
    serviceSlot?: ServiceSlotUpdateOneWithoutGroupsNestedInput
    items?: OrderItemUpdateManyWithoutGroupNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutGroupNestedInput
  }

  export type FulfillmentGroupUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    serviceSlotId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutGroupNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type MenuOfferingCreateWithoutHoldsInput = {
    priceOverrideCents?: number | null
    capacityOverride?: number | null
    isAvailable?: boolean
    maxPerOrder?: number | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    menu: MenuCreateNestedOneWithoutOfferingsInput
    variant: MenuVariantCreateNestedOneWithoutOfferingsInput
  }

  export type MenuOfferingUncheckedCreateWithoutHoldsInput = {
    id?: number
    menuId: number
    menuVariantId: number
    priceOverrideCents?: number | null
    capacityOverride?: number | null
    isAvailable?: boolean
    maxPerOrder?: number | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuOfferingCreateOrConnectWithoutHoldsInput = {
    where: MenuOfferingWhereUniqueInput
    create: XOR<MenuOfferingCreateWithoutHoldsInput, MenuOfferingUncheckedCreateWithoutHoldsInput>
  }

  export type OrderCreateWithoutCapacityHoldsInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    createdBy?: UserCreateNestedOneWithoutCreatedOrdersInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutDeliveryOrdersInput
    groups?: FulfillmentGroupCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    events?: OrderEventCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCapacityHoldsInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    events?: OrderEventUncheckedCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCapacityHoldsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCapacityHoldsInput, OrderUncheckedCreateWithoutCapacityHoldsInput>
  }

  export type MenuOfferingUpsertWithoutHoldsInput = {
    update: XOR<MenuOfferingUpdateWithoutHoldsInput, MenuOfferingUncheckedUpdateWithoutHoldsInput>
    create: XOR<MenuOfferingCreateWithoutHoldsInput, MenuOfferingUncheckedCreateWithoutHoldsInput>
    where?: MenuOfferingWhereInput
  }

  export type MenuOfferingUpdateToOneWithWhereWithoutHoldsInput = {
    where?: MenuOfferingWhereInput
    data: XOR<MenuOfferingUpdateWithoutHoldsInput, MenuOfferingUncheckedUpdateWithoutHoldsInput>
  }

  export type MenuOfferingUpdateWithoutHoldsInput = {
    priceOverrideCents?: NullableIntFieldUpdateOperationsInput | number | null
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxPerOrder?: NullableIntFieldUpdateOperationsInput | number | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: MenuUpdateOneRequiredWithoutOfferingsNestedInput
    variant?: MenuVariantUpdateOneRequiredWithoutOfferingsNestedInput
  }

  export type MenuOfferingUncheckedUpdateWithoutHoldsInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    menuVariantId?: IntFieldUpdateOperationsInput | number
    priceOverrideCents?: NullableIntFieldUpdateOperationsInput | number | null
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxPerOrder?: NullableIntFieldUpdateOperationsInput | number | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpsertWithoutCapacityHoldsInput = {
    update: XOR<OrderUpdateWithoutCapacityHoldsInput, OrderUncheckedUpdateWithoutCapacityHoldsInput>
    create: XOR<OrderCreateWithoutCapacityHoldsInput, OrderUncheckedCreateWithoutCapacityHoldsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutCapacityHoldsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutCapacityHoldsInput, OrderUncheckedUpdateWithoutCapacityHoldsInput>
  }

  export type OrderUpdateWithoutCapacityHoldsInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    createdBy?: UserUpdateOneWithoutCreatedOrdersNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutDeliveryOrdersNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    events?: OrderEventUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCapacityHoldsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type PromotionRedemptionCreateWithoutPromotionInput = {
    discountCentsApplied: number
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutPromoRedemptionsInput
    user?: UserCreateNestedOneWithoutPromotionRedemptionsInput
  }

  export type PromotionRedemptionUncheckedCreateWithoutPromotionInput = {
    id?: number
    orderId: number
    userId?: number | null
    discountCentsApplied: number
    createdAt?: Date | string
  }

  export type PromotionRedemptionCreateOrConnectWithoutPromotionInput = {
    where: PromotionRedemptionWhereUniqueInput
    create: XOR<PromotionRedemptionCreateWithoutPromotionInput, PromotionRedemptionUncheckedCreateWithoutPromotionInput>
  }

  export type PromotionRedemptionCreateManyPromotionInputEnvelope = {
    data: PromotionRedemptionCreateManyPromotionInput | PromotionRedemptionCreateManyPromotionInput[]
    skipDuplicates?: boolean
  }

  export type PromotionRedemptionUpsertWithWhereUniqueWithoutPromotionInput = {
    where: PromotionRedemptionWhereUniqueInput
    update: XOR<PromotionRedemptionUpdateWithoutPromotionInput, PromotionRedemptionUncheckedUpdateWithoutPromotionInput>
    create: XOR<PromotionRedemptionCreateWithoutPromotionInput, PromotionRedemptionUncheckedCreateWithoutPromotionInput>
  }

  export type PromotionRedemptionUpdateWithWhereUniqueWithoutPromotionInput = {
    where: PromotionRedemptionWhereUniqueInput
    data: XOR<PromotionRedemptionUpdateWithoutPromotionInput, PromotionRedemptionUncheckedUpdateWithoutPromotionInput>
  }

  export type PromotionRedemptionUpdateManyWithWhereWithoutPromotionInput = {
    where: PromotionRedemptionScalarWhereInput
    data: XOR<PromotionRedemptionUpdateManyMutationInput, PromotionRedemptionUncheckedUpdateManyWithoutPromotionInput>
  }

  export type PromotionCreateWithoutRedemptionsInput = {
    code: string
    description?: string | null
    type: $Enums.PromotionType
    amountCents?: number | null
    percentBps?: number | null
    minSubtotalCents?: number | null
    maxRedemptions?: number | null
    perUserLimit?: number | null
    startsAt: Date | string
    endsAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUncheckedCreateWithoutRedemptionsInput = {
    id?: number
    code: string
    description?: string | null
    type: $Enums.PromotionType
    amountCents?: number | null
    percentBps?: number | null
    minSubtotalCents?: number | null
    maxRedemptions?: number | null
    perUserLimit?: number | null
    startsAt: Date | string
    endsAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionCreateOrConnectWithoutRedemptionsInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutRedemptionsInput, PromotionUncheckedCreateWithoutRedemptionsInput>
  }

  export type OrderCreateWithoutPromoRedemptionsInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    createdBy?: UserCreateNestedOneWithoutCreatedOrdersInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutDeliveryOrdersInput
    groups?: FulfillmentGroupCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    events?: OrderEventCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPromoRedemptionsInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    events?: OrderEventUncheckedCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldUncheckedCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPromoRedemptionsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPromoRedemptionsInput, OrderUncheckedCreateWithoutPromoRedemptionsInput>
  }

  export type UserCreateWithoutPromotionRedemptionsInput = {
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    cateringOrders?: CateringOrderCreateNestedManyWithoutUserInput
    createdCateringOrders?: CateringOrderCreateNestedManyWithoutCreatedByInput
    rewardAccount?: RewardAccountCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPromotionRedemptionsInput = {
    id?: number
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    cateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutUserInput
    createdCateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutCreatedByInput
    rewardAccount?: RewardAccountUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPromotionRedemptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPromotionRedemptionsInput, UserUncheckedCreateWithoutPromotionRedemptionsInput>
  }

  export type PromotionUpsertWithoutRedemptionsInput = {
    update: XOR<PromotionUpdateWithoutRedemptionsInput, PromotionUncheckedUpdateWithoutRedemptionsInput>
    create: XOR<PromotionCreateWithoutRedemptionsInput, PromotionUncheckedCreateWithoutRedemptionsInput>
    where?: PromotionWhereInput
  }

  export type PromotionUpdateToOneWithWhereWithoutRedemptionsInput = {
    where?: PromotionWhereInput
    data: XOR<PromotionUpdateWithoutRedemptionsInput, PromotionUncheckedUpdateWithoutRedemptionsInput>
  }

  export type PromotionUpdateWithoutRedemptionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromotionTypeFieldUpdateOperationsInput | $Enums.PromotionType
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    percentBps?: NullableIntFieldUpdateOperationsInput | number | null
    minSubtotalCents?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    perUserLimit?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateWithoutRedemptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromotionTypeFieldUpdateOperationsInput | $Enums.PromotionType
    amountCents?: NullableIntFieldUpdateOperationsInput | number | null
    percentBps?: NullableIntFieldUpdateOperationsInput | number | null
    minSubtotalCents?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    perUserLimit?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpsertWithoutPromoRedemptionsInput = {
    update: XOR<OrderUpdateWithoutPromoRedemptionsInput, OrderUncheckedUpdateWithoutPromoRedemptionsInput>
    create: XOR<OrderCreateWithoutPromoRedemptionsInput, OrderUncheckedCreateWithoutPromoRedemptionsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPromoRedemptionsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPromoRedemptionsInput, OrderUncheckedUpdateWithoutPromoRedemptionsInput>
  }

  export type OrderUpdateWithoutPromoRedemptionsInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    createdBy?: UserUpdateOneWithoutCreatedOrdersNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutDeliveryOrdersNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    events?: OrderEventUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPromoRedemptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUncheckedUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserUpsertWithoutPromotionRedemptionsInput = {
    update: XOR<UserUpdateWithoutPromotionRedemptionsInput, UserUncheckedUpdateWithoutPromotionRedemptionsInput>
    create: XOR<UserCreateWithoutPromotionRedemptionsInput, UserUncheckedCreateWithoutPromotionRedemptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPromotionRedemptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPromotionRedemptionsInput, UserUncheckedUpdateWithoutPromotionRedemptionsInput>
  }

  export type UserUpdateWithoutPromotionRedemptionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    cateringOrders?: CateringOrderUpdateManyWithoutUserNestedInput
    createdCateringOrders?: CateringOrderUpdateManyWithoutCreatedByNestedInput
    rewardAccount?: RewardAccountUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPromotionRedemptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    cateringOrders?: CateringOrderUncheckedUpdateManyWithoutUserNestedInput
    createdCateringOrders?: CateringOrderUncheckedUpdateManyWithoutCreatedByNestedInput
    rewardAccount?: RewardAccountUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRewardAccountInput = {
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    cateringOrders?: CateringOrderCreateNestedManyWithoutUserInput
    createdCateringOrders?: CateringOrderCreateNestedManyWithoutCreatedByInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    promotionRedemptions?: PromotionRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRewardAccountInput = {
    id?: number
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    cateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutUserInput
    createdCateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutCreatedByInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    promotionRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRewardAccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRewardAccountInput, UserUncheckedCreateWithoutRewardAccountInput>
  }

  export type RewardTransactionCreateWithoutAccountInput = {
    type: $Enums.RewardTxnType
    amountPoints: number
    note?: string | null
    createdAt?: Date | string
    order?: OrderCreateNestedOneWithoutRewardTransactionsInput
  }

  export type RewardTransactionUncheckedCreateWithoutAccountInput = {
    id?: number
    type: $Enums.RewardTxnType
    amountPoints: number
    orderId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type RewardTransactionCreateOrConnectWithoutAccountInput = {
    where: RewardTransactionWhereUniqueInput
    create: XOR<RewardTransactionCreateWithoutAccountInput, RewardTransactionUncheckedCreateWithoutAccountInput>
  }

  export type RewardTransactionCreateManyAccountInputEnvelope = {
    data: RewardTransactionCreateManyAccountInput | RewardTransactionCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRewardAccountInput = {
    update: XOR<UserUpdateWithoutRewardAccountInput, UserUncheckedUpdateWithoutRewardAccountInput>
    create: XOR<UserCreateWithoutRewardAccountInput, UserUncheckedCreateWithoutRewardAccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRewardAccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRewardAccountInput, UserUncheckedUpdateWithoutRewardAccountInput>
  }

  export type UserUpdateWithoutRewardAccountInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    cateringOrders?: CateringOrderUpdateManyWithoutUserNestedInput
    createdCateringOrders?: CateringOrderUpdateManyWithoutCreatedByNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRewardAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    cateringOrders?: CateringOrderUncheckedUpdateManyWithoutUserNestedInput
    createdCateringOrders?: CateringOrderUncheckedUpdateManyWithoutCreatedByNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RewardTransactionUpsertWithWhereUniqueWithoutAccountInput = {
    where: RewardTransactionWhereUniqueInput
    update: XOR<RewardTransactionUpdateWithoutAccountInput, RewardTransactionUncheckedUpdateWithoutAccountInput>
    create: XOR<RewardTransactionCreateWithoutAccountInput, RewardTransactionUncheckedCreateWithoutAccountInput>
  }

  export type RewardTransactionUpdateWithWhereUniqueWithoutAccountInput = {
    where: RewardTransactionWhereUniqueInput
    data: XOR<RewardTransactionUpdateWithoutAccountInput, RewardTransactionUncheckedUpdateWithoutAccountInput>
  }

  export type RewardTransactionUpdateManyWithWhereWithoutAccountInput = {
    where: RewardTransactionScalarWhereInput
    data: XOR<RewardTransactionUpdateManyMutationInput, RewardTransactionUncheckedUpdateManyWithoutAccountInput>
  }

  export type RewardAccountCreateWithoutTxnsInput = {
    balancePoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRewardAccountInput
  }

  export type RewardAccountUncheckedCreateWithoutTxnsInput = {
    id?: number
    userId: number
    balancePoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardAccountCreateOrConnectWithoutTxnsInput = {
    where: RewardAccountWhereUniqueInput
    create: XOR<RewardAccountCreateWithoutTxnsInput, RewardAccountUncheckedCreateWithoutTxnsInput>
  }

  export type OrderCreateWithoutRewardTransactionsInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    createdBy?: UserCreateNestedOneWithoutCreatedOrdersInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutDeliveryOrdersInput
    groups?: FulfillmentGroupCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    events?: OrderEventCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutRewardTransactionsInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    events?: OrderEventUncheckedCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutRewardTransactionsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutRewardTransactionsInput, OrderUncheckedCreateWithoutRewardTransactionsInput>
  }

  export type RewardAccountUpsertWithoutTxnsInput = {
    update: XOR<RewardAccountUpdateWithoutTxnsInput, RewardAccountUncheckedUpdateWithoutTxnsInput>
    create: XOR<RewardAccountCreateWithoutTxnsInput, RewardAccountUncheckedCreateWithoutTxnsInput>
    where?: RewardAccountWhereInput
  }

  export type RewardAccountUpdateToOneWithWhereWithoutTxnsInput = {
    where?: RewardAccountWhereInput
    data: XOR<RewardAccountUpdateWithoutTxnsInput, RewardAccountUncheckedUpdateWithoutTxnsInput>
  }

  export type RewardAccountUpdateWithoutTxnsInput = {
    balancePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRewardAccountNestedInput
  }

  export type RewardAccountUncheckedUpdateWithoutTxnsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    balancePoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpsertWithoutRewardTransactionsInput = {
    update: XOR<OrderUpdateWithoutRewardTransactionsInput, OrderUncheckedUpdateWithoutRewardTransactionsInput>
    create: XOR<OrderCreateWithoutRewardTransactionsInput, OrderUncheckedCreateWithoutRewardTransactionsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutRewardTransactionsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutRewardTransactionsInput, OrderUncheckedUpdateWithoutRewardTransactionsInput>
  }

  export type OrderUpdateWithoutRewardTransactionsInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    createdBy?: UserUpdateOneWithoutCreatedOrdersNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutDeliveryOrdersNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    events?: OrderEventUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutRewardTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserCreateWithoutCateringOrdersInput = {
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    createdCateringOrders?: CateringOrderCreateNestedManyWithoutCreatedByInput
    rewardAccount?: RewardAccountCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    promotionRedemptions?: PromotionRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCateringOrdersInput = {
    id?: number
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdCateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutCreatedByInput
    rewardAccount?: RewardAccountUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    promotionRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCateringOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCateringOrdersInput, UserUncheckedCreateWithoutCateringOrdersInput>
  }

  export type UserCreateWithoutCreatedCateringOrdersInput = {
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    cateringOrders?: CateringOrderCreateNestedManyWithoutUserInput
    rewardAccount?: RewardAccountCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    promotionRedemptions?: PromotionRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedCateringOrdersInput = {
    id?: number
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    cateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutUserInput
    rewardAccount?: RewardAccountUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    promotionRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedCateringOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedCateringOrdersInput, UserUncheckedCreateWithoutCreatedCateringOrdersInput>
  }

  export type CateringItemCreateWithoutCateringOrderInput = {
    nameSnapshot: string
    quantity: number
    unitPriceCents: number
    menuItem?: MenuItemCreateNestedOneWithoutCateringItemsInput
  }

  export type CateringItemUncheckedCreateWithoutCateringOrderInput = {
    id?: number
    menuItemId?: number | null
    nameSnapshot: string
    quantity: number
    unitPriceCents: number
  }

  export type CateringItemCreateOrConnectWithoutCateringOrderInput = {
    where: CateringItemWhereUniqueInput
    create: XOR<CateringItemCreateWithoutCateringOrderInput, CateringItemUncheckedCreateWithoutCateringOrderInput>
  }

  export type CateringItemCreateManyCateringOrderInputEnvelope = {
    data: CateringItemCreateManyCateringOrderInput | CateringItemCreateManyCateringOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCateringOrdersInput = {
    update: XOR<UserUpdateWithoutCateringOrdersInput, UserUncheckedUpdateWithoutCateringOrdersInput>
    create: XOR<UserCreateWithoutCateringOrdersInput, UserUncheckedCreateWithoutCateringOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCateringOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCateringOrdersInput, UserUncheckedUpdateWithoutCateringOrdersInput>
  }

  export type UserUpdateWithoutCateringOrdersInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdCateringOrders?: CateringOrderUpdateManyWithoutCreatedByNestedInput
    rewardAccount?: RewardAccountUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCateringOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdCateringOrders?: CateringOrderUncheckedUpdateManyWithoutCreatedByNestedInput
    rewardAccount?: RewardAccountUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutCreatedCateringOrdersInput = {
    update: XOR<UserUpdateWithoutCreatedCateringOrdersInput, UserUncheckedUpdateWithoutCreatedCateringOrdersInput>
    create: XOR<UserCreateWithoutCreatedCateringOrdersInput, UserUncheckedCreateWithoutCreatedCateringOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedCateringOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedCateringOrdersInput, UserUncheckedUpdateWithoutCreatedCateringOrdersInput>
  }

  export type UserUpdateWithoutCreatedCateringOrdersInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    cateringOrders?: CateringOrderUpdateManyWithoutUserNestedInput
    rewardAccount?: RewardAccountUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedCateringOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    cateringOrders?: CateringOrderUncheckedUpdateManyWithoutUserNestedInput
    rewardAccount?: RewardAccountUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CateringItemUpsertWithWhereUniqueWithoutCateringOrderInput = {
    where: CateringItemWhereUniqueInput
    update: XOR<CateringItemUpdateWithoutCateringOrderInput, CateringItemUncheckedUpdateWithoutCateringOrderInput>
    create: XOR<CateringItemCreateWithoutCateringOrderInput, CateringItemUncheckedCreateWithoutCateringOrderInput>
  }

  export type CateringItemUpdateWithWhereUniqueWithoutCateringOrderInput = {
    where: CateringItemWhereUniqueInput
    data: XOR<CateringItemUpdateWithoutCateringOrderInput, CateringItemUncheckedUpdateWithoutCateringOrderInput>
  }

  export type CateringItemUpdateManyWithWhereWithoutCateringOrderInput = {
    where: CateringItemScalarWhereInput
    data: XOR<CateringItemUpdateManyMutationInput, CateringItemUncheckedUpdateManyWithoutCateringOrderInput>
  }

  export type CateringOrderCreateWithoutItemsInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    status?: $Enums.CateringStatus
    eventDate: Date | string
    guestCount: number
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    notes?: string | null
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCateringOrdersInput
    createdBy?: UserCreateNestedOneWithoutCreatedCateringOrdersInput
  }

  export type CateringOrderUncheckedCreateWithoutItemsInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    status?: $Enums.CateringStatus
    eventDate: Date | string
    guestCount: number
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    notes?: string | null
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CateringOrderCreateOrConnectWithoutItemsInput = {
    where: CateringOrderWhereUniqueInput
    create: XOR<CateringOrderCreateWithoutItemsInput, CateringOrderUncheckedCreateWithoutItemsInput>
  }

  export type MenuItemCreateWithoutCateringItemsInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutItemsInput
    variants?: MenuVariantCreateNestedManyWithoutMenuItemInput
    addOnLinks?: MenuItemAddOnCreateNestedManyWithoutMenuItemInput
  }

  export type MenuItemUncheckedCreateWithoutCateringItemsInput = {
    id?: number
    categoryId?: number | null
    name: string
    description?: string | null
    imageUrl?: string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: MenuVariantUncheckedCreateNestedManyWithoutMenuItemInput
    addOnLinks?: MenuItemAddOnUncheckedCreateNestedManyWithoutMenuItemInput
  }

  export type MenuItemCreateOrConnectWithoutCateringItemsInput = {
    where: MenuItemWhereUniqueInput
    create: XOR<MenuItemCreateWithoutCateringItemsInput, MenuItemUncheckedCreateWithoutCateringItemsInput>
  }

  export type CateringOrderUpsertWithoutItemsInput = {
    update: XOR<CateringOrderUpdateWithoutItemsInput, CateringOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<CateringOrderCreateWithoutItemsInput, CateringOrderUncheckedCreateWithoutItemsInput>
    where?: CateringOrderWhereInput
  }

  export type CateringOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: CateringOrderWhereInput
    data: XOR<CateringOrderUpdateWithoutItemsInput, CateringOrderUncheckedUpdateWithoutItemsInput>
  }

  export type CateringOrderUpdateWithoutItemsInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCateringStatusFieldUpdateOperationsInput | $Enums.CateringStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guestCount?: IntFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCateringOrdersNestedInput
    createdBy?: UserUpdateOneWithoutCreatedCateringOrdersNestedInput
  }

  export type CateringOrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCateringStatusFieldUpdateOperationsInput | $Enums.CateringStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guestCount?: IntFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemUpsertWithoutCateringItemsInput = {
    update: XOR<MenuItemUpdateWithoutCateringItemsInput, MenuItemUncheckedUpdateWithoutCateringItemsInput>
    create: XOR<MenuItemCreateWithoutCateringItemsInput, MenuItemUncheckedCreateWithoutCateringItemsInput>
    where?: MenuItemWhereInput
  }

  export type MenuItemUpdateToOneWithWhereWithoutCateringItemsInput = {
    where?: MenuItemWhereInput
    data: XOR<MenuItemUpdateWithoutCateringItemsInput, MenuItemUncheckedUpdateWithoutCateringItemsInput>
  }

  export type MenuItemUpdateWithoutCateringItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutItemsNestedInput
    variants?: MenuVariantUpdateManyWithoutMenuItemNestedInput
    addOnLinks?: MenuItemAddOnUpdateManyWithoutMenuItemNestedInput
  }

  export type MenuItemUncheckedUpdateWithoutCateringItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: MenuVariantUncheckedUpdateManyWithoutMenuItemNestedInput
    addOnLinks?: MenuItemAddOnUncheckedUpdateManyWithoutMenuItemNestedInput
  }

  export type UserCreateWithoutReviewsInput = {
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    cateringOrders?: CateringOrderCreateNestedManyWithoutUserInput
    createdCateringOrders?: CateringOrderCreateNestedManyWithoutCreatedByInput
    rewardAccount?: RewardAccountCreateNestedOneWithoutUserInput
    promotionRedemptions?: PromotionRedemptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: number
    email: string
    name?: string | null
    googleId?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    cateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutUserInput
    createdCateringOrders?: CateringOrderUncheckedCreateNestedManyWithoutCreatedByInput
    rewardAccount?: RewardAccountUncheckedCreateNestedOneWithoutUserInput
    promotionRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type OrderCreateWithoutReviewsInput = {
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutOrdersInput
    createdBy?: UserCreateNestedOneWithoutCreatedOrdersInput
    pickupLocation?: PickupLocationCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutDeliveryOrdersInput
    groups?: FulfillmentGroupCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    events?: OrderEventCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutReviewsInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: FulfillmentGroupUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    adjustments?: OrderAdjustmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    events?: OrderEventUncheckedCreateNestedManyWithoutOrderInput
    promoRedemptions?: PromotionRedemptionUncheckedCreateNestedManyWithoutOrderInput
    capacityHolds?: CapacityHoldUncheckedCreateNestedManyWithoutOrderInput
    rewardTransactions?: RewardTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutReviewsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutReviewsInput, OrderUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    cateringOrders?: CateringOrderUpdateManyWithoutUserNestedInput
    createdCateringOrders?: CateringOrderUpdateManyWithoutCreatedByNestedInput
    rewardAccount?: RewardAccountUpdateOneWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    cateringOrders?: CateringOrderUncheckedUpdateManyWithoutUserNestedInput
    createdCateringOrders?: CateringOrderUncheckedUpdateManyWithoutCreatedByNestedInput
    rewardAccount?: RewardAccountUncheckedUpdateOneWithoutUserNestedInput
    promotionRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderUpsertWithoutReviewsInput = {
    update: XOR<OrderUpdateWithoutReviewsInput, OrderUncheckedUpdateWithoutReviewsInput>
    create: XOR<OrderCreateWithoutReviewsInput, OrderUncheckedCreateWithoutReviewsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutReviewsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutReviewsInput, OrderUncheckedUpdateWithoutReviewsInput>
  }

  export type OrderUpdateWithoutReviewsInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    createdBy?: UserUpdateOneWithoutCreatedOrdersNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutDeliveryOrdersNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    events?: OrderEventUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUncheckedUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyUserInput = {
    id?: number
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyCreatedByInput = {
    id?: number
    userId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateManyUserInput = {
    id?: number
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    state: string
    postalCode: string
    country?: string
    lat?: number | null
    lng?: number | null
    isDefault?: boolean
    isSnapshot?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyReceivedByInput = {
    id?: number
    orderId: number
    provider?: $Enums.PaymentProvider
    method: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    amountCents: number
    providerRef?: string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CateringOrderCreateManyUserInput = {
    id?: number
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    status?: $Enums.CateringStatus
    eventDate: Date | string
    guestCount: number
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    notes?: string | null
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CateringOrderCreateManyCreatedByInput = {
    id?: number
    userId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    status?: $Enums.CateringStatus
    eventDate: Date | string
    guestCount: number
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    notes?: string | null
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: number
    orderId?: number | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionRedemptionCreateManyUserInput = {
    id?: number
    promotionId: number
    orderId: number
    discountCentsApplied: number
    createdAt?: Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedOrdersNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutDeliveryOrdersNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    events?: OrderEventUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUncheckedUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutCreatedByInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutDeliveryOrdersNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    events?: OrderEventUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUncheckedUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUpdateWithoutUserInput = {
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isSnapshot?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryOrders?: OrderUpdateManyWithoutDeliveryAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isSnapshot?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryOrders?: OrderUncheckedUpdateManyWithoutDeliveryAddressNestedInput
  }

  export type AddressUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isSnapshot?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutReceivedByInput = {
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amountCents?: IntFieldUpdateOperationsInput | number
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutReceivedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amountCents?: IntFieldUpdateOperationsInput | number
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutReceivedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amountCents?: IntFieldUpdateOperationsInput | number
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CateringOrderUpdateWithoutUserInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCateringStatusFieldUpdateOperationsInput | $Enums.CateringStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guestCount?: IntFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedCateringOrdersNestedInput
    items?: CateringItemUpdateManyWithoutCateringOrderNestedInput
  }

  export type CateringOrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCateringStatusFieldUpdateOperationsInput | $Enums.CateringStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guestCount?: IntFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CateringItemUncheckedUpdateManyWithoutCateringOrderNestedInput
  }

  export type CateringOrderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCateringStatusFieldUpdateOperationsInput | $Enums.CateringStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guestCount?: IntFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CateringOrderUpdateWithoutCreatedByInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCateringStatusFieldUpdateOperationsInput | $Enums.CateringStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guestCount?: IntFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCateringOrdersNestedInput
    items?: CateringItemUpdateManyWithoutCateringOrderNestedInput
  }

  export type CateringOrderUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCateringStatusFieldUpdateOperationsInput | $Enums.CateringStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guestCount?: IntFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CateringItemUncheckedUpdateManyWithoutCateringOrderNestedInput
  }

  export type CateringOrderUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCateringStatusFieldUpdateOperationsInput | $Enums.CateringStatus
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guestCount?: IntFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionUpdateWithoutUserInput = {
    discountCentsApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promotion?: PromotionUpdateOneRequiredWithoutRedemptionsNestedInput
    order?: OrderUpdateOneRequiredWithoutPromoRedemptionsNestedInput
  }

  export type PromotionRedemptionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    discountCentsApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    discountCentsApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemCreateManyCategoryInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: MenuVariantUpdateManyWithoutMenuItemNestedInput
    addOnLinks?: MenuItemAddOnUpdateManyWithoutMenuItemNestedInput
    cateringItems?: CateringItemUpdateManyWithoutMenuItemNestedInput
  }

  export type MenuItemUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: MenuVariantUncheckedUpdateManyWithoutMenuItemNestedInput
    addOnLinks?: MenuItemAddOnUncheckedUpdateManyWithoutMenuItemNestedInput
    cateringItems?: CateringItemUncheckedUpdateManyWithoutMenuItemNestedInput
  }

  export type MenuItemUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    nutrition?: NullableJsonNullValueInput | InputJsonValue
    allergens?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuVariantCreateManyMenuItemInput = {
    id?: number
    label: string
    basePriceCents: number
    baseCapacity?: number | null
    isActive?: boolean
    prepMinutes?: number | null
    packagingCostCents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemAddOnCreateManyMenuItemInput = {
    addOnId: number
    maxQtyPerItem?: number | null
  }

  export type CateringItemCreateManyMenuItemInput = {
    id?: number
    cateringOrderId: number
    nameSnapshot: string
    quantity: number
    unitPriceCents: number
  }

  export type MenuVariantUpdateWithoutMenuItemInput = {
    label?: StringFieldUpdateOperationsInput | string
    basePriceCents?: IntFieldUpdateOperationsInput | number
    baseCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prepMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    packagingCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: MenuOfferingUpdateManyWithoutVariantNestedInput
    orderItems?: OrderItemUpdateManyWithoutVariantNestedInput
  }

  export type MenuVariantUncheckedUpdateWithoutMenuItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    basePriceCents?: IntFieldUpdateOperationsInput | number
    baseCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prepMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    packagingCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: MenuOfferingUncheckedUpdateManyWithoutVariantNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type MenuVariantUncheckedUpdateManyWithoutMenuItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    basePriceCents?: IntFieldUpdateOperationsInput | number
    baseCapacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    prepMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    packagingCostCents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemAddOnUpdateWithoutMenuItemInput = {
    maxQtyPerItem?: NullableIntFieldUpdateOperationsInput | number | null
    addOn?: AddOnUpdateOneRequiredWithoutItemLinksNestedInput
  }

  export type MenuItemAddOnUncheckedUpdateWithoutMenuItemInput = {
    addOnId?: IntFieldUpdateOperationsInput | number
    maxQtyPerItem?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MenuItemAddOnUncheckedUpdateManyWithoutMenuItemInput = {
    addOnId?: IntFieldUpdateOperationsInput | number
    maxQtyPerItem?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CateringItemUpdateWithoutMenuItemInput = {
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    cateringOrder?: CateringOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type CateringItemUncheckedUpdateWithoutMenuItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    cateringOrderId?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
  }

  export type CateringItemUncheckedUpdateManyWithoutMenuItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    cateringOrderId?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
  }

  export type MenuOfferingCreateManyVariantInput = {
    id?: number
    menuId: number
    priceOverrideCents?: number | null
    capacityOverride?: number | null
    isAvailable?: boolean
    maxPerOrder?: number | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemCreateManyVariantInput = {
    id?: number
    orderId: number
    fulfillmentGroupId: number
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    variantLabelSnapshot: string
    imageUrlSnapshot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuOfferingUpdateWithoutVariantInput = {
    priceOverrideCents?: NullableIntFieldUpdateOperationsInput | number | null
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxPerOrder?: NullableIntFieldUpdateOperationsInput | number | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: MenuUpdateOneRequiredWithoutOfferingsNestedInput
    holds?: CapacityHoldUpdateManyWithoutOfferingNestedInput
  }

  export type MenuOfferingUncheckedUpdateWithoutVariantInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    priceOverrideCents?: NullableIntFieldUpdateOperationsInput | number | null
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxPerOrder?: NullableIntFieldUpdateOperationsInput | number | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holds?: CapacityHoldUncheckedUpdateManyWithoutOfferingNestedInput
  }

  export type MenuOfferingUncheckedUpdateManyWithoutVariantInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    priceOverrideCents?: NullableIntFieldUpdateOperationsInput | number | null
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxPerOrder?: NullableIntFieldUpdateOperationsInput | number | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpdateWithoutVariantInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    variantLabelSnapshot?: StringFieldUpdateOperationsInput | string
    imageUrlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    group?: FulfillmentGroupUpdateOneRequiredWithoutItemsNestedInput
    addOns?: OrderItemAddOnUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutVariantInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    fulfillmentGroupId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    variantLabelSnapshot?: StringFieldUpdateOperationsInput | string
    imageUrlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addOns?: OrderItemAddOnUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutVariantInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    fulfillmentGroupId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    variantLabelSnapshot?: StringFieldUpdateOperationsInput | string
    imageUrlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemAddOnCreateManyAddOnInput = {
    menuItemId: number
    maxQtyPerItem?: number | null
  }

  export type OrderItemAddOnCreateManyAddOnInput = {
    id?: number
    orderItemId: number
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
  }

  export type MenuItemAddOnUpdateWithoutAddOnInput = {
    maxQtyPerItem?: NullableIntFieldUpdateOperationsInput | number | null
    menuItem?: MenuItemUpdateOneRequiredWithoutAddOnLinksNestedInput
  }

  export type MenuItemAddOnUncheckedUpdateWithoutAddOnInput = {
    menuItemId?: IntFieldUpdateOperationsInput | number
    maxQtyPerItem?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MenuItemAddOnUncheckedUpdateManyWithoutAddOnInput = {
    menuItemId?: IntFieldUpdateOperationsInput | number
    maxQtyPerItem?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderItemAddOnUpdateWithoutAddOnInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    orderItem?: OrderItemUpdateOneRequiredWithoutAddOnsNestedInput
  }

  export type OrderItemAddOnUncheckedUpdateWithoutAddOnInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderItemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemAddOnUncheckedUpdateManyWithoutAddOnInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderItemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
  }

  export type MenuCreateManyServiceDayInput = {
    id?: number
    menuType?: $Enums.MenuType
    title?: string | null
    isPublished?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceSlotCreateManyServiceDayInput = {
    id?: number
    slotTemplateId: number
    fulfillmentType: $Enums.FulfillmentType
    pickupLocationId?: number | null
    slotKey: string
    capacityOverride?: number | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FulfillmentGroupCreateManyServiceDayInput = {
    id?: number
    orderId: number
    serviceSlotId?: number | null
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateWithoutServiceDayInput = {
    menuType?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: MenuOfferingUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateWithoutServiceDayInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuType?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: MenuOfferingUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateManyWithoutServiceDayInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuType?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceSlotUpdateWithoutServiceDayInput = {
    fulfillmentType?: EnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType
    slotKey?: StringFieldUpdateOperationsInput | string
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: SlotTemplateUpdateOneRequiredWithoutServiceSlotsNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutServiceSlotsNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutServiceSlotNestedInput
  }

  export type ServiceSlotUncheckedUpdateWithoutServiceDayInput = {
    id?: IntFieldUpdateOperationsInput | number
    slotTemplateId?: IntFieldUpdateOperationsInput | number
    fulfillmentType?: EnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    slotKey?: StringFieldUpdateOperationsInput | string
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutServiceSlotNestedInput
  }

  export type ServiceSlotUncheckedUpdateManyWithoutServiceDayInput = {
    id?: IntFieldUpdateOperationsInput | number
    slotTemplateId?: IntFieldUpdateOperationsInput | number
    fulfillmentType?: EnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    slotKey?: StringFieldUpdateOperationsInput | string
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FulfillmentGroupUpdateWithoutServiceDayInput = {
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutGroupsNestedInput
    serviceSlot?: ServiceSlotUpdateOneWithoutGroupsNestedInput
    items?: OrderItemUpdateManyWithoutGroupNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutGroupNestedInput
    events?: OrderEventUpdateManyWithoutGroupNestedInput
  }

  export type FulfillmentGroupUncheckedUpdateWithoutServiceDayInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    serviceSlotId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutGroupNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutGroupNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type FulfillmentGroupUncheckedUpdateManyWithoutServiceDayInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    serviceSlotId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuOfferingCreateManyMenuInput = {
    id?: number
    menuVariantId: number
    priceOverrideCents?: number | null
    capacityOverride?: number | null
    isAvailable?: boolean
    maxPerOrder?: number | null
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuOfferingUpdateWithoutMenuInput = {
    priceOverrideCents?: NullableIntFieldUpdateOperationsInput | number | null
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxPerOrder?: NullableIntFieldUpdateOperationsInput | number | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variant?: MenuVariantUpdateOneRequiredWithoutOfferingsNestedInput
    holds?: CapacityHoldUpdateManyWithoutOfferingNestedInput
  }

  export type MenuOfferingUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuVariantId?: IntFieldUpdateOperationsInput | number
    priceOverrideCents?: NullableIntFieldUpdateOperationsInput | number | null
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxPerOrder?: NullableIntFieldUpdateOperationsInput | number | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holds?: CapacityHoldUncheckedUpdateManyWithoutOfferingNestedInput
  }

  export type MenuOfferingUncheckedUpdateManyWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuVariantId?: IntFieldUpdateOperationsInput | number
    priceOverrideCents?: NullableIntFieldUpdateOperationsInput | number | null
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maxPerOrder?: NullableIntFieldUpdateOperationsInput | number | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapacityHoldCreateManyOfferingInput = {
    id?: number
    orderId?: number | null
    quantity: number
    status?: $Enums.HoldStatus
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type CapacityHoldUpdateWithoutOfferingInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumHoldStatusFieldUpdateOperationsInput | $Enums.HoldStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutCapacityHoldsNestedInput
  }

  export type CapacityHoldUncheckedUpdateWithoutOfferingInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumHoldStatusFieldUpdateOperationsInput | $Enums.HoldStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapacityHoldUncheckedUpdateManyWithoutOfferingInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumHoldStatusFieldUpdateOperationsInput | $Enums.HoldStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceSlotCreateManyPickupLocationInput = {
    id?: number
    serviceDayId: number
    slotTemplateId: number
    fulfillmentType: $Enums.FulfillmentType
    slotKey: string
    capacityOverride?: number | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyPickupLocationInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    deliveryAddressId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceSlotUpdateWithoutPickupLocationInput = {
    fulfillmentType?: EnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType
    slotKey?: StringFieldUpdateOperationsInput | string
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDay?: ServiceDayUpdateOneRequiredWithoutSlotsNestedInput
    template?: SlotTemplateUpdateOneRequiredWithoutServiceSlotsNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutServiceSlotNestedInput
  }

  export type ServiceSlotUncheckedUpdateWithoutPickupLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    slotTemplateId?: IntFieldUpdateOperationsInput | number
    fulfillmentType?: EnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType
    slotKey?: StringFieldUpdateOperationsInput | string
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutServiceSlotNestedInput
  }

  export type ServiceSlotUncheckedUpdateManyWithoutPickupLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    slotTemplateId?: IntFieldUpdateOperationsInput | number
    fulfillmentType?: EnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType
    slotKey?: StringFieldUpdateOperationsInput | string
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutPickupLocationInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    createdBy?: UserUpdateOneWithoutCreatedOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutDeliveryOrdersNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    events?: OrderEventUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPickupLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUncheckedUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutPickupLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyDeliveryAddressInput = {
    id?: number
    userId?: number | null
    createdByUserId?: number | null
    source?: $Enums.OrderSource
    sourceRef?: string | null
    currency?: string
    checkoutStatus?: $Enums.OrderCheckoutStatus
    deliveryPricingMode?: $Enums.DeliveryPricingMode
    fulfillmentType?: $Enums.FulfillmentType | null
    pickupLocationId?: number | null
    deliveryDistanceMiles?: number | null
    customerName?: string | null
    customerEmail?: string | null
    customerPhone?: string | null
    customerNotes?: string | null
    internalNotes?: string | null
    subtotalCents?: number
    adjustmentsCents?: number
    totalCents?: number
    refundedCents?: number
    placedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutDeliveryAddressInput = {
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrdersNestedInput
    createdBy?: UserUpdateOneWithoutCreatedOrdersNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutOrdersNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    events?: OrderEventUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutDeliveryAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutOrderNestedInput
    promoRedemptions?: PromotionRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    capacityHolds?: CapacityHoldUncheckedUpdateManyWithoutOrderNestedInput
    rewardTransactions?: RewardTransactionUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutDeliveryAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    sourceRef?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    checkoutStatus?: EnumOrderCheckoutStatusFieldUpdateOperationsInput | $Enums.OrderCheckoutStatus
    deliveryPricingMode?: EnumDeliveryPricingModeFieldUpdateOperationsInput | $Enums.DeliveryPricingMode
    fulfillmentType?: NullableEnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType | null
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    deliveryDistanceMiles?: NullableFloatFieldUpdateOperationsInput | number | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotalCents?: IntFieldUpdateOperationsInput | number
    adjustmentsCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    refundedCents?: IntFieldUpdateOperationsInput | number
    placedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceSlotCreateManyTemplateInput = {
    id?: number
    serviceDayId: number
    fulfillmentType: $Enums.FulfillmentType
    pickupLocationId?: number | null
    slotKey: string
    capacityOverride?: number | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceSlotUpdateWithoutTemplateInput = {
    fulfillmentType?: EnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType
    slotKey?: StringFieldUpdateOperationsInput | string
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDay?: ServiceDayUpdateOneRequiredWithoutSlotsNestedInput
    pickupLocation?: PickupLocationUpdateOneWithoutServiceSlotsNestedInput
    groups?: FulfillmentGroupUpdateManyWithoutServiceSlotNestedInput
  }

  export type ServiceSlotUncheckedUpdateWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    fulfillmentType?: EnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    slotKey?: StringFieldUpdateOperationsInput | string
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: FulfillmentGroupUncheckedUpdateManyWithoutServiceSlotNestedInput
  }

  export type ServiceSlotUncheckedUpdateManyWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    fulfillmentType?: EnumFulfillmentTypeFieldUpdateOperationsInput | $Enums.FulfillmentType
    pickupLocationId?: NullableIntFieldUpdateOperationsInput | number | null
    slotKey?: StringFieldUpdateOperationsInput | string
    capacityOverride?: NullableIntFieldUpdateOperationsInput | number | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FulfillmentGroupCreateManyServiceSlotInput = {
    id?: number
    orderId: number
    serviceDayId: number
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FulfillmentGroupUpdateWithoutServiceSlotInput = {
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutGroupsNestedInput
    serviceDay?: ServiceDayUpdateOneRequiredWithoutGroupsNestedInput
    items?: OrderItemUpdateManyWithoutGroupNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutGroupNestedInput
    events?: OrderEventUpdateManyWithoutGroupNestedInput
  }

  export type FulfillmentGroupUncheckedUpdateWithoutServiceSlotInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutGroupNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutGroupNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type FulfillmentGroupUncheckedUpdateManyWithoutServiceSlotInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FulfillmentGroupCreateManyOrderInput = {
    id?: number
    serviceDayId: number
    serviceSlotId?: number | null
    status?: $Enums.FulfillmentGroupStatus
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: number
    fulfillmentGroupId: number
    menuVariantId: number
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    variantLabelSnapshot: string
    imageUrlSnapshot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderAdjustmentCreateManyOrderInput = {
    id?: number
    fulfillmentGroupId?: number | null
    type: $Enums.AdjustmentType
    label?: string | null
    amountCents: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PaymentCreateManyOrderInput = {
    id?: number
    provider?: $Enums.PaymentProvider
    method: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    amountCents: number
    providerRef?: string | null
    receivedByUserId?: number | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderEventCreateManyOrderInput = {
    id?: number
    fulfillmentGroupId?: number | null
    type: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PromotionRedemptionCreateManyOrderInput = {
    id?: number
    promotionId: number
    userId?: number | null
    discountCentsApplied: number
    createdAt?: Date | string
  }

  export type CapacityHoldCreateManyOrderInput = {
    id?: number
    menuOfferingId: number
    quantity: number
    status?: $Enums.HoldStatus
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RewardTransactionCreateManyOrderInput = {
    id?: number
    rewardAccountId: number
    type: $Enums.RewardTxnType
    amountPoints: number
    note?: string | null
    createdAt?: Date | string
  }

  export type ReviewCreateManyOrderInput = {
    id?: number
    userId: number
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FulfillmentGroupUpdateWithoutOrderInput = {
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDay?: ServiceDayUpdateOneRequiredWithoutGroupsNestedInput
    serviceSlot?: ServiceSlotUpdateOneWithoutGroupsNestedInput
    items?: OrderItemUpdateManyWithoutGroupNestedInput
    adjustments?: OrderAdjustmentUpdateManyWithoutGroupNestedInput
    events?: OrderEventUpdateManyWithoutGroupNestedInput
  }

  export type FulfillmentGroupUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    serviceSlotId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutGroupNestedInput
    adjustments?: OrderAdjustmentUncheckedUpdateManyWithoutGroupNestedInput
    events?: OrderEventUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type FulfillmentGroupUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceDayId?: IntFieldUpdateOperationsInput | number
    serviceSlotId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumFulfillmentGroupStatusFieldUpdateOperationsInput | $Enums.FulfillmentGroupStatus
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    variantLabelSnapshot?: StringFieldUpdateOperationsInput | string
    imageUrlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: FulfillmentGroupUpdateOneRequiredWithoutItemsNestedInput
    variant?: MenuVariantUpdateOneRequiredWithoutOrderItemsNestedInput
    addOns?: OrderItemAddOnUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    fulfillmentGroupId?: IntFieldUpdateOperationsInput | number
    menuVariantId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    variantLabelSnapshot?: StringFieldUpdateOperationsInput | string
    imageUrlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addOns?: OrderItemAddOnUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    fulfillmentGroupId?: IntFieldUpdateOperationsInput | number
    menuVariantId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    variantLabelSnapshot?: StringFieldUpdateOperationsInput | string
    imageUrlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAdjustmentUpdateWithoutOrderInput = {
    type?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: FulfillmentGroupUpdateOneWithoutAdjustmentsNestedInput
  }

  export type OrderAdjustmentUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    fulfillmentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAdjustmentUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    fulfillmentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutOrderInput = {
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amountCents?: IntFieldUpdateOperationsInput | number
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedBy?: UserUpdateOneWithoutPaymentsReceivedNestedInput
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amountCents?: IntFieldUpdateOperationsInput | number
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amountCents?: IntFieldUpdateOperationsInput | number
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderEventUpdateWithoutOrderInput = {
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: FulfillmentGroupUpdateOneWithoutEventsNestedInput
  }

  export type OrderEventUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    fulfillmentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderEventUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    fulfillmentGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionUpdateWithoutOrderInput = {
    discountCentsApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promotion?: PromotionUpdateOneRequiredWithoutRedemptionsNestedInput
    user?: UserUpdateOneWithoutPromotionRedemptionsNestedInput
  }

  export type PromotionRedemptionUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    discountCentsApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    discountCentsApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapacityHoldUpdateWithoutOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumHoldStatusFieldUpdateOperationsInput | $Enums.HoldStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offering?: MenuOfferingUpdateOneRequiredWithoutHoldsNestedInput
  }

  export type CapacityHoldUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuOfferingId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumHoldStatusFieldUpdateOperationsInput | $Enums.HoldStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapacityHoldUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuOfferingId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumHoldStatusFieldUpdateOperationsInput | $Enums.HoldStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardTransactionUpdateWithoutOrderInput = {
    type?: EnumRewardTxnTypeFieldUpdateOperationsInput | $Enums.RewardTxnType
    amountPoints?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: RewardAccountUpdateOneRequiredWithoutTxnsNestedInput
  }

  export type RewardTransactionUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    rewardAccountId?: IntFieldUpdateOperationsInput | number
    type?: EnumRewardTxnTypeFieldUpdateOperationsInput | $Enums.RewardTxnType
    amountPoints?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardTransactionUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    rewardAccountId?: IntFieldUpdateOperationsInput | number
    type?: EnumRewardTxnTypeFieldUpdateOperationsInput | $Enums.RewardTxnType
    amountPoints?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutOrderInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyGroupInput = {
    id?: number
    orderId: number
    menuVariantId: number
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
    variantLabelSnapshot: string
    imageUrlSnapshot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderAdjustmentCreateManyGroupInput = {
    id?: number
    orderId: number
    type: $Enums.AdjustmentType
    label?: string | null
    amountCents: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderEventCreateManyGroupInput = {
    id?: number
    orderId: number
    type: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutGroupInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    variantLabelSnapshot?: StringFieldUpdateOperationsInput | string
    imageUrlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    variant?: MenuVariantUpdateOneRequiredWithoutOrderItemsNestedInput
    addOns?: OrderItemAddOnUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    menuVariantId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    variantLabelSnapshot?: StringFieldUpdateOperationsInput | string
    imageUrlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addOns?: OrderItemAddOnUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    menuVariantId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    variantLabelSnapshot?: StringFieldUpdateOperationsInput | string
    imageUrlSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAdjustmentUpdateWithoutGroupInput = {
    type?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutAdjustmentsNestedInput
  }

  export type OrderAdjustmentUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    type?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAdjustmentUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    type?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    label?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderEventUpdateWithoutGroupInput = {
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutEventsNestedInput
  }

  export type OrderEventUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderEventUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemAddOnCreateManyOrderItemInput = {
    id?: number
    addOnId?: number | null
    quantity: number
    unitPriceCents: number
    nameSnapshot: string
  }

  export type OrderItemAddOnUpdateWithoutOrderItemInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    addOn?: AddOnUpdateOneWithoutOrderLinksNestedInput
  }

  export type OrderItemAddOnUncheckedUpdateWithoutOrderItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    addOnId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemAddOnUncheckedUpdateManyWithoutOrderItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    addOnId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    nameSnapshot?: StringFieldUpdateOperationsInput | string
  }

  export type PromotionRedemptionCreateManyPromotionInput = {
    id?: number
    orderId: number
    userId?: number | null
    discountCentsApplied: number
    createdAt?: Date | string
  }

  export type PromotionRedemptionUpdateWithoutPromotionInput = {
    discountCentsApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPromoRedemptionsNestedInput
    user?: UserUpdateOneWithoutPromotionRedemptionsNestedInput
  }

  export type PromotionRedemptionUncheckedUpdateWithoutPromotionInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    discountCentsApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionUncheckedUpdateManyWithoutPromotionInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    discountCentsApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardTransactionCreateManyAccountInput = {
    id?: number
    type: $Enums.RewardTxnType
    amountPoints: number
    orderId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type RewardTransactionUpdateWithoutAccountInput = {
    type?: EnumRewardTxnTypeFieldUpdateOperationsInput | $Enums.RewardTxnType
    amountPoints?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutRewardTransactionsNestedInput
  }

  export type RewardTransactionUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRewardTxnTypeFieldUpdateOperationsInput | $Enums.RewardTxnType
    amountPoints?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardTransactionUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRewardTxnTypeFieldUpdateOperationsInput | $Enums.RewardTxnType
    amountPoints?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CateringItemCreateManyCateringOrderInput = {
    id?: number
    menuItemId?: number | null
    nameSnapshot: string
    quantity: number
    unitPriceCents: number
  }

  export type CateringItemUpdateWithoutCateringOrderInput = {
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    menuItem?: MenuItemUpdateOneWithoutCateringItemsNestedInput
  }

  export type CateringItemUncheckedUpdateWithoutCateringOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuItemId?: NullableIntFieldUpdateOperationsInput | number | null
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
  }

  export type CateringItemUncheckedUpdateManyWithoutCateringOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuItemId?: NullableIntFieldUpdateOperationsInput | number | null
    nameSnapshot?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}